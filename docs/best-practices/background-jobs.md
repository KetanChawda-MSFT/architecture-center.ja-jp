---
title: バックグラウンド ジョブのガイダンス
description: ユーザー インターフェイスとは無関係に実行されるバックグラウンド タスクに関するガイダンスです。
author: dragon119
ms.date: 05/24/2017
pnp.series.title: Best Practices
ms.openlocfilehash: 10c24afee4b880cfbf8ee534f4d7f945d2b046a9
ms.sourcegitcommit: 3426a9c5ed937f097725c487cf3d073ae5e2a347
ms.translationtype: HT
ms.contentlocale: ja-JP
ms.lasthandoff: 02/01/2018
---
# <a name="background-jobs"></a><span data-ttu-id="121d9-103">バックグラウンド ジョブ</span><span class="sxs-lookup"><span data-stu-id="121d9-103">Background jobs</span></span>
[!INCLUDE [header](../_includes/header.md)]

<span data-ttu-id="121d9-104">ユーザー インターフェイス (UI) とは無関係に実行されるバックグラウンド タスクは、さまざまな種類のアプリケーションで重要な役割を果たしています。</span><span class="sxs-lookup"><span data-stu-id="121d9-104">Many types of applications require background tasks that run independently of the user interface (UI).</span></span> <span data-ttu-id="121d9-105">その例として、バッチ ジョブ、多くの処理能力を消費するタスク、長時間実行されるプロセス (ワークフローなど) を挙げることができます。</span><span class="sxs-lookup"><span data-stu-id="121d9-105">Examples include batch jobs, intensive processing tasks, and long-running processes such as workflows.</span></span> <span data-ttu-id="121d9-106">バックグラウンド ジョブの実行は、ユーザーの介入を必要としません。アプリケーションでジョブを起動した後も、ユーザーから対話式に送られる要求を処理し続けることができます。</span><span class="sxs-lookup"><span data-stu-id="121d9-106">Background jobs can be executed without requiring user interaction--the application can start the job and then continue to process interactive requests from users.</span></span> <span data-ttu-id="121d9-107">アプリケーションの UI に対する負荷が小さくなるので、稼働率が向上し、対話の応答時間が短縮されます。</span><span class="sxs-lookup"><span data-stu-id="121d9-107">This can help to minimize the load on the application UI, which can improve availability and reduce interactive response times.</span></span>

<span data-ttu-id="121d9-108">たとえば、ユーザーからアップロードされた画像のサムネイルをアプリケーションで生成する場合、その処理をバックグラウンド ジョブとして実行し、完成したサムネイルを記憶域に保存することができます。処理が完了するまでユーザーを待たせる必要はありません。</span><span class="sxs-lookup"><span data-stu-id="121d9-108">For example, if an application is required to generate thumbnails of images that are uploaded by users, it can do this as a background job and save the thumbnail to storage when it is complete--without the user needing to wait for the process to be completed.</span></span> <span data-ttu-id="121d9-109">同様に、何かを購入する状況においても、注文を処理するワークフローをバックグラウンドで開始すれば、その間もユーザーは UI を使って Web アプリを閲覧することができます。</span><span class="sxs-lookup"><span data-stu-id="121d9-109">In the same way, a user placing an order can initiate a background workflow that processes the order, while the UI allows the user to continue browsing the web app.</span></span> <span data-ttu-id="121d9-110">バックグラウンド ジョブが完了した時点で、保存された注文データを更新し、注文内容を確認するメールをユーザーに送信することが可能です。</span><span class="sxs-lookup"><span data-stu-id="121d9-110">When the background job is complete, it can update the stored orders data and send an email to the user that confirms the order.</span></span>

<span data-ttu-id="121d9-111">特定のタスクをバックグラウンド ジョブとして実装するかどうかの主要な判断基準は、そのタスクが、ユーザーの介入なしで実行できるかどうかと、ジョブの完了まで UI を待機状態にする必要があるかどうかです。</span><span class="sxs-lookup"><span data-stu-id="121d9-111">When you consider whether to implement a task as a background job, the main criteria is whether the task can run without user interaction and without the UI needing to wait for the job to be completed.</span></span> <span data-ttu-id="121d9-112">完了までユーザーまたは UI を待機させる必要のあるタスクは、バックグラウンド ジョブに適していない可能性があります。</span><span class="sxs-lookup"><span data-stu-id="121d9-112">Tasks that require the user or the UI to wait while they are completed might not be appropriate as background jobs.</span></span>

## <a name="types-of-background-jobs"></a><span data-ttu-id="121d9-113">バックグラウンド ジョブの種類</span><span class="sxs-lookup"><span data-stu-id="121d9-113">Types of background jobs</span></span>
<span data-ttu-id="121d9-114">バックグラウンド ジョブには次のような種類があります。</span><span class="sxs-lookup"><span data-stu-id="121d9-114">Background jobs typically include one or more of the following types of jobs:</span></span>

* <span data-ttu-id="121d9-115">CPU に負荷のかかるジョブ (数学的計算、構造モデル分析など)。</span><span class="sxs-lookup"><span data-stu-id="121d9-115">CPU-intensive jobs, such as mathematical calculations or structural model analysis.</span></span>
* <span data-ttu-id="121d9-116">入出力の多いジョブ (一連のストレージ トランザクションの実行、ファイルのインデックス作成など)。</span><span class="sxs-lookup"><span data-stu-id="121d9-116">I/O-intensive jobs, such as executing a series of storage transactions or indexing files.</span></span>
* <span data-ttu-id="121d9-117">バッチ ジョブ (夜間のデータ更新、スケジュール設定された処理など)。</span><span class="sxs-lookup"><span data-stu-id="121d9-117">Batch jobs, such as nightly data updates or scheduled processing.</span></span>
* <span data-ttu-id="121d9-118">長時間実行されるワークフロー (受注処理、サービスやシステムのプロビジョニングなど)。</span><span class="sxs-lookup"><span data-stu-id="121d9-118">Long-running workflows, such as order fulfillment, or provisioning services and systems.</span></span>
* <span data-ttu-id="121d9-119">機密データ処理 (より安全な場所にタスクが引き渡されて処理される)。</span><span class="sxs-lookup"><span data-stu-id="121d9-119">Sensitive-data processing where the task is handed off to a more secure location for processing.</span></span> <span data-ttu-id="121d9-120">たとえば、機密データは、Web アプリ内で処理するより、</span><span class="sxs-lookup"><span data-stu-id="121d9-120">For example, you might not want to process sensitive data within a web app.</span></span> <span data-ttu-id="121d9-121">[Gatekeeper](http://msdn.microsoft.com/library/dn589793.aspx) などのパターンに従い、保護された記憶域にアクセスできる分離されたバックグラウンド プロセスにデータを転送した方が賢明です。</span><span class="sxs-lookup"><span data-stu-id="121d9-121">Instead, you might use a pattern such as [Gatekeeper](http://msdn.microsoft.com/library/dn589793.aspx) to transfer the data to an isolated background process that has access to protected storage.</span></span>

## <a name="triggers"></a><span data-ttu-id="121d9-122">トリガー</span><span class="sxs-lookup"><span data-stu-id="121d9-122">Triggers</span></span>
<span data-ttu-id="121d9-123">バックグラウンド ジョブは、さまざまな方法で開始することができます。</span><span class="sxs-lookup"><span data-stu-id="121d9-123">Background jobs can be initiated in several different ways.</span></span> <span data-ttu-id="121d9-124">大きく次の 2 つのカテゴリに分けられます。</span><span class="sxs-lookup"><span data-stu-id="121d9-124">They fall into one of the following categories:</span></span>

* <span data-ttu-id="121d9-125">[**イベント ドリブン トリガー**](#event-driven-triggers)。</span><span class="sxs-lookup"><span data-stu-id="121d9-125">[**Event-driven triggers**](#event-driven-triggers).</span></span> <span data-ttu-id="121d9-126">イベント (通常、ユーザーが実行する操作またはワークフロー内のステップ) に反応する形でタスクが開始されます。</span><span class="sxs-lookup"><span data-stu-id="121d9-126">The task is started in response to an event, typically an action taken by a user or a step in a workflow.</span></span>
* <span data-ttu-id="121d9-127">[**スケジュール ドリブン トリガー**](#schedule-driven-triggers)。</span><span class="sxs-lookup"><span data-stu-id="121d9-127">[**Schedule-driven triggers**](#schedule-driven-triggers).</span></span> <span data-ttu-id="121d9-128">タイマーに基づくスケジュールに従ってタスクが呼び出されます。</span><span class="sxs-lookup"><span data-stu-id="121d9-128">The task is invoked on a schedule based on a timer.</span></span> <span data-ttu-id="121d9-129">スケジュールに従って定期的に呼び出すことも、指定された時刻に 1 回だけ呼び出すこともできます。</span><span class="sxs-lookup"><span data-stu-id="121d9-129">This might be a recurring schedule or a one-off invocation that is specified for a later time.</span></span>

### <a name="event-driven-triggers"></a><span data-ttu-id="121d9-130">イベント ドリブン トリガー</span><span class="sxs-lookup"><span data-stu-id="121d9-130">Event-driven triggers</span></span>
<span data-ttu-id="121d9-131">イベント ドリブン型の呼び出しでは、トリガーを使ってバックグラウンド タスクが開始されます。</span><span class="sxs-lookup"><span data-stu-id="121d9-131">Event-driven invocation uses a trigger to start the background task.</span></span> <span data-ttu-id="121d9-132">イベント ドリブン トリガーの例を次に示します。</span><span class="sxs-lookup"><span data-stu-id="121d9-132">Examples of using event-driven triggers include:</span></span>

* <span data-ttu-id="121d9-133">UI やその他のジョブによってキューにメッセージが追加されます。</span><span class="sxs-lookup"><span data-stu-id="121d9-133">The UI or another job places a message in a queue.</span></span> <span data-ttu-id="121d9-134">メッセージに含まれているのは、実行された操作 (ユーザーによる注文など) に関するデータです。</span><span class="sxs-lookup"><span data-stu-id="121d9-134">The message contains data about an action that has taken place, such as the user placing an order.</span></span> <span data-ttu-id="121d9-135">バックグラウンド タスクは、このキューで待機し、新しいメッセージの到着を検出します。</span><span class="sxs-lookup"><span data-stu-id="121d9-135">The background task listens on this queue and detects the arrival of a new message.</span></span> <span data-ttu-id="121d9-136">そのメッセージが読み取られ、その中のデータが、バックグラウンド ジョブの入力として使用されます。</span><span class="sxs-lookup"><span data-stu-id="121d9-136">It reads the message and uses the data in it as the input to the background job.</span></span>
* <span data-ttu-id="121d9-137">UI やその他のジョブによって記憶域に値が保存されるか値が更新されます。</span><span class="sxs-lookup"><span data-stu-id="121d9-137">The UI or another job saves or updates a value in storage.</span></span> <span data-ttu-id="121d9-138">バックグラウンド タスクは記憶域を監視し、変更を検出します。</span><span class="sxs-lookup"><span data-stu-id="121d9-138">The background task monitors the storage and detects changes.</span></span> <span data-ttu-id="121d9-139">そのデータが読み取られ、バックグラウンド ジョブの入力として使用されます。</span><span class="sxs-lookup"><span data-stu-id="121d9-139">It reads the data and uses it as the input to the background job.</span></span>
* <span data-ttu-id="121d9-140">UI やその他のジョブからエンドポイント (Web サービスとして公開されている API、HTTPS URI など) に要求が送られます。</span><span class="sxs-lookup"><span data-stu-id="121d9-140">The UI or another job makes a request to an endpoint, such as an HTTPS URI, or an API that is exposed as a web service.</span></span> <span data-ttu-id="121d9-141">その際バックグラウンド タスクを実行するために必要なデータは要求の一部として渡されます。</span><span class="sxs-lookup"><span data-stu-id="121d9-141">It passes the data that is required to complete the background task as part of the request.</span></span> <span data-ttu-id="121d9-142">エンドポイントまたは Web サービスがバックグラウンド タスクを呼び出すときに、そのデータが入力として使用されます。</span><span class="sxs-lookup"><span data-stu-id="121d9-142">The endpoint or web service invokes the background task, which uses the data as its input.</span></span>

<span data-ttu-id="121d9-143">イベント ドリブンの呼び出しに適したタスクの例としては、画像処理、ワークフロー、リモート サービスへの情報送信、電子メール メッセージの送信、マルチテナント アプリケーションへの新しいユーザーのプロビジョニングが代表的です。</span><span class="sxs-lookup"><span data-stu-id="121d9-143">Typical examples of tasks that are suited to event-driven invocation include image processing, workflows, sending information to remote services, sending email messages, and provisioning new users in multitenant applications.</span></span>

### <a name="schedule-driven-triggers"></a><span data-ttu-id="121d9-144">スケジュール ドリブン トリガー</span><span class="sxs-lookup"><span data-stu-id="121d9-144">Schedule-driven triggers</span></span>
<span data-ttu-id="121d9-145">スケジュール ドリブン型の呼び出しでは、タイマーを使ってバックグラウンド タスクが開始されます。</span><span class="sxs-lookup"><span data-stu-id="121d9-145">Schedule-driven invocation uses a timer to start the background task.</span></span> <span data-ttu-id="121d9-146">スケジュール ドリブン トリガーの例を次に示します。</span><span class="sxs-lookup"><span data-stu-id="121d9-146">Examples of using schedule-driven triggers include:</span></span>

* <span data-ttu-id="121d9-147">同じアプリケーション内でローカルに実行されているタイマーまたはその動作環境であるオペレーティング システムの機能として実行されているタイマーによってバックグラウンド タスクが定期的に呼び出されます。</span><span class="sxs-lookup"><span data-stu-id="121d9-147">A timer that is running locally within the application or as part of the application’s operating system invokes a background task on a regular basis.</span></span>
* <span data-ttu-id="121d9-148">別のアプリケーションで実行されているタイマーまたは Azure Scheduler などのタイマー サービスから API や Web サービスに対して定期的に要求が送られます。</span><span class="sxs-lookup"><span data-stu-id="121d9-148">A timer that is running in a different application, or a timer service such as Azure Scheduler, sends a request to an API or web service on a regular basis.</span></span> <span data-ttu-id="121d9-149">その API または Web サービスによってバックグラウンド タスクが呼び出されます。</span><span class="sxs-lookup"><span data-stu-id="121d9-149">The API or web service invokes the background task.</span></span>
* <span data-ttu-id="121d9-150">別のプロセスまたはアプリケーションによってタイマーが起動され、指定された時間の経過後または特定の時刻にバックグラウンド タスクが呼び出されます。</span><span class="sxs-lookup"><span data-stu-id="121d9-150">A separate process or application starts a timer that causes the background task to be invoked once after a specified time delay, or at a specific time.</span></span>

<span data-ttu-id="121d9-151">スケジュール ドリブンで呼び出すことが適しているタスクの例としては、バッチ処理ルーチン (ユーザーの直近の行動に基づいて、表示する関連製品一覧を更新するなど)、ルーチン データ処理タスク (インデックスの更新、蓄積された結果の生成など)、日次レポート用のデータ分析、データのリテンション期間のクリーンアップ、データ一貫性チェックが代表的です。</span><span class="sxs-lookup"><span data-stu-id="121d9-151">Typical examples of tasks that are suited to schedule-driven invocation include batch-processing routines (such as updating related-products lists for users based on their recent behavior), routine data processing tasks (such as updating indexes or generating accumulated results), data analysis for daily reports, data retention cleanup, and data consistency checks.</span></span>

<span data-ttu-id="121d9-152">スケジュール ドリブンのタスクを単一のインスタンスとして実行する必要がある場合は、次の点に注意してください。</span><span class="sxs-lookup"><span data-stu-id="121d9-152">If you use a schedule-driven task that must run as a single instance, be aware of the following:</span></span>

* <span data-ttu-id="121d9-153">スケジューラを実行するコンピューティング インスタンス (Windows のスケジュール タスクを使用する仮想マシンなど) がスケーリングされた場合、そのスケジューラのインスタンスが複数実行され、</span><span class="sxs-lookup"><span data-stu-id="121d9-153">If the compute instance that is running the scheduler (such as a virtual machine using Windows scheduled tasks) is scaled, you will have multiple instances of the scheduler running.</span></span> <span data-ttu-id="121d9-154">タスクのインスタンスも複数起動される可能性があります。</span><span class="sxs-lookup"><span data-stu-id="121d9-154">These could start multiple instances of the task.</span></span>
* <span data-ttu-id="121d9-155">タスクの実行時間がスケジューラのイベントの発生間隔を超えた場合、先に起動されたインスタンスが終わる前に、スケジューラによってタスクのインスタンスがもう 1 つ起動されます。</span><span class="sxs-lookup"><span data-stu-id="121d9-155">If tasks run for longer than the period between scheduler events, the scheduler may start another instance of the task while the previous one is still running.</span></span>

## <a name="returning-results"></a><span data-ttu-id="121d9-156">結果の出力</span><span class="sxs-lookup"><span data-stu-id="121d9-156">Returning results</span></span>
<span data-ttu-id="121d9-157">バックグラウンド ジョブは、その呼び出し元となった UI やプロセスとは独立したプロセスで (または場合によっては別の場所で) 非同期的に実行されます。</span><span class="sxs-lookup"><span data-stu-id="121d9-157">Background jobs execute asynchronously in a separate process, or even in a separate location, from the UI or the process that invoked the background task.</span></span> <span data-ttu-id="121d9-158">バックグラウンド タスクは、開始後放置できること、またその実行中に UI や呼び出し元のプロセスに影響を与えないことが理想です。</span><span class="sxs-lookup"><span data-stu-id="121d9-158">Ideally, background tasks are “fire and forget” operations, and their execution progress has no impact on the UI or the calling process.</span></span> <span data-ttu-id="121d9-159">呼び出し元のプロセスはタスクの完了を待機せず、</span><span class="sxs-lookup"><span data-stu-id="121d9-159">This means that the calling process does not wait for completion of the tasks.</span></span> <span data-ttu-id="121d9-160">いつタスクが完了するかを自動的には検出できません。</span><span class="sxs-lookup"><span data-stu-id="121d9-160">Therefore, it cannot automatically detect when the task ends.</span></span>

<span data-ttu-id="121d9-161">バックグラウンド タスクが呼び出し元のタスクと情報をやり取りし、進行状況や完了を伝えることができるようにするには、そのための機構を実装する必要があります。</span><span class="sxs-lookup"><span data-stu-id="121d9-161">If you require a background task to communicate with the calling task to indicate progress or completion, you must implement a mechanism for this.</span></span> <span data-ttu-id="121d9-162">次に例をいくつか示します。</span><span class="sxs-lookup"><span data-stu-id="121d9-162">Some examples are:</span></span>

* <span data-ttu-id="121d9-163">UI や呼び出し元のタスクからアクセスできる記憶域にステータス インジケーターの値を書き込み、呼び出し元が必要に応じてその値を監視、確認できるようにする。</span><span class="sxs-lookup"><span data-stu-id="121d9-163">Write a status indicator value to storage that is accessible to the UI or caller task, which can monitor or check this value when required.</span></span> <span data-ttu-id="121d9-164">その他、バックグラウンド タスクから呼び出し元に返す必要のあるデータも同じ記憶域に格納することができます。</span><span class="sxs-lookup"><span data-stu-id="121d9-164">Other data that the background task must return to the caller can be placed into the same storage.</span></span>
* <span data-ttu-id="121d9-165">応答キューを設定し、そこで UI または呼び出し元を待機させる。</span><span class="sxs-lookup"><span data-stu-id="121d9-165">Establish a reply queue that the UI or caller listens on.</span></span> <span data-ttu-id="121d9-166">バックグラウンド タスクは、このキューにメッセージを送ることでステータスや完了を知らせることができます。</span><span class="sxs-lookup"><span data-stu-id="121d9-166">The background task can send messages to the queue that indicate status and completion.</span></span> <span data-ttu-id="121d9-167">バックグラウンド タスクから呼び出し元に返す必要のあるデータもそのメッセージに格納することができます。</span><span class="sxs-lookup"><span data-stu-id="121d9-167">Data that the background task must return to the caller can be placed into the messages.</span></span> <span data-ttu-id="121d9-168">Azure Service Bus を使っている場合、**ReplyTo** プロパティと **CorrelationId** プロパティを使ってこの機能を実装できます。</span><span class="sxs-lookup"><span data-stu-id="121d9-168">If you are using Azure Service Bus, you can use the **ReplyTo** and **CorrelationId** properties to implement this capability.</span></span> <span data-ttu-id="121d9-169">詳細については、 [Service Bus ブローカー メッセージングにおける相関](http://www.cloudcasts.net/devguide/Default.aspx?id=13029)に関するページを参照してください。</span><span class="sxs-lookup"><span data-stu-id="121d9-169">For more information, see [Correlation in Service Bus Brokered Messaging](http://www.cloudcasts.net/devguide/Default.aspx?id=13029).</span></span>
* <span data-ttu-id="121d9-170">UI や呼び出し元がステータス情報を取得する目的でアクセスできる API またはエンドポイントをバックグラウンド タスク側で公開する。</span><span class="sxs-lookup"><span data-stu-id="121d9-170">Expose an API or endpoint from the background task that the UI or caller can access to obtain status information.</span></span> <span data-ttu-id="121d9-171">その応答に、バックグラウンド タスクから呼び出し元に返す必要のあるデータを格納することができます。</span><span class="sxs-lookup"><span data-stu-id="121d9-171">Data that the background task must return to the caller can be included in the response.</span></span>
* <span data-ttu-id="121d9-172">バックグラウンド タスクから API を介して UI や呼び出し元をコールバックし、定義済みのポイントや完了時点でステータスを通知する。</span><span class="sxs-lookup"><span data-stu-id="121d9-172">Have the background task call back to the UI or caller through an API to indicate status at predefined points or on completion.</span></span> <span data-ttu-id="121d9-173">コールバックのタイミングとしては、ローカルで発生するイベントや、パブリッシュとサブスクライブのメカニズムを利用することができます。</span><span class="sxs-lookup"><span data-stu-id="121d9-173">This might be through events raised locally or through a publish-and-subscribe mechanism.</span></span> <span data-ttu-id="121d9-174">バックグラウンド タスクから呼び出し元に返す必要のあるデータは、要求またはイベントのペイロードに格納することができます。</span><span class="sxs-lookup"><span data-stu-id="121d9-174">Data that the background task must return to the caller can be included in the request or event payload.</span></span>

## <a name="hosting-environment"></a><span data-ttu-id="121d9-175">ホスティング環境</span><span class="sxs-lookup"><span data-stu-id="121d9-175">Hosting environment</span></span>
<span data-ttu-id="121d9-176">バックグラウンド タスクは、Azure の各種プラットフォーム サービスを使ってホストすることができます。</span><span class="sxs-lookup"><span data-stu-id="121d9-176">You can host background tasks by using a range of different Azure platform services:</span></span>

* <span data-ttu-id="121d9-177">[**Azure Web アプリと Web ジョブ**](#azure-web-apps-and-webjobs)。</span><span class="sxs-lookup"><span data-stu-id="121d9-177">[**Azure Web Apps and WebJobs**](#azure-web-apps-and-webjobs).</span></span> <span data-ttu-id="121d9-178">Web ジョブを使うと、各種のスクリプトや実行可能プログラムをカスタム ジョブとして Web アプリのコンテキスト内で実行することができます。</span><span class="sxs-lookup"><span data-stu-id="121d9-178">You can use WebJobs to execute custom jobs based on a range of different types of scripts or executable programs within the context of a web app.</span></span>
* <span data-ttu-id="121d9-179">[**Azure Virtual Machines**](#azure-virtual-machines)。</span><span class="sxs-lookup"><span data-stu-id="121d9-179">[**Azure Virtual Machines**](#azure-virtual-machines).</span></span> <span data-ttu-id="121d9-180">Windows サービスがある場合または Windows タスク スケジューラを使用する場合、バックグラウンド タスクを専用の仮想マシンにホストするのが一般的です。</span><span class="sxs-lookup"><span data-stu-id="121d9-180">If you have a Windows service or want to use the Windows Task Scheduler, it is common to host your background tasks within a dedicated virtual machine.</span></span>
* <span data-ttu-id="121d9-181">[**Azure Batch**](#azure-batch)。</span><span class="sxs-lookup"><span data-stu-id="121d9-181">[**Azure Batch**](#azure-batch).</span></span> <span data-ttu-id="121d9-182">バッチは、仮想マシンの管理されたコレクションを実行するため、大量の計算を必要とする作業をスケジュールするためのプラットフォーム サービスです。</span><span class="sxs-lookup"><span data-stu-id="121d9-182">Batch is a platform service that schedules compute-intensive work to run on a managed collection of virtual machines.</span></span> <span data-ttu-id="121d9-183">自動的にコンピューティング リソースを拡張できます。</span><span class="sxs-lookup"><span data-stu-id="121d9-183">It can automatically scale compute resources.</span></span>
* <span data-ttu-id="121d9-184">[**Azure Container Service**](#azure-container-service)。</span><span class="sxs-lookup"><span data-stu-id="121d9-184">[**Azure Container Service**](#azure-container-service).</span></span> <span data-ttu-id="121d9-185">Azure Container Service は Azure コンテナー ホスト環境です。</span><span class="sxs-lookup"><span data-stu-id="121d9-185">Azure Container Service provides a container hosting environment on Azure.</span></span> 
* <span data-ttu-id="121d9-186">[**Azure Cloud Services**](#azure-cloud-services)。</span><span class="sxs-lookup"><span data-stu-id="121d9-186">[**Azure Cloud Services**](#azure-cloud-services).</span></span> <span data-ttu-id="121d9-187">バックグラウンド タスクとして動作するロールにコードを記述することができます。</span><span class="sxs-lookup"><span data-stu-id="121d9-187">You can write code within a role that executes as a background task.</span></span>

<span data-ttu-id="121d9-188">以降のセクションでそれぞれの方法について詳しく説明すると共に、適切な方法を選ぶうえでの注意事項を取り上げます。</span><span class="sxs-lookup"><span data-stu-id="121d9-188">The following sections describe each of these options in more detail, and include considerations to help you choose the appropriate option.</span></span>

### <a name="azure-web-apps-and-webjobs"></a><span data-ttu-id="121d9-189">Azure Web アプリと Web ジョブ</span><span class="sxs-lookup"><span data-stu-id="121d9-189">Azure Web Apps and WebJobs</span></span>

<span data-ttu-id="121d9-190">Azure Web ジョブを使うと、Azure Web アプリ内でカスタム ジョブをバックグラウンド タスクとして実行できます。</span><span class="sxs-lookup"><span data-stu-id="121d9-190">You can use Azure WebJobs to execute custom jobs as background tasks within an Azure Web App.</span></span> <span data-ttu-id="121d9-191">Web ジョブは、Web アプリのコンテキスト内で継続するプロセスとして実行されます。</span><span class="sxs-lookup"><span data-stu-id="121d9-191">WebJobs run within the context of your web app as a continuous process.</span></span> <span data-ttu-id="121d9-192">または、Azure Scheduler や外的要因 (ストレージ BLOB やメッセージ キューに対する変更など) からのトリガー イベントに反応する形で実行されます。</span><span class="sxs-lookup"><span data-stu-id="121d9-192">WebJobs also run in response to a trigger event from Azure Scheduler or external factors, such as changes to storage blobs and message queues.</span></span> <span data-ttu-id="121d9-193">ジョブは、起動と停止をオンデマンドで行うことができ、正規の手順でシャットダウンすることができます。</span><span class="sxs-lookup"><span data-stu-id="121d9-193">Jobs can be started and stopped on demand, and shut down gracefully.</span></span> <span data-ttu-id="121d9-194">継続的に実行される Web ジョブは、エラーが発生した場合、自動的に再起動されます。</span><span class="sxs-lookup"><span data-stu-id="121d9-194">If a continuously running WebJob fails, it is automatically restarted.</span></span> <span data-ttu-id="121d9-195">再試行とエラーのアクションは、設定で変更することができます。</span><span class="sxs-lookup"><span data-stu-id="121d9-195">Retry and error actions are configurable.</span></span>

<span data-ttu-id="121d9-196">Web ジョブを構成する際の注意事項を次に示します。</span><span class="sxs-lookup"><span data-stu-id="121d9-196">When you configure a WebJob:</span></span>

* <span data-ttu-id="121d9-197">イベント ドリブン トリガーを使ってジョブを起動する場合は、 **[連続的に実行]**として構成する必要があります。</span><span class="sxs-lookup"><span data-stu-id="121d9-197">If you want the job to respond to an event-driven trigger, you should configure it as **Run continuously**.</span></span> <span data-ttu-id="121d9-198">スクリプトまたはプログラムは、"site/wwwroot/app_data/jobs/continuous" という名前のフォルダーに格納されます。</span><span class="sxs-lookup"><span data-stu-id="121d9-198">The script or program is stored in the folder named site/wwwroot/app_data/jobs/continuous.</span></span>
* <span data-ttu-id="121d9-199">スケジュール ドリブン トリガーを使ってジョブを起動する場合は、 **[スケジュールに従って実行]**として構成する必要があります。</span><span class="sxs-lookup"><span data-stu-id="121d9-199">If you want the job to respond to a schedule-driven trigger, you should configure it as **Run on a schedule**.</span></span> <span data-ttu-id="121d9-200">スクリプトまたはプログラムは、"site/wwwroot/app_data/jobs/triggered" という名前のフォルダーに格納されます。</span><span class="sxs-lookup"><span data-stu-id="121d9-200">The script or program is stored in the folder named site/wwwroot/app_data/jobs/triggered.</span></span>
* <span data-ttu-id="121d9-201">ジョブを構成するときに **[オンデマンドで実行]** オプションを選択した場合、**[スケジュールに従って実行]** オプションと同じコードが起動時に実行されます。</span><span class="sxs-lookup"><span data-stu-id="121d9-201">If you choose the **Run on demand** option when you configure a job, it will execute the same code as the **Run on a schedule** option when you start it.</span></span>

<span data-ttu-id="121d9-202">Azure Web ジョブは、Web アプリのサンドボックス内で実行されます。</span><span class="sxs-lookup"><span data-stu-id="121d9-202">Azure WebJobs run within the sandbox of the web app.</span></span> <span data-ttu-id="121d9-203">つまり、環境変数にアクセスして、接続文字列などの情報を Web アプリとの間で共有することができます。</span><span class="sxs-lookup"><span data-stu-id="121d9-203">This means that they can access environment variables and share information, such as connection strings, with the web app.</span></span> <span data-ttu-id="121d9-204">Web ジョブは、それを実行しているコンピューターの一意の識別子にアクセスすることができます。</span><span class="sxs-lookup"><span data-stu-id="121d9-204">The job has access to the unique identifier of the machine that is running the job.</span></span> <span data-ttu-id="121d9-205">Azure Storage のキューや BLOB、テーブルにアクセスしてアプリケーション データを取得したり、Service Bus にアクセスしてメッセージングや通信を行ったりするには、 **AzureWebJobsStorage** という接続文字列を使用します。</span><span class="sxs-lookup"><span data-stu-id="121d9-205">The connection string named **AzureWebJobsStorage** provides access to Azure storage queues, blobs, and tables for application data, and access to Service Bus for messaging and communication.</span></span> <span data-ttu-id="121d9-206">ジョブのアクション ログ ファイルにアクセスするには、 **AzureWebJobsDashboard** という接続文字列を使用します。</span><span class="sxs-lookup"><span data-stu-id="121d9-206">The connection string named **AzureWebJobsDashboard** provides access to the job action log files.</span></span>

<span data-ttu-id="121d9-207">Azure の Web ジョブの特徴を次に示します。</span><span class="sxs-lookup"><span data-stu-id="121d9-207">Azure WebJobs have the following characteristics:</span></span>

* <span data-ttu-id="121d9-208">**セキュリティ**: Web ジョブの保護には、Web アプリのデプロイ資格情報が使用されます。</span><span class="sxs-lookup"><span data-stu-id="121d9-208">**Security**: WebJobs are protected by the deployment credentials of the web app.</span></span>
* <span data-ttu-id="121d9-209">**サポートされるファイルの種類**: Web ジョブは、コマンド スクリプト (.cmd)、バッチ ファイル (.bat)、PowerShell スクリプト (.ps1)、bash シェル スクリプト (.sh)、PHP スクリプト (.php)、Python スクリプト (.py)、JavaScript コード (.js)、実行可能プログラム (.exe、.jar など) を使って定義することができます。</span><span class="sxs-lookup"><span data-stu-id="121d9-209">**Supported file types**: You can define WebJobs by using command scripts (.cmd), batch files (.bat), PowerShell scripts (.ps1), bash shell scripts (.sh), PHP scripts (.php), Python scripts (.py), JavaScript code (.js), and executable programs (.exe, .jar, and more).</span></span>
* <span data-ttu-id="121d9-210">**デプロイ**: スクリプトと実行可能ファイルは、Azure ポータル、Visual Studio の [WebJobsVs](/azure/app-service-web/web-sites-create-web-jobs) アドインまたは [Visual Studio 2013 Update 4](/azure/app-service-web/websites-dotnet-deploy-webjobs) (作成からデプロイまで)、または [Azure WebJobs SDK](/azure/azure-webjobs-sdk) を使ってデプロイできます。スクリプトと実行可能ファイルを次の場所に直接コピーしてデプロイすることもできます。</span><span class="sxs-lookup"><span data-stu-id="121d9-210">**Deployment**: You can deploy scripts and executables by using the [Azure portal](/azure/app-service-web/web-sites-create-web-jobs), by using [Visual Studio](/azure/app-service-web/websites-dotnet-deploy-webjobs), by using the [Azure WebJobs SDK](/azure/azure-webjobs-sdk), or by copying them directly to the following locations:</span></span>
  * <span data-ttu-id="121d9-211">トリガーによって実行する場合: site/wwwroot/app_data/jobs/triggered/{job name}</span><span class="sxs-lookup"><span data-stu-id="121d9-211">For triggered execution: site/wwwroot/app_data/jobs/triggered/{job name}</span></span>
  * <span data-ttu-id="121d9-212">連続実行の場合: site/wwwroot/app_data/jobs/continuous/{job name}</span><span class="sxs-lookup"><span data-stu-id="121d9-212">For continuous execution: site/wwwroot/app_data/jobs/continuous/{job name}</span></span>
* <span data-ttu-id="121d9-213">**ログ**: Console.Out は INFO として処理 (マーク) されます。</span><span class="sxs-lookup"><span data-stu-id="121d9-213">**Logging**: Console.Out is treated (marked) as INFO.</span></span> <span data-ttu-id="121d9-214">Console.Error は ERROR として処理 (マーク) されます。</span><span class="sxs-lookup"><span data-stu-id="121d9-214">Console.Error is treated as ERROR.</span></span> <span data-ttu-id="121d9-215">監視情報と診断情報には、Azure ポータルからアクセスできます。</span><span class="sxs-lookup"><span data-stu-id="121d9-215">You can access monitoring and diagnostics information by using the Azure portal.</span></span> <span data-ttu-id="121d9-216">ログ ファイルは、サイトから直接ダウンロードすることができます。</span><span class="sxs-lookup"><span data-stu-id="121d9-216">You can download log files directly from the site.</span></span> <span data-ttu-id="121d9-217">これらの情報は次の場所に保存されます。</span><span class="sxs-lookup"><span data-stu-id="121d9-217">They are saved in the following locations:</span></span>
  * <span data-ttu-id="121d9-218">トリガーによって実行する場合: Vfs/data/jobs/triggered/jobName</span><span class="sxs-lookup"><span data-stu-id="121d9-218">For triggered execution: Vfs/data/jobs/triggered/jobName</span></span>
  * <span data-ttu-id="121d9-219">連続実行の場合: Vfs/data/jobs/continuous/jobName</span><span class="sxs-lookup"><span data-stu-id="121d9-219">For continuous execution: Vfs/data/jobs/continuous/jobName</span></span>
* <span data-ttu-id="121d9-220">**構成**: Web ジョブの構成には、ポータル、REST API、PowerShell を使用できます。</span><span class="sxs-lookup"><span data-stu-id="121d9-220">**Configuration**: You can configure WebJobs by using the portal, the REST API, and PowerShell.</span></span> <span data-ttu-id="121d9-221">ジョブの構成情報は、ジョブ スクリプトと同じルート ディレクトリにある settings.job という名前の構成ファイルで指定できます。</span><span class="sxs-lookup"><span data-stu-id="121d9-221">You can use a configuration file named settings.job in the same root directory as the job script to provide configuration information for a job.</span></span> <span data-ttu-id="121d9-222">例:</span><span class="sxs-lookup"><span data-stu-id="121d9-222">For example:</span></span>
  * <span data-ttu-id="121d9-223">{ "stopping_wait_time": 60 }</span><span class="sxs-lookup"><span data-stu-id="121d9-223">{ "stopping_wait_time": 60 }</span></span>
  * <span data-ttu-id="121d9-224">{ "is_singleton": true }</span><span class="sxs-lookup"><span data-stu-id="121d9-224">{ "is_singleton": true }</span></span>

#### <a name="considerations"></a><span data-ttu-id="121d9-225">考慮事項</span><span class="sxs-lookup"><span data-stu-id="121d9-225">Considerations</span></span>

* <span data-ttu-id="121d9-226">既定では、Web アプリをスケーリングすると Web ジョブもスケーリングされます。</span><span class="sxs-lookup"><span data-stu-id="121d9-226">By default, WebJobs scale with the web app.</span></span> <span data-ttu-id="121d9-227">ただし、**is_singleton** 構成プロパティを **true** に設定すれば、単一インスタンスで実行されるようにジョブを構成することが可能です。</span><span class="sxs-lookup"><span data-stu-id="121d9-227">However, you can configure jobs to run on single instance by setting the **is_singleton** configuration property to **true**.</span></span> <span data-ttu-id="121d9-228">単一インスタンスの Web ジョブは、スケーリングが不要なタスク (インデックスの再構築、データ分析など、同時に複数のインスタンスで実行することが望ましくないタスク) に適しています。</span><span class="sxs-lookup"><span data-stu-id="121d9-228">Single instance WebJobs are useful for tasks that you do not want to scale or run as simultaneous multiple instances, such as reindexing, data analysis, and similar tasks.</span></span>
* <span data-ttu-id="121d9-229">長時間実行されるジョブやリソースの消費量が大きいジョブは、Web アプリのパフォーマンスへの影響を最小限に抑えるために、新しい App Service プランで空の Azure Web App インスタンスを作成し、そこでホストすることを検討してください。</span><span class="sxs-lookup"><span data-stu-id="121d9-229">To minimize the impact of jobs on the performance of the web app, consider creating an empty Azure Web App instance in a new App Service plan to host WebJobs that may be long running or resource intensive.</span></span>

### <a name="more-information"></a><span data-ttu-id="121d9-230">詳細情報</span><span class="sxs-lookup"><span data-stu-id="121d9-230">More information</span></span>
* <span data-ttu-id="121d9-231">[Azure WebJobs 推奨リソース](/azure/app-service-web/websites-webjobs-resources)に関するページをご覧ください。Web ジョブに関する有益なリソースやダウンロード、サンプルが多数紹介されています。</span><span class="sxs-lookup"><span data-stu-id="121d9-231">[Azure WebJobs recommended resources](/azure/app-service-web/websites-webjobs-resources) lists the many useful resources, downloads, and samples for WebJobs.</span></span>

### <a name="azure-virtual-machines"></a><span data-ttu-id="121d9-232">Azure Virtual Machines</span><span class="sxs-lookup"><span data-stu-id="121d9-232">Azure Virtual Machines</span></span>
<span data-ttu-id="121d9-233">バックグラウンド タスクの実装形態によっては、Azure Web Apps や Cloud Services にデプロイできなかったり、便利ではなかったりすることもあります。</span><span class="sxs-lookup"><span data-stu-id="121d9-233">Background tasks might be implemented in a way that prevents them from being deployed to Azure Web Apps or Cloud Services, or these options might not be convenient.</span></span> <span data-ttu-id="121d9-234">Windows のサービスや、サード パーティのユーティリティ、サード パーティの実行可能プログラムがその代表的な例です。</span><span class="sxs-lookup"><span data-stu-id="121d9-234">Typical examples are Windows services, and third-party utilities and executable programs.</span></span> <span data-ttu-id="121d9-235">また、アプリケーションのホスティング環境とは異なる実行環境向けに作成されたプログラムも同様です。</span><span class="sxs-lookup"><span data-stu-id="121d9-235">Another example might be programs written for an execution environment that is different than that hosting the application.</span></span> <span data-ttu-id="121d9-236">たとえば、Unix や Linux のプログラムを Windows アプリケーションまたは .NET アプリケーションから実行するケースなどが該当します。</span><span class="sxs-lookup"><span data-stu-id="121d9-236">For example, it might be a Unix or Linux program that you want to execute from a Windows or .NET application.</span></span> <span data-ttu-id="121d9-237">Azure Virtual Machines には、さまざまなオペレーティング システムが用意されているので、そこから目的のオペレーティング システムを選んで、仮想マシン上で必要なサービスまたは実行可能ファイルを運用することができます。</span><span class="sxs-lookup"><span data-stu-id="121d9-237">You can choose from a range of operating systems for an Azure virtual machine, and run your service or executable on that virtual machine.</span></span>

<span data-ttu-id="121d9-238">どのようなときに Virtual Machines を使うかについては、 [Azure App Services、Cloud Services、Virtual Machines の比較](/azure/app-service-web/choose-web-site-cloud-service-vm/)に関するページを参照してください。</span><span class="sxs-lookup"><span data-stu-id="121d9-238">To help you choose when to use Virtual Machines, see [Azure App Services, Cloud Services and Virtual Machines comparison](/azure/app-service-web/choose-web-site-cloud-service-vm/).</span></span> <span data-ttu-id="121d9-239">Virtual Machines の選択肢については、 [Azure の仮想マシンとクラウド サービスのサイズ](http://msdn.microsoft.com/library/azure/dn197896.aspx)に関するページを参照してください。</span><span class="sxs-lookup"><span data-stu-id="121d9-239">For information about the options for Virtual Machines, see [Virtual Machine and Cloud Service sizes for Azure](http://msdn.microsoft.com/library/azure/dn197896.aspx).</span></span> <span data-ttu-id="121d9-240">Virtual Machines で利用できるオペレーティング システムと既製イメージの詳細については、 [Azure Virtual Machines Marketplace](https://azure.microsoft.com/gallery/virtual-machines/)を参照してください。</span><span class="sxs-lookup"><span data-stu-id="121d9-240">For more information about the operating systems and prebuilt images that are available for Virtual Machines, see [Azure Virtual Machines Marketplace](https://azure.microsoft.com/gallery/virtual-machines/).</span></span>

<span data-ttu-id="121d9-241">バックグラウンド タスクを別の仮想マシンで開始するには、いくつかの方法があります。</span><span class="sxs-lookup"><span data-stu-id="121d9-241">To initiate the background task in a separate virtual machine, you have a range of options:</span></span>

* <span data-ttu-id="121d9-242">タスクの公開エンドポイントに要求を送り、アプリケーションからオンデマンドで直接タスクを実行する。</span><span class="sxs-lookup"><span data-stu-id="121d9-242">You can execute the task on demand directly from your application by sending a request to an endpoint that the task exposes.</span></span> <span data-ttu-id="121d9-243">これにより、タスクに必要なデータが渡され、</span><span class="sxs-lookup"><span data-stu-id="121d9-243">This passes in any data that the task requires.</span></span> <span data-ttu-id="121d9-244">タスクは、このエンドポイントによって呼び出されます。</span><span class="sxs-lookup"><span data-stu-id="121d9-244">This endpoint invokes the task.</span></span>
* <span data-ttu-id="121d9-245">選択したオペレーティング システムに用意されているスケジューラやタイマーを使い、スケジュールに基づいて動作するようにタスクを構成する。</span><span class="sxs-lookup"><span data-stu-id="121d9-245">You can configure the task to run on a schedule by using a scheduler or timer that is available in your chosen operating system.</span></span> <span data-ttu-id="121d9-246">たとえば Windows では、Windows タスク スケジューラを使ってスクリプトやタスクを実行できるほか、</span><span class="sxs-lookup"><span data-stu-id="121d9-246">For example, on Windows you can use Windows Task Scheduler to execute scripts and tasks.</span></span> <span data-ttu-id="121d9-247">仮想マシンに SQL Server がインストールされていれば、SQL Server エージェントを使ってスクリプトやタスクを実行することができます。</span><span class="sxs-lookup"><span data-stu-id="121d9-247">Or, if you have SQL Server installed on the virtual machine, you can use the SQL Server Agent to execute scripts and tasks.</span></span>
* <span data-ttu-id="121d9-248">Azure Scheduler を使用し、タスクが待機しているキューにメッセージを追加するか、タスクが公開している API に要求を送ることによってタスクを開始する。</span><span class="sxs-lookup"><span data-stu-id="121d9-248">You can use Azure Scheduler to initiate the task by adding a message to a queue that the task listens on, or by sending a request to an API that the task exposes.</span></span>

<span data-ttu-id="121d9-249">バックグラウンド タスクを開始する方法の詳細については、冒頭のセクション「 [トリガー](#triggers) 」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="121d9-249">See the earlier section [Triggers](#triggers) for more information about how you can initiate background tasks.</span></span>  

#### <a name="considerations"></a><span data-ttu-id="121d9-250">考慮事項</span><span class="sxs-lookup"><span data-stu-id="121d9-250">Considerations</span></span>
<span data-ttu-id="121d9-251">Azure 仮想マシンにバックグラウンド タスクをデプロイするかどうかは、次の点を考慮して判断してください。</span><span class="sxs-lookup"><span data-stu-id="121d9-251">Consider the following points when you are deciding whether to deploy background tasks in an Azure virtual machine:</span></span>

* <span data-ttu-id="121d9-252">独立した Azure 仮想マシンでバックグラウンド タスクをホスティングすれば、運用の幅が広がり、開始と実行、スケジューリング、リソース割り当てを細かく制御することができます。</span><span class="sxs-lookup"><span data-stu-id="121d9-252">Hosting background tasks in a separate Azure virtual machine provides flexibility and allows precise control over initiation, execution, scheduling, and resource allocation.</span></span> <span data-ttu-id="121d9-253">ただし、バックグラウンド タスクを実行するためだけに仮想マシンをデプロイしなければならない場合、ランタイム コストが大きくなります。</span><span class="sxs-lookup"><span data-stu-id="121d9-253">However, it will increase runtime cost if a virtual machine must be deployed just to run background tasks.</span></span>
* <span data-ttu-id="121d9-254">[Azure Resource Manager コマンドレット](https://msdn.microsoft.com/library/mt125356.aspx)を使って仮想マシンを管理したり、仮想マシンの基本的なステータスを監視したりすることはできますが、バックグラウンド タスクを監視する機構は Azure ポータルにはなく、また、障害の発生したタスクを自動的に再起動する機能もありません。</span><span class="sxs-lookup"><span data-stu-id="121d9-254">There is no facility to monitor the tasks in the Azure portal and no automated restart capability for failed tasks--although you can monitor the basic status of the virtual machine and manage it by using the  [Azure Resource Manager Cmdlets](https://msdn.microsoft.com/library/mt125356.aspx).</span></span> <span data-ttu-id="121d9-255">コンピューティング ノード内のプロセスやスレッドを制御する機構も存在しません。</span><span class="sxs-lookup"><span data-stu-id="121d9-255">However, there are no facilities to control processes and threads in compute nodes.</span></span> <span data-ttu-id="121d9-256">通常、仮想マシンを使うためには、タスクのインストルメンテーションや仮想マシン内のオペレーティング システムからデータを収集するメカニズムを別途導入する必要があります。</span><span class="sxs-lookup"><span data-stu-id="121d9-256">Typically, using a virtual machine will require additional effort to implement a mechanism that collects data from instrumentation in the task, and from the operating system in the virtual machine.</span></span> <span data-ttu-id="121d9-257">1 つの方法として、 [Azure 用の System Center 管理パック](https://www.microsoft.com/download/details.aspx?id=50013)を使うことが解決策として考えられます。</span><span class="sxs-lookup"><span data-stu-id="121d9-257">One solution that might be appropriate is to use the [System Center Management Pack for Azure](https://www.microsoft.com/download/details.aspx?id=50013).</span></span>
* <span data-ttu-id="121d9-258">HTTP エンドポイントを介して公開される監視プローブの作成を検討してください。</span><span class="sxs-lookup"><span data-stu-id="121d9-258">You might consider creating monitoring probes that are exposed through HTTP endpoints.</span></span> <span data-ttu-id="121d9-259">正常性チェックの実行、運用情報や統計情報の収集、エラー情報の照合を監視プローブのコードから実行して管理アプリケーションに返すようにします。</span><span class="sxs-lookup"><span data-stu-id="121d9-259">The code for these probes could perform health checks, collect operational information and statistics--or collate error information and return it to a management application.</span></span> <span data-ttu-id="121d9-260">詳細については、 [Health Endpoint Monitoring パターン](http://msdn.microsoft.com/library/dn589789.aspx)に関するページを参照してください。</span><span class="sxs-lookup"><span data-stu-id="121d9-260">For more information, see [Health Endpoint Monitoring Pattern](http://msdn.microsoft.com/library/dn589789.aspx).</span></span>

#### <a name="more-information"></a><span data-ttu-id="121d9-261">詳細情報</span><span class="sxs-lookup"><span data-stu-id="121d9-261">More information</span></span>
* <span data-ttu-id="121d9-262">[Virtual Machines](https://azure.microsoft.com/services/virtual-machines/) </span><span class="sxs-lookup"><span data-stu-id="121d9-262">[Virtual Machines](https://azure.microsoft.com/services/virtual-machines/) on Azure</span></span>
* [<span data-ttu-id="121d9-263">Azure Virtual Machines に関する FAQ</span><span class="sxs-lookup"><span data-stu-id="121d9-263">Azure Virtual Machines FAQ</span></span>](/azure/virtual-machines/virtual-machines-linux-classic-faq?toc=%2fazure%2fvirtual-machines%2flinux%2fclassic%2ftoc.json)

### <a name="azure-batch"></a><span data-ttu-id="121d9-264">Azure Batch</span><span class="sxs-lookup"><span data-stu-id="121d9-264">Azure Batch</span></span> 

<span data-ttu-id="121d9-265">数十、数百または数千の VM 間で高パフォーマンス コンピューティング (HPC) ワークロードを 大規模に並列実行する必要がある場合は、[Azure Batch](/azure/batch/) の使用を検討してください。</span><span class="sxs-lookup"><span data-stu-id="121d9-265">Consider [Azure Batch](/azure/batch/) if you need to run large, parallel high-performance computing (HPC) workloads across tens, hundreds, or thousands of VMs.</span></span>  

<span data-ttu-id="121d9-266">バッチ サービスにより VM がプロビジョニングされ、VM にタスクが割り当てられ、タスクが実行され、進行状況が監視されます。</span><span class="sxs-lookup"><span data-stu-id="121d9-266">The Batch service provisions the VMs, assign tasks to the VMs, runs the tasks, and monitors the progress.</span></span> <span data-ttu-id="121d9-267">バッチは、ワークロードに応じて VM を自動的にスケール アウトできます。</span><span class="sxs-lookup"><span data-stu-id="121d9-267">Batch can automatically scale out the VMs in response to the workload.</span></span> <span data-ttu-id="121d9-268">また、バッチは、ジョブのスケジューリングも提供します。</span><span class="sxs-lookup"><span data-stu-id="121d9-268">Batch also provides job scheduling.</span></span> <span data-ttu-id="121d9-269">Azure Batch は、Linux と Windows VM の両方をサポートします。</span><span class="sxs-lookup"><span data-stu-id="121d9-269">Azure Batch supports both Linux and Windows VMs.</span></span>

#### <a name="considerations"></a><span data-ttu-id="121d9-270">考慮事項</span><span class="sxs-lookup"><span data-stu-id="121d9-270">Considerations</span></span> 

<span data-ttu-id="121d9-271">Batch は、本質的に並列ワークロードの実行に適しています。</span><span class="sxs-lookup"><span data-stu-id="121d9-271">Batch works well with intrinsically parallel workloads.</span></span> <span data-ttu-id="121d9-272">最終的に低減されたステップで並列計算を実行するか、ノード間でメッセージの受け渡しを必要とする並列タスクの場合は、[Message Passing Interface (MPI) アプリケーション](/azure/batch/batch-mpi) を実行することもできます。</span><span class="sxs-lookup"><span data-stu-id="121d9-272">It can also perform parallel calculations with a reduce step at the end, or run [Message Passing Interface (MPI) applications](/azure/batch/batch-mpi) for parallel tasks that require message passing between nodes.</span></span> 

<span data-ttu-id="121d9-273">Azure Batch のジョブは、ノード (VM) のプールで実行されます。</span><span class="sxs-lookup"><span data-stu-id="121d9-273">An Azure Batch job runs on a pool of nodes (VMs).</span></span> <span data-ttu-id="121d9-274">1 つの方法は、必要なときのみプールを割り当て、ジョブの完了後に削除することです。</span><span class="sxs-lookup"><span data-stu-id="121d9-274">One approach is to allocate a pool only when needed and then delete it after the job completes.</span></span> <span data-ttu-id="121d9-275">この場合、ノードがアイドル状態にならず、使用率が最大限化されますが、ノードが割り当てられるまで、ジョブは待機する必要があります。</span><span class="sxs-lookup"><span data-stu-id="121d9-275">This maximizes utilization, because nodes are not idle, but the job must wait for nodes to be allocated.</span></span> <span data-ttu-id="121d9-276">または、前もってプールを作成することができます。</span><span class="sxs-lookup"><span data-stu-id="121d9-276">Alternatively, you can create a pool ahead of time.</span></span> <span data-ttu-id="121d9-277">この方法では、ジョブが開始されるまでの時間を短縮できますが、ノードがアイドル状態のままになる可能性があります。</span><span class="sxs-lookup"><span data-stu-id="121d9-277">That approach minimizes the time that it takes for a job to start, but can result in having nodes that sit idle.</span></span> <span data-ttu-id="121d9-278">詳細については、[プールとコンピューティング ノードの有効期間](/azure/batch/batch-api-basics#pool-and-compute-node-lifetime)を参照してください。</span><span class="sxs-lookup"><span data-stu-id="121d9-278">For more information, see [Pool and compute node lifetime](/azure/batch/batch-api-basics#pool-and-compute-node-lifetime).</span></span>

#### <a name="more-information"></a><span data-ttu-id="121d9-279">詳細情報</span><span class="sxs-lookup"><span data-stu-id="121d9-279">More information</span></span> 

* [<span data-ttu-id="121d9-280">Batch で並列ワークロードを本質的に実行する</span><span class="sxs-lookup"><span data-stu-id="121d9-280">Run intrinsically parallel workloads with Batch</span></span>](/azure/batch/batch-technical-overview) 
* [<span data-ttu-id="121d9-281">Batch を使って大規模な並列コンピューティング ソリューションを開発する</span><span class="sxs-lookup"><span data-stu-id="121d9-281">Develop large-scale parallel compute solutions with Batch</span></span>](/azure/batch/batch-api-basics) 
* [<span data-ttu-id="121d9-282">大規模コンピューティング ワークロード用の Batch および HPC ソリューション</span><span class="sxs-lookup"><span data-stu-id="121d9-282">Batch and HPC solutions for large-scale computing workloads</span></span>](/azure/batch/batch-hpc-solutions)

### <a name="azure-container-service"></a><span data-ttu-id="121d9-283">Azure Container Service</span><span class="sxs-lookup"><span data-stu-id="121d9-283">Azure Container Service</span></span> 

<span data-ttu-id="121d9-284">Azure Container Service を使用すると、コンテナー化されたアプリケーションを実行するように事前構成されている Azure の VM クラスターを、作成、構成、および管理できます。</span><span class="sxs-lookup"><span data-stu-id="121d9-284">Azure Container Service lets you configure and manage a cluster of VMs in Azure to run containerized applications.</span></span> <span data-ttu-id="121d9-285">Azure Container Service では、オーケストレーション用に Docker Swarm、DC/OS、または Kubernetes を選択できます。</span><span class="sxs-lookup"><span data-stu-id="121d9-285">It provides a choice of Docker Swarm, DC/OS, or Kubernetes for orchestration.</span></span> 

<span data-ttu-id="121d9-286">コンテナーは、バック グラウンド ジョブを実行するために役立ちます。</span><span class="sxs-lookup"><span data-stu-id="121d9-286">Containers can be useful for running background jobs.</span></span> <span data-ttu-id="121d9-287">次の利点があります。</span><span class="sxs-lookup"><span data-stu-id="121d9-287">Some of the benefits include:</span></span> 

- <span data-ttu-id="121d9-288">コンテナーは、高密度のホストをサポートします。</span><span class="sxs-lookup"><span data-stu-id="121d9-288">Containers support high-density hosting.</span></span> <span data-ttu-id="121d9-289">各 VM に複数のコンテナーを配置して、コンテナー内のバック グラウンド タスクを分離できます。</span><span class="sxs-lookup"><span data-stu-id="121d9-289">You can isolate a background task in a container, while placing multiple containers in each VM.</span></span>
- <span data-ttu-id="121d9-290">コンテナー オーケストレーターは、内部負荷分散、内部ネットワークと他の構成タスクの構成を処理します。</span><span class="sxs-lookup"><span data-stu-id="121d9-290">The container orchestrator handles internal load balancing, configuring the internal network, and other configuration tasks.</span></span>
- <span data-ttu-id="121d9-291">コンテナーは、必要に応じて起動/停止できます。</span><span class="sxs-lookup"><span data-stu-id="121d9-291">Containers can be started and stopped as needed.</span></span> 
- <span data-ttu-id="121d9-292">Azure Container Registry を使用して、Azure の境界内にコンテナーを登録することができます。</span><span class="sxs-lookup"><span data-stu-id="121d9-292">Azure Container Registry allows you to register your containers inside Azure boundaries.</span></span> <span data-ttu-id="121d9-293">これは、セキュリティ、プライバシー、および近接の面でメリットがあります。</span><span class="sxs-lookup"><span data-stu-id="121d9-293">This comes with security, privacy, and proximity benefits.</span></span> 

#### <a name="considerations"></a><span data-ttu-id="121d9-294">考慮事項</span><span class="sxs-lookup"><span data-stu-id="121d9-294">Considerations</span></span>

- <span data-ttu-id="121d9-295">コンテナー オーケストレーターの使用方法を理解する必要がある。</span><span class="sxs-lookup"><span data-stu-id="121d9-295">Requires an understanding of how to use a container orchestrator.</span></span> <span data-ttu-id="121d9-296">DevOps チームのスキルによって、これが問題になる、またはならない場合があります。</span><span class="sxs-lookup"><span data-stu-id="121d9-296">Depending on the skillset of your DevOps team, this may or may not be an issue.</span></span>  
- <span data-ttu-id="121d9-297">コンテナー サービスは、IaaS 環境で実行されます。</span><span class="sxs-lookup"><span data-stu-id="121d9-297">Container Service runs in an IaaS environment.</span></span> <span data-ttu-id="121d9-298">専用 VNet 内の VM のクラスターをプロビジョニングします。</span><span class="sxs-lookup"><span data-stu-id="121d9-298">It provisions a cluster of VMs inside a dedicated VNet.</span></span> 

#### <a name="more-information"></a><span data-ttu-id="121d9-299">詳細情報</span><span class="sxs-lookup"><span data-stu-id="121d9-299">More information</span></span> 

* [<span data-ttu-id="121d9-300">Azure Container Service を使用した Docker コンテナー ホスティング ソリューションの概要</span><span class="sxs-lookup"><span data-stu-id="121d9-300">Introduction to Docker container hosting solutions with Azure Container Service</span></span>](/azure/container-service/container-service-intro) 
* [<span data-ttu-id="121d9-301">プライベート Docker コンテナー レジストリの概要</span><span class="sxs-lookup"><span data-stu-id="121d9-301">Introduction to private Docker container registries</span></span>](/azure/container-registry/container-registry-intro) 

### <a name="azure-cloud-services"></a><span data-ttu-id="121d9-302">Azure クラウド サービス</span><span class="sxs-lookup"><span data-stu-id="121d9-302">Azure Cloud Services</span></span> 
<span data-ttu-id="121d9-303">バックグラウンド タスクは、Web ロール内で実行することも、独立した worker ロールで実行することもできます。</span><span class="sxs-lookup"><span data-stu-id="121d9-303">You can execute background tasks within a web role or in a separate worker role.</span></span> <span data-ttu-id="121d9-304">worker ロールを用いるかどうかは、スケーラビリティと弾力性の要件、タスクの有効期間、リリースの頻度、セキュリティ、フォールト トレランス、リソースの奪い合い、複雑性、論理アーキテクチャなどを考慮して判断します。</span><span class="sxs-lookup"><span data-stu-id="121d9-304">When you are deciding whether to use a worker role, consider scalability and elasticity requirements, task lifetime, release cadence, security, fault tolerance, contention, complexity, and the logical architecture.</span></span> <span data-ttu-id="121d9-305">詳細については、 [Compute Resource Consolidation パターン](http://msdn.microsoft.com/library/dn589778.aspx)に関するページを参照してください。</span><span class="sxs-lookup"><span data-stu-id="121d9-305">For more information, see [Compute Resource Consolidation Pattern](http://msdn.microsoft.com/library/dn589778.aspx).</span></span>

<span data-ttu-id="121d9-306">Cloud Services ロールには、さまざまな方法でバックグラウンド タスクを実装することができます。</span><span class="sxs-lookup"><span data-stu-id="121d9-306">There are several ways to implement background tasks within a Cloud Services role:</span></span>

* <span data-ttu-id="121d9-307">Cloud Services ロールに **RoleEntryPoint** クラスの実装を作成し、そのメソッドを使ってバックグラウンド タスクを実行する。</span><span class="sxs-lookup"><span data-stu-id="121d9-307">Create an implementation of the **RoleEntryPoint** class in the role and use its methods to execute background tasks.</span></span> <span data-ttu-id="121d9-308">この場合タスクは WaIISHost.exe のコンテキストで動作し、</span><span class="sxs-lookup"><span data-stu-id="121d9-308">The tasks run in the context of WaIISHost.exe.</span></span> <span data-ttu-id="121d9-309">**CloudConfigurationManager** クラスの **GetSetting** メソッドを使って構成設定を読み込むことができます。</span><span class="sxs-lookup"><span data-stu-id="121d9-309">They can use the **GetSetting** method of the **CloudConfigurationManager** class to load configuration settings.</span></span> <span data-ttu-id="121d9-310">詳細については、「[ライフサイクル](#lifecycle)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="121d9-310">For more information, see [Lifecycle](#lifecycle).</span></span>
* <span data-ttu-id="121d9-311">アプリケーションの起動時にスタートアップ タスクを使ってバックグラウンド タスクを実行する。</span><span class="sxs-lookup"><span data-stu-id="121d9-311">Use startup tasks to execute background tasks when the application starts.</span></span> <span data-ttu-id="121d9-312">バックグラウンドでタスクを強制的に実行し続けるには、**taskType** プロパティを **background** に設定します (この設定をしなかった場合、アプリケーションの起動プロセスが中断状態でタスクの完了を待機します)。</span><span class="sxs-lookup"><span data-stu-id="121d9-312">To force the tasks to continue to run in the background, set the **taskType** property to **background** (if you do not do this, the application startup process will halt and wait for the task to finish).</span></span> <span data-ttu-id="121d9-313">詳細については、 [Azure におけるスタートアップ タスクの実行](/azure/cloud-services/cloud-services-startup-tasks)に関するページを参照してください。</span><span class="sxs-lookup"><span data-stu-id="121d9-313">For more information, see [Run startup tasks in Azure](/azure/cloud-services/cloud-services-startup-tasks).</span></span>
* <span data-ttu-id="121d9-314">WebJobs SDK を使い、スタートアップ タスクとして開始される Web ジョブなどのバックグラウンド タスクを実装する。</span><span class="sxs-lookup"><span data-stu-id="121d9-314">Use the WebJobs SDK to implement background tasks such as WebJobs that are initiated as a startup task.</span></span> <span data-ttu-id="121d9-315">詳細については、「[Azure App Service での .NET WebJob の作成](/azure/app-service-web/websites-dotnet-webjobs-sdk-get-started)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="121d9-315">For more information, see [Create a .NET WebJob in Azure App Service](/azure/app-service-web/websites-dotnet-webjobs-sdk-get-started).</span></span>
* <span data-ttu-id="121d9-316">バックグラウンド タスクを実行する Windows サービスを、スタートアップ タスクを使ってインストールする。</span><span class="sxs-lookup"><span data-stu-id="121d9-316">Use a startup task to install a Windows service that executes one or more background tasks.</span></span> <span data-ttu-id="121d9-317">サービスをバックグラウンドで実行するには、**taskType** プロパティを **background** に設定する必要があります。</span><span class="sxs-lookup"><span data-stu-id="121d9-317">You must set the **taskType** property to **background** so that the service executes in the background.</span></span> <span data-ttu-id="121d9-318">詳細については、 [Azure におけるスタートアップ タスクの実行](/azure/cloud-services/cloud-services-startup-tasks)に関するページを参照してください。</span><span class="sxs-lookup"><span data-stu-id="121d9-318">For more information, see [Run startup tasks in Azure](/azure/cloud-services/cloud-services-startup-tasks).</span></span>

<span data-ttu-id="121d9-319">バックグラウンド タスクを Web ロールで実行する利点はなんといっても、別途ロールを追加デプロイする必要がないため、ホスティングにかかるコストが低いことです。</span><span class="sxs-lookup"><span data-stu-id="121d9-319">The main advantage of running background tasks in the web role is the saving in hosting costs because there is no requirement to deploy additional roles.</span></span>

<span data-ttu-id="121d9-320">以下、バックグラウンド タスクを worker ロールで実行する利点をいくつか挙げます。</span><span class="sxs-lookup"><span data-stu-id="121d9-320">Running background tasks in a worker role has several advantages:</span></span>

* <span data-ttu-id="121d9-321">ロールの種類ごとに切り離してスケーリングを管理できる。</span><span class="sxs-lookup"><span data-stu-id="121d9-321">It allows you to manage scaling separately for each type of role.</span></span> <span data-ttu-id="121d9-322">たとえば現状の負荷に対応するために Web ロールのインスタンス数を増やす必要がある一方で、バックグラウンド タスクを実行する worker ロールのインスタンス数はもっと少なくできるという状況が考えられます。</span><span class="sxs-lookup"><span data-stu-id="121d9-322">For example, you might need more instances of a web role to support the current load, but fewer instances of the worker role that executes background tasks.</span></span> <span data-ttu-id="121d9-323">バックグラウンド タスクのコンピューティング インスタンスを UI のロールとは独立にスケーリングすることで、十分なパフォーマンスを維持しながら、ホスティングのコストを削減することができます。</span><span class="sxs-lookup"><span data-stu-id="121d9-323">By scaling background task compute instances separately from the UI roles, you can reduce hosting costs, while maintaining acceptable performance.</span></span>
* <span data-ttu-id="121d9-324">バックグラウンド タスクの処理オーバーヘッドを Web ロールから取り除くことができる。</span><span class="sxs-lookup"><span data-stu-id="121d9-324">It offloads the processing overhead for background tasks from the web role.</span></span> <span data-ttu-id="121d9-325">UI として機能する Web ロールの応答性を保つことができるため、ユーザーからの特定の量の要求を処理するために必要なインスタンス数が相対的に少なくて済みます。</span><span class="sxs-lookup"><span data-stu-id="121d9-325">The web role that provides the UI can remain responsive, and it may mean fewer instances are required to support a given volume of requests from users.</span></span>
* <span data-ttu-id="121d9-326">処理内容の独立性を高めることができる。</span><span class="sxs-lookup"><span data-stu-id="121d9-326">It allows you to implement separation of concerns.</span></span> <span data-ttu-id="121d9-327">ロールの種類ごとに明確な特徴を持った関連するタスクを集めて実装することができます。</span><span class="sxs-lookup"><span data-stu-id="121d9-327">Each role type can implement a specific set of clearly defined and related tasks.</span></span> <span data-ttu-id="121d9-328">他のロールのコードや機能への依存度が下がるため、コードの設計と管理がしやすくなります。</span><span class="sxs-lookup"><span data-stu-id="121d9-328">This makes designing and maintaining the code easier because there is less interdependence of code and functionality between each role.</span></span>
* <span data-ttu-id="121d9-329">機密を要するプロセスやデータが分離しやすくなる。</span><span class="sxs-lookup"><span data-stu-id="121d9-329">It can help to isolate sensitive processes and data.</span></span> <span data-ttu-id="121d9-330">たとえば、UI の機能を実装する Web ロールが、worker ロールの管理下にあるデータにアクセスできる必要はありません。</span><span class="sxs-lookup"><span data-stu-id="121d9-330">For example, web roles that implement the UI do not need to have access to data that is managed and controlled by a worker role.</span></span> <span data-ttu-id="121d9-331">これは、特に [Gatekeeper パターン](http://msdn.microsoft.com/library/dn589793.aspx)のようなパターンを使用してセキュリティを強化する場合に便利です。</span><span class="sxs-lookup"><span data-stu-id="121d9-331">This can be useful in strengthening security, especially when you use a pattern such as the [Gatekeeper Pattern](http://msdn.microsoft.com/library/dn589793.aspx).</span></span>  

#### <a name="considerations"></a><span data-ttu-id="121d9-332">考慮事項</span><span class="sxs-lookup"><span data-stu-id="121d9-332">Considerations</span></span>
<span data-ttu-id="121d9-333">Cloud Services の Web ロールと worker ロールを使っているときに、バックグラウンド タスクをどこにどのようにデプロイするかは、次の点を考慮して判断してください。</span><span class="sxs-lookup"><span data-stu-id="121d9-333">Consider the following points when choosing how and where to deploy background tasks when using Cloud Services web and worker roles:</span></span>

* <span data-ttu-id="121d9-334">バックグラウンド タスクを既存の Web ロールでホスティングすると、そのタスク専用に独立した worker ロールを運用するコストを節約することができます。</span><span class="sxs-lookup"><span data-stu-id="121d9-334">Hosting background tasks in an existing web role can save the cost of running a separate worker role just for these tasks.</span></span> <span data-ttu-id="121d9-335">一方、処理や他のリソースを奪い合う状況が生じると、アプリケーションのパフォーマンスと稼働率に影響する可能性が高くなります。</span><span class="sxs-lookup"><span data-stu-id="121d9-335">However, it is likely to affect the performance and availability of the application if there is contention for processing and other resources.</span></span> <span data-ttu-id="121d9-336">独立した worker ロールを使うと、バックグラウンド タスクの実行時間が長時間に及んだり、リソースが大量に消費されたりする影響から Web ロールを守ることができます。</span><span class="sxs-lookup"><span data-stu-id="121d9-336">Using a separate worker role protects the web role from the impact of long-running or resource-intensive background tasks.</span></span>
* <span data-ttu-id="121d9-337">**RoleEntryPoint** クラスを使ってバックグラウンド タスクをホストすると、そのクラスを簡単に別のロールに移すことができます。</span><span class="sxs-lookup"><span data-stu-id="121d9-337">If you host background tasks by using the **RoleEntryPoint** class, you can easily move this to another role.</span></span> <span data-ttu-id="121d9-338">たとえば、このクラスを最初 Web ロールに作成したものの、後日、worker ロールでタスクを実行することにした場合、 **RoleEntryPoint** クラスの実装を worker ロールに移すことができます。</span><span class="sxs-lookup"><span data-stu-id="121d9-338">For example, if you create the class in a web role and later decide that you need to run the tasks in a worker role, you can move the **RoleEntryPoint** class implementation into the worker role.</span></span>
* <span data-ttu-id="121d9-339">スタートアップ タスクはプログラムまたはスクリプトを実行するように設計されています。</span><span class="sxs-lookup"><span data-stu-id="121d9-339">Startup tasks are designed to execute a program or a script.</span></span> <span data-ttu-id="121d9-340">バックグラウンド ジョブを実行可能プログラムとしてデプロイするのは、特に依存アセンブリのデプロイを伴う場合、スクリプトとしてデプロイするよりも難易度が高くなります。</span><span class="sxs-lookup"><span data-stu-id="121d9-340">Deploying a background job as an executable program might be more difficult, especially if it also requires deployment of dependent assemblies.</span></span> <span data-ttu-id="121d9-341">スタートアップ タスクを使うときは、スクリプトをデプロイして使用した方が簡単にバックグラウンド ジョブを定義できます。</span><span class="sxs-lookup"><span data-stu-id="121d9-341">It might be easier to deploy and use a script to define a background job when you use startup tasks.</span></span>
* <span data-ttu-id="121d9-342">バックグラウンド タスクの障害を引き起こす例外の影響は、バックグラウンド タスクのホスティング形態によって異なります。</span><span class="sxs-lookup"><span data-stu-id="121d9-342">Exceptions that cause a background task to fail have a different impact, depending on the way that they are hosted:</span></span>
  * <span data-ttu-id="121d9-343">**RoleEntryPoint** クラスを使った方法を用いている場合、タスクの障害が発生すると、タスクを自動的に再起動するためにロールが再起動されます。</span><span class="sxs-lookup"><span data-stu-id="121d9-343">If you use the **RoleEntryPoint** class approach, a failed task will cause the role to restart so that the task automatically restarts.</span></span> <span data-ttu-id="121d9-344">このことでアプリケーションの稼働率に影響が生じる可能性があります。</span><span class="sxs-lookup"><span data-stu-id="121d9-344">This can affect availability of the application.</span></span> <span data-ttu-id="121d9-345">これを防ぐためには、 **RoleEntryPoint** クラスとすべてのバックグラウンド タスクに堅牢な例外処理を設ける必要があります。</span><span class="sxs-lookup"><span data-stu-id="121d9-345">To prevent this, ensure that you include robust exception handling within the **RoleEntryPoint** class and all the background tasks.</span></span> <span data-ttu-id="121d9-346">障害の発生したタスクを (再起動することが妥当であれば) 再起動するようにコーディングし、そのコード内の正規の手順で障害から復旧できない場合にのみ、例外をスローしてロールを再起動するようにしてください。</span><span class="sxs-lookup"><span data-stu-id="121d9-346">Use code to restart tasks that fail where this is appropriate, and throw the exception to restart the role only if you cannot gracefully recover from the failure within your code.</span></span>
  * <span data-ttu-id="121d9-347">スタートアップ タスクを使った場合、タスクの実行管理と障害が発生しているかどうかのチェックを自分で行う必要があります。</span><span class="sxs-lookup"><span data-stu-id="121d9-347">If you use startup tasks, you are responsible for managing the task execution and checking if it fails.</span></span>
* <span data-ttu-id="121d9-348">スタートアップ タスクの管理と監視は、 **RoleEntryPoint** クラスを使ったアプローチと比べて難しくなります。</span><span class="sxs-lookup"><span data-stu-id="121d9-348">Managing and monitoring startup tasks is more difficult than using the **RoleEntryPoint** class approach.</span></span> <span data-ttu-id="121d9-349">ただし、Azure WebJobs SDK に用意されているダッシュボードを使うと、スタートアップ タスクを用いて開始された Web ジョブを簡単に管理することができます。</span><span class="sxs-lookup"><span data-stu-id="121d9-349">However, the Azure WebJobs SDK includes a dashboard to make it easier to manage WebJobs that you initiate through startup tasks.</span></span>

#### <a name="lifecycle"></a><span data-ttu-id="121d9-350">ライフサイクル</span><span class="sxs-lookup"><span data-stu-id="121d9-350">Lifecycle</span></span> 
 <span data-ttu-id="121d9-351">Web ロールと worker ロールを使用する Cloud Services アプリケーションで、 **RoleEntryPoint** クラスを使ってバックグラウンド ジョブを実装する場合、このクラスのライフサイクルを理解しておくことが正しく使用するうえで大切です。</span><span class="sxs-lookup"><span data-stu-id="121d9-351">If you decide to implement background jobs for Cloud Services applications that use web and worker roles by using the **RoleEntryPoint** class, it is important to understand the lifecycle of this class in order to use it correctly.</span></span>

<span data-ttu-id="121d9-352">Web ロールと worker ロールが開始、実行、停止される過程には、明確に区別されたいくつかの段階が存在します。</span><span class="sxs-lookup"><span data-stu-id="121d9-352">Web and worker roles go through a set of distinct phases as they start, run, and stop.</span></span> <span data-ttu-id="121d9-353">これらの各段階に到達したタイミングを通知する一連のイベントが、 **RoleEntryPoint** クラスに定義されています。</span><span class="sxs-lookup"><span data-stu-id="121d9-353">The **RoleEntryPoint** class exposes a series of events that indicate when these stages are occurring.</span></span> <span data-ttu-id="121d9-354">それらのイベントを利用して、カスタム バックグラウンド タスクの初期化、実行、停止を行うことができます。</span><span class="sxs-lookup"><span data-stu-id="121d9-354">You use these to initialize, run, and stop your custom background tasks.</span></span> <span data-ttu-id="121d9-355">その全体のサイクルは次のとおりです。</span><span class="sxs-lookup"><span data-stu-id="121d9-355">The complete cycle is:</span></span>

* <span data-ttu-id="121d9-356">Azure がロールのアセンブリを読み込み、 **RoleEntryPoint**から派生したクラスを探します。</span><span class="sxs-lookup"><span data-stu-id="121d9-356">Azure loads the role assembly and searches it for a class that derives from **RoleEntryPoint**.</span></span>
* <span data-ttu-id="121d9-357">このクラスが見つかった場合、 **RoleEntryPoint.OnStart()**を呼び出します。</span><span class="sxs-lookup"><span data-stu-id="121d9-357">If it finds this class, it calls **RoleEntryPoint.OnStart()**.</span></span> <span data-ttu-id="121d9-358">このメソッドをオーバーライドしてバックグラウンド タスクを初期化できます。</span><span class="sxs-lookup"><span data-stu-id="121d9-358">You override this method to initialize your background tasks.</span></span>
* <span data-ttu-id="121d9-359">**OnStart** メソッドの完了後、Azure は、アプリケーションの Global ファイル (ASP.NET を実行している Web ロールの Global.asax など) が存在する場合、そのファイル内の **Application_Start()** を呼び出します。</span><span class="sxs-lookup"><span data-stu-id="121d9-359">After the **OnStart** method has completed, Azure calls **Application_Start()** in the application’s Global file if this is present (for example, Global.asax in a web role running ASP.NET).</span></span>
* <span data-ttu-id="121d9-360">Azure が、**OnStart()** と並列に実行される新しいフォアグラウンド スレッドで **RoleEntryPoint.Run()** を呼び出します。</span><span class="sxs-lookup"><span data-stu-id="121d9-360">Azure calls **RoleEntryPoint.Run()** on a new foreground thread that executes in parallel with **OnStart()**.</span></span> <span data-ttu-id="121d9-361">このメソッドをオーバーライドしてバックグラウンド タスクを開始できます。</span><span class="sxs-lookup"><span data-stu-id="121d9-361">You override this method to start your background tasks.</span></span>
* <span data-ttu-id="121d9-362">Run メソッドが終了すると、Azure はまずアプリケーションの Global ファイル (存在する場合) 内の **Application_End()** を呼び出し、その後、**RoleEntryPoint.OnStop()** を呼び出します。</span><span class="sxs-lookup"><span data-stu-id="121d9-362">When the Run method ends, Azure first calls **Application_End()** in the application’s Global file if this is present, and then calls **RoleEntryPoint.OnStop()**.</span></span> <span data-ttu-id="121d9-363">バックグラウンド タスクの停止、リソースのクリーンアップ、オブジェクトの破棄、タスクで使われていた接続の終了処理は、この **OnStop** メソッドをオーバーライドして行います。</span><span class="sxs-lookup"><span data-stu-id="121d9-363">You override the **OnStop** method to stop your background tasks, clean up resources, dispose of objects, and close connections that the tasks may have used.</span></span>
* <span data-ttu-id="121d9-364">Azure worker ロールのホスト プロセスが停止します。</span><span class="sxs-lookup"><span data-stu-id="121d9-364">The Azure worker role host process is stopped.</span></span> <span data-ttu-id="121d9-365">この時点で、ロールがリサイクルされて再起動します。</span><span class="sxs-lookup"><span data-stu-id="121d9-365">At this point, the role will be recycled and will restart.</span></span>

<span data-ttu-id="121d9-366">**RoleEntryPoint** クラスのメソッドの詳細と使用例については、 [Compute Resource Consolidation パターン](http://msdn.microsoft.com/library/dn589778.aspx)に関するページを参照してください。</span><span class="sxs-lookup"><span data-stu-id="121d9-366">For more details and an example of using the methods of the **RoleEntryPoint** class, see [Compute Resource Consolidation Pattern](http://msdn.microsoft.com/library/dn589778.aspx).</span></span>

#### <a name="implementation-considerations"></a><span data-ttu-id="121d9-367">実装時の注意事項</span><span class="sxs-lookup"><span data-stu-id="121d9-367">Implementation considerations</span></span>

<span data-ttu-id="121d9-368">Web またはワーカー ロールでバックグラウンド タスクを実装する場合は、次の点を考慮してください。</span><span class="sxs-lookup"><span data-stu-id="121d9-368">Consider the following points if you are implementing background tasks in a web or worker role:</span></span>

* <span data-ttu-id="121d9-369">**RoleEntryPoint** クラスの **Run** メソッドの既定の実装には、ロールを無期限に起動状態にする **Thread.Sleep(Timeout.Infinite)** の呼び出しが含まれています。</span><span class="sxs-lookup"><span data-stu-id="121d9-369">The default **Run** method implementation in the **RoleEntryPoint** class contains a call to **Thread.Sleep(Timeout.Infinite)** that keeps the role alive indefinitely.</span></span> <span data-ttu-id="121d9-370">この **Run** メソッドをオーバーライドする場合 (通常、バックグラウンド タスクを実行するためにはオーバーライドが必要)、ロール インスタンスをリサイクルするとき以外は、このメソッドを終了してはいけません。</span><span class="sxs-lookup"><span data-stu-id="121d9-370">If you override the **Run** method (which is typically necessary to execute background tasks), you must not allow your code to exit from the method unless you want to recycle the role instance.</span></span>
* <span data-ttu-id="121d9-371">通常、 **Run** メソッドの実装は、個々のバックグラウンド タスクを開始するコードと、すべてのバックグラウンド タスクの状態を定期的にチェックするループ構文を含んでいます。</span><span class="sxs-lookup"><span data-stu-id="121d9-371">A typical implementation of the **Run** method includes code to start each of the background tasks and a loop construct that periodically checks the state of all the background tasks.</span></span> <span data-ttu-id="121d9-372">障害の発生したタスクを再起動したり、ジョブが完了したことを示すキャンセル トークンを監視したりすることが可能です。</span><span class="sxs-lookup"><span data-stu-id="121d9-372">It can restart any that fail or monitor for cancellation tokens that indicate that jobs have completed.</span></span>
* <span data-ttu-id="121d9-373">ハンドルされない例外が特定のバックグラウンド タスクでスローされた場合、ロール内の他のバックグラウンド タスクについては実行を継続し、例外のスローされたタスクだけをリサイクルします。</span><span class="sxs-lookup"><span data-stu-id="121d9-373">If a background task throws an unhandled exception, that task should be recycled while allowing any other background tasks in the role to continue running.</span></span> <span data-ttu-id="121d9-374">ただし、その例外がタスクの外部にあるオブジェクト (共有記憶域など) の破損に起因する場合は、**RoleEntryPoint** クラスに実装するコードの中でその例外を処理し、すべてのタスクを取り消せば、**Run** メソッドを終了できます。</span><span class="sxs-lookup"><span data-stu-id="121d9-374">However, if the exception is caused by corruption of objects outside the task, such as shared storage, the exception should be handled by your **RoleEntryPoint** class, all tasks should be cancelled, and the **Run** method should be allowed to end.</span></span> <span data-ttu-id="121d9-375">その後 Azure によってロールが再起動されます。</span><span class="sxs-lookup"><span data-stu-id="121d9-375">Azure will then restart the role.</span></span>
* <span data-ttu-id="121d9-376">バックグラウンド タスクを一時停止または強制終了し、リソースをクリーンアップするには、**OnStop** メソッドを使います。</span><span class="sxs-lookup"><span data-stu-id="121d9-376">Use the **OnStop** method to pause or kill background tasks and clean up resources.</span></span> <span data-ttu-id="121d9-377">必然的に、長時間実行されるタスクや複数のステップから成るタスクを停止しなければならない場合があります。</span><span class="sxs-lookup"><span data-stu-id="121d9-377">This might involve stopping long-running or multistep tasks.</span></span> <span data-ttu-id="121d9-378">データに不整合を来さない方法でいかにそれを実行するかは重要な考慮事項です。</span><span class="sxs-lookup"><span data-stu-id="121d9-378">It is vital to consider how this can be done to avoid data inconsistencies.</span></span> <span data-ttu-id="121d9-379">ユーザーによって引き起こされたシャットダウンを除くなんらかの理由でロール インスタンスが停止した場合、**OnStop** メソッドで実行されているコードは 5 分以内に完了しなければなりません。5 分が経過すると強制終了されます。</span><span class="sxs-lookup"><span data-stu-id="121d9-379">If a role instance stops for any reason other than a user-initiated shutdown, the code running in the **OnStop** method must be completed within five minutes before it is forcibly terminated.</span></span> <span data-ttu-id="121d9-380">その時間内に完了するようにコードを作成するか、最後まで実行されなくても支障がないようにコードを設計してください。</span><span class="sxs-lookup"><span data-stu-id="121d9-380">Ensure that your code can be completed in that time or can tolerate not running to completion.</span></span>  
* <span data-ttu-id="121d9-381">Azure Load Balancer は、**RoleEntryPoint.OnStart** メソッドから **true** が返されると、ロール インスタンスにトラフィックを誘導し始めます。</span><span class="sxs-lookup"><span data-stu-id="121d9-381">The Azure load balancer starts directing traffic to the role instance when the **RoleEntryPoint.OnStart** method returns the value **true**.</span></span> <span data-ttu-id="121d9-382">そのため、正常に初期化されなかったロール インスタンスにトラフィックが振り分けられることのないよう、必要な初期化コードはすべて **OnStart** メソッドに記述することをお勧めします。</span><span class="sxs-lookup"><span data-stu-id="121d9-382">Therefore, consider putting all your initialization code in the **OnStart** method so that role instances that do not successfully initialize will not receive any traffic.</span></span>
* <span data-ttu-id="121d9-383">**RoleEntryPoint** クラスのメソッドに加えてスタートアップ タスクを使うことができます。</span><span class="sxs-lookup"><span data-stu-id="121d9-383">You can use startup tasks in addition to the methods of the **RoleEntryPoint** class.</span></span> <span data-ttu-id="121d9-384">Azure ロード バランサーの設定を初期化して変更する必要がある場合は、スタートアップ タスクを使う必要があります。スタートアップ タスクは、ロールが要求を受け取る前に実行されます。</span><span class="sxs-lookup"><span data-stu-id="121d9-384">You should use startup tasks to initialize any settings that you need to change in the Azure load balancer because these tasks will execute before the role receives any requests.</span></span> <span data-ttu-id="121d9-385">詳細については、 [Azure におけるスタートアップ タスクの実行](/azure/cloud-services/cloud-services-startup-tasks/)に関するページを参照してください。</span><span class="sxs-lookup"><span data-stu-id="121d9-385">For more information, see [Run startup tasks in Azure](/azure/cloud-services/cloud-services-startup-tasks/).</span></span>
* <span data-ttu-id="121d9-386">スタートアップ タスクにエラーが存在すると、ロールの再起動が強制的に繰り返されることがあります。</span><span class="sxs-lookup"><span data-stu-id="121d9-386">If there is an error in a startup task, it might force the role to continually restart.</span></span> <span data-ttu-id="121d9-387">この場合、それまでのステージング環境への仮想 IP (VIP) スワップを実行できなくなる可能性があります。</span><span class="sxs-lookup"><span data-stu-id="121d9-387">This can prevent you from performing a virtual IP (VIP) address swap back to a previously staged version because the swap requires exclusive access to the role.</span></span> <span data-ttu-id="121d9-388">VIP スワップを実行するためには、ロールへの排他アクセスが必要ですが、ロールの再起動中は排他アクセスを取得できないためです。</span><span class="sxs-lookup"><span data-stu-id="121d9-388">This cannot be obtained while the role is restarting.</span></span> <span data-ttu-id="121d9-389">それを解決するには、次のようにします。</span><span class="sxs-lookup"><span data-stu-id="121d9-389">To resolve this:</span></span>
  
  * <span data-ttu-id="121d9-390">ロールの **OnStart** メソッドと **Run** メソッドの先頭に次のコードを追加します。</span><span class="sxs-lookup"><span data-stu-id="121d9-390">Add the following code to the beginning of the **OnStart** and **Run** methods in your role:</span></span>
    
    ```C#
    var freeze = CloudConfigurationManager.GetSetting("Freeze");
    if (freeze != null)
    {
     if (Boolean.Parse(freeze))
       {
         Thread.Sleep(System.Threading.Timeout.Infinite);
     }
    }
    ```
    
  * <span data-ttu-id="121d9-391">ロールの ServiceDefinition.csdef ファイルと ServiceConfiguration.\*.cscfg ファイルに **Freeze** 設定の定義を Boolean 値として追加し、**false** に設定します。</span><span class="sxs-lookup"><span data-stu-id="121d9-391">Add the definition of the **Freeze** setting as a Boolean value to the ServiceDefinition.csdef and ServiceConfiguration.\*.cscfg files for the role and set it to **false**.</span></span> <span data-ttu-id="121d9-392">ロールが再起動を繰り返す状態になった場合は、この設定を **true** に変更してロールの実行を凍結 (Freeze) させれば、それまでの環境とスワップできる状態になります。</span><span class="sxs-lookup"><span data-stu-id="121d9-392">If the role goes into a repeated restart mode, you can change the setting to **true** to freeze role execution and allow it to be swapped with a previous version.</span></span>

#### <a name="more-information"></a><span data-ttu-id="121d9-393">詳細情報</span><span class="sxs-lookup"><span data-stu-id="121d9-393">More information</span></span>
* [<span data-ttu-id="121d9-394">Compute Resource Consolidation パターン</span><span class="sxs-lookup"><span data-stu-id="121d9-394">Compute Resource Consolidation Pattern</span></span>](http://msdn.microsoft.com/library/dn589778.aspx)
* [<span data-ttu-id="121d9-395">Azure Web ジョブ SDK の使用</span><span class="sxs-lookup"><span data-stu-id="121d9-395">Get started with the Azure WebJobs SDK</span></span>](/azure/app-service-web/websites-dotnet-webjobs-sdk-get-started/)


## <a name="partitioning"></a><span data-ttu-id="121d9-396">パーティション分割</span><span class="sxs-lookup"><span data-stu-id="121d9-396">Partitioning</span></span>
<span data-ttu-id="121d9-397">バックグラウンド タスクを既存のコンピューティング インスタンス (Web アプリ、Web ロール、既存の worker ロール、仮想マシンなど) でホストすることにした場合、そのコンピューティング インスタンスとバックグラウンド タスクそのもののパフォーマンス特性に波及する影響を考慮に入れる必要があります。</span><span class="sxs-lookup"><span data-stu-id="121d9-397">If you decide to include background tasks within an existing compute instance (such as a web app, web role, existing worker role, or virtual machine), you must consider how this will affect the quality attributes of the compute instance and the background task itself.</span></span> <span data-ttu-id="121d9-398">以下、既存のコンピューティング インスタンスを間借りする形でタスクを配置するか、独立したコンピューティング インスタンスを専用に用意して配置するかを決めるうえでの判断材料としてください。</span><span class="sxs-lookup"><span data-stu-id="121d9-398">These factors will help you to decide whether to colocate the tasks with the existing compute instance or separate them out into a separate compute instance:</span></span>

* <span data-ttu-id="121d9-399">**稼働率**: バックグラウンド タスクに、アプリケーションの他の領域 (特に、ユーザーとの対話を直接つかさどる UI などの領域) と同じレベルの稼働率は必要ありません。</span><span class="sxs-lookup"><span data-stu-id="121d9-399">**Availability**: Background tasks might not need to have the same level of availability as other parts of the application, in particular the UI and other parts that are directly involved in user interaction.</span></span> <span data-ttu-id="121d9-400">バックグラウンド タスクは、処理をキューに追加することができるため、遅延や接続失敗時の再試行など、稼働率を左右する要因は、ある程度許容することができます。</span><span class="sxs-lookup"><span data-stu-id="121d9-400">Background tasks might be more tolerant of latency, retried connection failures, and other factors that affect availability because the operations can be queued.</span></span> <span data-ttu-id="121d9-401">ただし、要求が溢れてしまうとキューがブロックされてアプリケーション全体に影響が生じるので、ある程度の処理能力は必要です。</span><span class="sxs-lookup"><span data-stu-id="121d9-401">However, there must be sufficient capacity to prevent the backup of requests that could block queues and affect the application as a whole.</span></span>
* <span data-ttu-id="121d9-402">**スケーラビリティ**: 通常、バックグラウンド タスクは、アプリケーションの UI など対話的な操作をつかさどる領域とは、スケーラビリティの要件が異なります。</span><span class="sxs-lookup"><span data-stu-id="121d9-402">**Scalability**: Background tasks are likely to have a different scalability requirement than the UI and the interactive parts of the application.</span></span> <span data-ttu-id="121d9-403">UI のスケーリングは需要のピークに対応できるように行う必要があるのに対し、未処理のバックグラウンド タスクは混雑時を避け、より少ないコンピューティング インスタンス数で実行することができます。</span><span class="sxs-lookup"><span data-stu-id="121d9-403">Scaling the UI might be necessary to meet peaks in demand, while outstanding background tasks might be completed during less busy times by a fewer number of compute instances.</span></span>
* <span data-ttu-id="121d9-404">**回復性**: バックグラウンド タスクだけをホストするコンピューティング インスタンスは、障害が発生しても、それらのタスクの要求をキューに追加 (つまりタスクが回復するまで延期) すれば、アプリケーション全体に致命的な影響は生じません。</span><span class="sxs-lookup"><span data-stu-id="121d9-404">**Resiliency**: Failure of a compute instance that just hosts background tasks might not fatally affect the application as a whole if the requests for these tasks can be queued or postponed until the task is available again.</span></span> <span data-ttu-id="121d9-405">適切な時間内にコンピューティング インスタンスまたはタスクが再起動されれば、アプリケーションのユーザーが影響を被ることはありません。</span><span class="sxs-lookup"><span data-stu-id="121d9-405">If the compute instance and/or tasks can be restarted within an appropriate interval, users of the application might not be affected.</span></span>
* <span data-ttu-id="121d9-406">**セキュリティ**: バックグラウンド タスクは、アプリケーションの UI などとは、セキュリティ上の要件や制限が異なります。</span><span class="sxs-lookup"><span data-stu-id="121d9-406">**Security**: Background tasks might have different security requirements or restrictions than the UI or other parts of the application.</span></span> <span data-ttu-id="121d9-407">独立したコンピューティング インスタンスを使うことによって、そのタスクに異なるセキュリティ環境を適用することができます。</span><span class="sxs-lookup"><span data-stu-id="121d9-407">By using a separate compute instance, you can specify a different security environment for the tasks.</span></span> <span data-ttu-id="121d9-408">また、セキュリティと独立性を高めるために、Gatekeeper などのパターンを使って、バックグラウンド コンピューティング インスタンスと UI とを分離させることもできます。</span><span class="sxs-lookup"><span data-stu-id="121d9-408">You can also use patterns such as Gatekeeper to isolate the background compute instances from the UI in order to maximize security and separation.</span></span>
* <span data-ttu-id="121d9-409">**パフォーマンス**: バックグラウンド タスクに用いるコンピューティング インスタンスのタイプは、具体的なタスクのパフォーマンス要件に合わせて選ぶことができます。</span><span class="sxs-lookup"><span data-stu-id="121d9-409">**Performance**: You can choose the type of compute instance for background tasks to specifically match the performance requirements of the tasks.</span></span> <span data-ttu-id="121d9-410">タスクに求められる処理能力が UI ほど高くない場合は、より安価なコンピューティング オプションを選ぶことができます。逆に、UI よりも高い処理能力と多くのリソースが必要である場合は、コンピューティング インスタンスを増設することができます。</span><span class="sxs-lookup"><span data-stu-id="121d9-410">This might mean using a less expensive compute option if the tasks do not require the same processing capabilities as the UI, or a larger instance if they require additional capacity and resources.</span></span>
* <span data-ttu-id="121d9-411">**管理性**: バックグラウンド タスクは、開発とデプロイの頻度が、アプリケーションのメイン コードや UI とは異なる場合があります。</span><span class="sxs-lookup"><span data-stu-id="121d9-411">**Manageability**: Background tasks might have a different development and deployment rhythm from the main application code or the UI.</span></span> <span data-ttu-id="121d9-412">独立したコンピューティング インスタンスにデプロイすることで、更新とバージョン管理を単純化することができます。</span><span class="sxs-lookup"><span data-stu-id="121d9-412">Deploying them to a separate compute instance can simplify updates and versioning.</span></span>
* <span data-ttu-id="121d9-413">**コスト**: バックグラウンド タスクを実行するためのコンピューティング インスタンスを追加した場合、ホスティングにかかるコストが増えます。</span><span class="sxs-lookup"><span data-stu-id="121d9-413">**Cost**: Adding compute instances to execute background tasks increases hosting costs.</span></span> <span data-ttu-id="121d9-414">処理能力の向上とコストの増大のトレードオフを慎重に検討する必要があります。</span><span class="sxs-lookup"><span data-stu-id="121d9-414">You should carefully consider the trade-off between additional capacity and these extra costs.</span></span>

<span data-ttu-id="121d9-415">詳細については、[Leader Election](http://msdn.microsoft.com/library/dn568104.aspx) パターンと [Competing Consumers](http://msdn.microsoft.com/library/dn568101.aspx) パターンに関するページを参照してください。</span><span class="sxs-lookup"><span data-stu-id="121d9-415">For more information, see [Leader Election Pattern](http://msdn.microsoft.com/library/dn568104.aspx) and [Competing Consumers Pattern](http://msdn.microsoft.com/library/dn568101.aspx).</span></span>

## <a name="conflicts"></a><span data-ttu-id="121d9-416">競合</span><span class="sxs-lookup"><span data-stu-id="121d9-416">Conflicts</span></span>
<span data-ttu-id="121d9-417">バックグラウンド ジョブのインスタンスが複数存在する場合、データベースや記憶域などのリソースやサービスを奪い合う状況が生じる可能性があります。</span><span class="sxs-lookup"><span data-stu-id="121d9-417">If you have multiple instances of a background job, it is possible that they will compete for access to resources and services, such as databases and storage.</span></span> <span data-ttu-id="121d9-418">このとき同時アクセスによってリソースの競合が生じ、サービスの稼働状態や記憶域におけるデータの整合性に矛盾が生じる場合があります。</span><span class="sxs-lookup"><span data-stu-id="121d9-418">This concurrent access can result in resource contention, which might cause conflicts in availability of the services and in the integrity of data in storage.</span></span> <span data-ttu-id="121d9-419">リソースの競合は、排他的ロックを使って解決できます。</span><span class="sxs-lookup"><span data-stu-id="121d9-419">You can resolve resource contention by using a pessimistic locking approach.</span></span> <span data-ttu-id="121d9-420">排他的ロックは、リソースを奪い合っている複数のタスクのインスタンスが同時にサービスにアクセスできないように (データを破損させないように) する手法です。</span><span class="sxs-lookup"><span data-stu-id="121d9-420">This prevents competing instances of a task from concurrently accessing a service or corrupting data.</span></span>

<span data-ttu-id="121d9-421">競合を解決するもう 1 つのアプローチとして、バックグラウンド タスクをシングルトンとして定義し、インスタンスを 1 つしか実行できないようにする方法もあります。</span><span class="sxs-lookup"><span data-stu-id="121d9-421">Another approach to resolve conflicts is to define background tasks as a singleton, so that there is only ever one instance running.</span></span> <span data-ttu-id="121d9-422">しかし、この方法では、複数インスタンス構成の利点である信頼性とパフォーマンスが活かされません。</span><span class="sxs-lookup"><span data-stu-id="121d9-422">However, this eliminates the reliability and performance benefits that a multiple-instance configuration can provide.</span></span> <span data-ttu-id="121d9-423">特に、複数のバックグラウンド タスクを常時塞いでしまうほどに UI の処理能力が高い場合はなおさらです。</span><span class="sxs-lookup"><span data-stu-id="121d9-423">This is especially true if the UI can supply sufficient work to keep more than one background task busy.</span></span>

<span data-ttu-id="121d9-424">バックグラウンド タスクを自動的に再起動できるようにし、さらに需要のピークに対処できるだけの処理能力を与えることが必須となります。</span><span class="sxs-lookup"><span data-stu-id="121d9-424">It is vital to ensure that the background task can automatically restart and that it has sufficient capacity to cope with peaks in demand.</span></span> <span data-ttu-id="121d9-425">たとえば、十分なリソースを備えたコンピューティング インスタンスを割り当てるか、要求をいったんキューに格納しておき後で需要が落ち着いたときに処理するメカニズムを実装するか、その両方の手段を組み合わせることが考えられます。</span><span class="sxs-lookup"><span data-stu-id="121d9-425">You can achieve this by allocating a compute instance with sufficient resources, by implementing a queueing mechanism that can store requests for later execution when demand decreases, or by using a combination of these techniques.</span></span>

## <a name="coordination"></a><span data-ttu-id="121d9-426">調整</span><span class="sxs-lookup"><span data-stu-id="121d9-426">Coordination</span></span>
<span data-ttu-id="121d9-427">バックグラウンド タスクは、複合的な成り立ちを有している場合があり、1 つの結果を得たり、すべての要件を満たしたりするためには、ばらばらに存在するいくつものタスクが必要になることがあります。</span><span class="sxs-lookup"><span data-stu-id="121d9-427">The background tasks might be complex and might require multiple individual tasks to execute to produce a result or to fulfil all the requirements.</span></span> <span data-ttu-id="121d9-428">そのような場合の常套手段は、より小さなステップ (サブタスク) にタスクを分割し、複数のコンシューマーによって実行できるようにすることです。</span><span class="sxs-lookup"><span data-stu-id="121d9-428">It is common in these scenarios to divide the task into smaller discreet steps or subtasks that can be executed by multiple consumers.</span></span> <span data-ttu-id="121d9-429">複数のステップでジョブが構成されていれば、個々のステップを他のジョブで再利用できるため、効率がよく柔軟性も向上します。</span><span class="sxs-lookup"><span data-stu-id="121d9-429">Multistep jobs can be more efficient and more flexible because individual steps might be reusable in multiple jobs.</span></span> <span data-ttu-id="121d9-430">ステップの追加と削除、順序変更も容易に行うことができます。</span><span class="sxs-lookup"><span data-stu-id="121d9-430">It is also easy to add, remove, or modify the order of the steps.</span></span>

<span data-ttu-id="121d9-431">複数のタスクやステップを調整するのは容易ではありませんが、その解決策として 3 つのパターンがよく知られているので、実装するうえでの参考にしてください。</span><span class="sxs-lookup"><span data-stu-id="121d9-431">Coordinating multiple tasks and steps can be challenging, but there are three common patterns that you can use to guide your implementation of a solution:</span></span>

* <span data-ttu-id="121d9-432">**再利用可能な複数のステップにタスクを分解する**。</span><span class="sxs-lookup"><span data-stu-id="121d9-432">**Decomposing a task into multiple reusable steps**.</span></span> <span data-ttu-id="121d9-433">アプリケーションは、その処理の対象となる情報に対し、複雑度の異なる多様なタスクを実行しなければならない場合があります。</span><span class="sxs-lookup"><span data-stu-id="121d9-433">An application might be required to perform a variety of tasks of varying complexity on the information that it processes.</span></span> <span data-ttu-id="121d9-434">その処理を一体型のモジュールとして実行するのが、柔軟性は低いものの実装方法としては簡単です。</span><span class="sxs-lookup"><span data-stu-id="121d9-434">A straightforward but inflexible approach to implementing this application might be to perform this processing as a monolithic module.</span></span> <span data-ttu-id="121d9-435">しかしそのアプリケーション内のどこか他の箇所で同じ処理の一部分が必要になったとき、この方法では、コードのリファクタリングや最適化、再利用の可能性が制限されます。</span><span class="sxs-lookup"><span data-stu-id="121d9-435">However, this approach is likely to reduce the opportunities for refactoring the code, optimizing it, or reusing it if parts of the same processing are required elsewhere within the application.</span></span> <span data-ttu-id="121d9-436">詳細については、 [Pipes and Filters パターン](http://msdn.microsoft.com/library/dn568100.aspx)に関するページを参照してください。</span><span class="sxs-lookup"><span data-stu-id="121d9-436">For more information, see [Pipes and Filters Pattern](http://msdn.microsoft.com/library/dn568100.aspx).</span></span>
* <span data-ttu-id="121d9-437">**タスクのステップの実行を管理する**。</span><span class="sxs-lookup"><span data-stu-id="121d9-437">**Managing execution of the steps for a task**.</span></span> <span data-ttu-id="121d9-438">アプリケーションで実行するタスクが、多数のステップから成り立っていて、その中でリモート サービスを呼び出したり、リモート リソースにアクセスしたりする場合があります。</span><span class="sxs-lookup"><span data-stu-id="121d9-438">An application might perform tasks that comprise a number of steps (some of which might invoke remote services or access remote resources).</span></span> <span data-ttu-id="121d9-439">それぞれのステップは互いに独立しているかもしれませんが、それらを指揮するのは、タスクを実装するアプリケーションのロジックです。</span><span class="sxs-lookup"><span data-stu-id="121d9-439">The individual steps might be independent of each other, but they are orchestrated by the application logic that implements the task.</span></span> <span data-ttu-id="121d9-440">詳細については、 [Scheduler Agent Supervisor パターン](http://msdn.microsoft.com/library/dn589780.aspx)に関するページを参照してください。</span><span class="sxs-lookup"><span data-stu-id="121d9-440">For more information, see [Scheduler Agent Supervisor Pattern](http://msdn.microsoft.com/library/dn589780.aspx).</span></span>
* <span data-ttu-id="121d9-441">**タスクのステップの障害復旧を管理する**。</span><span class="sxs-lookup"><span data-stu-id="121d9-441">**Managing recovery for task steps that fail**.</span></span> <span data-ttu-id="121d9-442">一連のステップによって実行される作業は、最終的にそれらが集まって整合の取れた操作となるものであり、そのいずれかのステップで障害が発生した場合は、アプリケーション側で元に戻す必要があります。</span><span class="sxs-lookup"><span data-stu-id="121d9-442">An application might need to undo the work that is performed by a series of steps (which together define an eventually consistent operation) if one or more of the steps fail.</span></span> <span data-ttu-id="121d9-443">詳細については、 [Compensating Transaction パターン](http://msdn.microsoft.com/library/dn589804.aspx)に関するページを参照してください。</span><span class="sxs-lookup"><span data-stu-id="121d9-443">For more information, see [Compensating Transaction Pattern](http://msdn.microsoft.com/library/dn589804.aspx).</span></span>


## <a name="resiliency-considerations"></a><span data-ttu-id="121d9-444">回復性に関する考慮事項</span><span class="sxs-lookup"><span data-stu-id="121d9-444">Resiliency considerations</span></span>
<span data-ttu-id="121d9-445">バックグラウンド タスクが Reliable Services をアプリケーションに提供するためには、その回復力が重要となります。</span><span class="sxs-lookup"><span data-stu-id="121d9-445">Background tasks must be resilient in order to provide reliable services to the application.</span></span> <span data-ttu-id="121d9-446">バックグラウンド タスクを計画、設計する際は、次の点を考慮してください。</span><span class="sxs-lookup"><span data-stu-id="121d9-446">When you are planning and designing background tasks, consider the following points:</span></span>

* <span data-ttu-id="121d9-447">バックグラウンド タスクは、ロールやサービスの再起動を正規の手順で処理できることが必要です。データが破損したり、アプリケーションに不整合をもたらしたりすることは許されません。</span><span class="sxs-lookup"><span data-stu-id="121d9-447">Background tasks must be able to gracefully handle role or service restarts without corrupting data or introducing inconsistency into the application.</span></span> <span data-ttu-id="121d9-448">長時間実行されるタスクや複数のステップから成るタスクでは、"*チェック ポイント*" の使用を検討してください。ジョブの状態を永続的ストレージに保存するか、または (妥当である場合) メッセージとしてキューに保存します。</span><span class="sxs-lookup"><span data-stu-id="121d9-448">For long-running or multistep tasks, consider using *check pointing* by saving the state of jobs in persistent storage, or as messages in a queue if this is appropriate.</span></span> <span data-ttu-id="121d9-449">たとえば、状態情報をメッセージとしてキューに永続化し、タスクの進行状況に合わせてその状態情報を漸増的に更新します。そうすれば、良好な状態であることが確認できている最新のチェックポイントからタスクを処理することができ、最初からやり直す必要はありません。</span><span class="sxs-lookup"><span data-stu-id="121d9-449">For example, you can persist state information in a message in a queue and incrementally update this state information with the task progress so that the task can be processed from the last known good checkpoint--instead of restarting from the beginning.</span></span> <span data-ttu-id="121d9-450">Azure Service Bus キューを使っている場合は、メッセージ セッションを使って同じシナリオを実現できます。</span><span class="sxs-lookup"><span data-stu-id="121d9-450">When using Azure Service Bus queues, you can use message sessions to enable the same scenario.</span></span> <span data-ttu-id="121d9-451">[SetState](https://docs.microsoft.com/dotnet/api/microsoft.servicebus.messaging.messagesession.setstate?view=azureservicebus-4.0.0) メソッドと [GetState](https://docs.microsoft.com/dotnet/api/microsoft.servicebus.messaging.messagesession.getstate?view=azureservicebus-4.0.0) メソッドを使って、アプリケーションの処理状態を保存したり取得したりすることが可能です。</span><span class="sxs-lookup"><span data-stu-id="121d9-451">Sessions allow you to save and retrieve the application processing state by using the [SetState](https://docs.microsoft.com/dotnet/api/microsoft.servicebus.messaging.messagesession.setstate?view=azureservicebus-4.0.0) and [GetState](https://docs.microsoft.com/dotnet/api/microsoft.servicebus.messaging.messagesession.getstate?view=azureservicebus-4.0.0) methods.</span></span> <span data-ttu-id="121d9-452">信頼性のあるマルチステップのプロセスとワークフローを設計する方法の詳細については、「[Scheduler Agent Supervisor Pattern (Scheduler Agent Supervisor パターン)](http://msdn.microsoft.com/library/dn589780.aspx)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="121d9-452">For more information about designing reliable multistep processes and workflows, see [Scheduler Agent Supervisor Pattern](http://msdn.microsoft.com/library/dn589780.aspx).</span></span>
* <span data-ttu-id="121d9-453">Web ロールまたは worker ロールを使って複数のバックグラウンド タスクをホストするときは、失敗したタスクや停止したタスクがないか監視し、それらを再起動するように **Run** メソッドのオーバーライドを設計してください。</span><span class="sxs-lookup"><span data-stu-id="121d9-453">When you use web or worker roles to host multiple background tasks, design your override of the **Run** method to monitor for failed or stalled tasks, and restart them.</span></span> <span data-ttu-id="121d9-454">それが難しい状況で worker ロールを使っている場合は、 **Run** メソッドを終了することによって強制的に worker ロールを再起動してください。</span><span class="sxs-lookup"><span data-stu-id="121d9-454">Where this is not practical, and you are using a worker role, force the worker role to restart by exiting from the **Run** method.</span></span>
* <span data-ttu-id="121d9-455">バックグラウンド タスクとのやり取りにキューを使っている場合、普段よりも高い負荷がアプリケーションにかかっているときにはキューがバッファーとして働き、タスクに送られた要求を溜めておくことができます。</span><span class="sxs-lookup"><span data-stu-id="121d9-455">When you use queues to communicate with background tasks, the queues can act as a buffer to store requests that are sent to the tasks while the application is under higher than usual load.</span></span> <span data-ttu-id="121d9-456">負荷が低くなったときにタスクの処理が UI に追い付くことができます。</span><span class="sxs-lookup"><span data-stu-id="121d9-456">This allows the tasks to catch up with the UI during less busy periods.</span></span> <span data-ttu-id="121d9-457">このことはまた、ロールをリサイクルしても UI がブロックされないことを意味します。</span><span class="sxs-lookup"><span data-stu-id="121d9-457">It also means that recycling the role will not block the UI.</span></span> <span data-ttu-id="121d9-458">詳細については、 [Queue-Based Load Leveling パターン](http://msdn.microsoft.com/library/dn589783.aspx)に関するページを参照してください。</span><span class="sxs-lookup"><span data-stu-id="121d9-458">For more information, see [Queue-Based Load Leveling Pattern](http://msdn.microsoft.com/library/dn589783.aspx).</span></span> <span data-ttu-id="121d9-459">タスクによって重要度に差がある場合は、 [Priority Queue パターン](http://msdn.microsoft.com/library/dn589794.aspx) を用い、重要度の高いタスクが低いタスクよりも先に実行されるようにすることをお勧めします。</span><span class="sxs-lookup"><span data-stu-id="121d9-459">If some tasks are more important than others, consider implementing the [Priority Queue Pattern](http://msdn.microsoft.com/library/dn589794.aspx) to ensure that these tasks run before less important ones.</span></span>
* <span data-ttu-id="121d9-460">メッセージによって開始されるバックグラウンド タスクまたはメッセージを処理するバックグラウンド タスクは、さまざまな不整合、たとえば不適切な順序で到着するメッセージ、頻繁にエラーが起こるメッセージ (" *有害なメッセージ*")、複数回配信されるメッセージに対処できるように設計する必要があります。</span><span class="sxs-lookup"><span data-stu-id="121d9-460">Background tasks that are initiated by messages or process messages must be designed to handle inconsistencies, such as messages arriving out of order, messages that repeatedly cause an error (often referred to as *poison messages*), and messages that are delivered more than once.</span></span> <span data-ttu-id="121d9-461">以下、具体例に沿って説明します。</span><span class="sxs-lookup"><span data-stu-id="121d9-461">Consider the following:</span></span>
  * <span data-ttu-id="121d9-462">既存のデータ値に基づいてデータを変更する (たとえば既存の値に加算する) など、特定の順序で処理する必要のあるメッセージが、送信されたときと同じ順序で到着するとは限りません。</span><span class="sxs-lookup"><span data-stu-id="121d9-462">Messages that must be processed in a specific order, such as those that change data based on the existing data value (for example, adding a value to an existing value), might not arrive in the original order in which they were sent.</span></span> <span data-ttu-id="121d9-463">また、バックグラウンド タスクの各インスタンスにかかる負荷の変動によって、メッセージを処理するインスタンスが変わったり、メッセージの処理の順番が入れ替わったりする可能性もあります。</span><span class="sxs-lookup"><span data-stu-id="121d9-463">Alternatively, they might be handled by different instances of a background task in a different order due to varying loads on each instance.</span></span> <span data-ttu-id="121d9-464">特定の順序で処理する必要のあるメッセージは、バックグラウンド タスクが常に正しい順序で処理できるように、シーケンス番号やキーなど、何らかのインジケーターを含んでいる必要があります。</span><span class="sxs-lookup"><span data-stu-id="121d9-464">Messages that must be processed in a specific order should include a sequence number, key, or some other indicator that background tasks can use to ensure that they are processed in the correct order.</span></span> <span data-ttu-id="121d9-465">Azure Service Bus を使っている場合、メッセージ セッションを使って配信の順序を保証することができます。</span><span class="sxs-lookup"><span data-stu-id="121d9-465">If you are using Azure Service Bus, you can use message sessions to guarantee the order of delivery.</span></span> <span data-ttu-id="121d9-466">ただし通常は、メッセージの順序が問題とならないようにプロセスを設計した方が効率的です。</span><span class="sxs-lookup"><span data-stu-id="121d9-466">However, it is usually more efficient, where possible, to design the process so that the message order is not important.</span></span>
  * <span data-ttu-id="121d9-467">バックグラウンド タスクは通常、キュー内のメッセージを読み出し (このとき、対象のメッセージは、一時的に他のメッセージ コンシューマーからは見えなくなります)、</span><span class="sxs-lookup"><span data-stu-id="121d9-467">Typically, a background task will peek at messages in the queue, which temporarily hides them from other message consumers.</span></span> <span data-ttu-id="121d9-468">正常に処理した後でそのメッセージを削除します。</span><span class="sxs-lookup"><span data-stu-id="121d9-468">Then it deletes the messages after they have been successfully processed.</span></span> <span data-ttu-id="121d9-469">メッセージの処理中にバックグラウンド タスクで障害が発生した場合、読み出しのタイムアウト期間が経過するとそのメッセージが再びキューに現れ、</span><span class="sxs-lookup"><span data-stu-id="121d9-469">If a background task fails when processing a message, that message will reappear on the queue after the peek time-out expires.</span></span> <span data-ttu-id="121d9-470">別のタスク インスタンスによって (または同じインスタンスの次回の処理サイクルで) 処理されることになります。</span><span class="sxs-lookup"><span data-stu-id="121d9-470">It will be processed by another instance of the task or during the next processing cycle of this instance.</span></span> <span data-ttu-id="121d9-471">同じメッセージに起因するエラーが繰り返しコンシューマーで発生すると、やがてキューがいっぱいになり、タスクやキュー、最終的にはアプリケーションそのものまでブロックされてしまいます。</span><span class="sxs-lookup"><span data-stu-id="121d9-471">If the message consistently causes an error in the consumer, it will block the task, the queue, and eventually the application itself when the queue becomes full.</span></span> <span data-ttu-id="121d9-472">そのため、有害なメッセージを検出してキューから除去することが不可欠となります。</span><span class="sxs-lookup"><span data-stu-id="121d9-472">Therefore, it is vital to detect and remove poison messages from the queue.</span></span> <span data-ttu-id="121d9-473">Azure Service Bus を使っている場合、エラーの原因となるメッセージを自動的に、または手動で、対応する配信不能キューに移動することができます。</span><span class="sxs-lookup"><span data-stu-id="121d9-473">If you are using Azure Service Bus, messages that cause an error can be moved automatically or manually to an associated dead letter queue.</span></span>
  * <span data-ttu-id="121d9-474">キューは *Least Once* のメカニズムで配信が保証されますが、同じメッセージが複数回配信される可能性もあります。</span><span class="sxs-lookup"><span data-stu-id="121d9-474">Queues are guaranteed at *least once* delivery mechanisms, but they might deliver the same message more than once.</span></span> <span data-ttu-id="121d9-475">また、メッセージの処理後、キューから削除される前にバックグラウンド タスクで障害が発生した場合、そのメッセージは再び処理の対象となります。</span><span class="sxs-lookup"><span data-stu-id="121d9-475">In addition, if a background task fails after processing a message but before deleting it from the queue, the message will become available for processing again.</span></span> <span data-ttu-id="121d9-476">バックグラウンド タスクは、1 と 1 のかけ算のように、同じメッセージを繰り返し処理しても、エラーを招いたり、アプリケーションのデータに不整合を来さないことが必要です。</span><span class="sxs-lookup"><span data-stu-id="121d9-476">Background tasks should be idempotent, which means that processing the same message more than once does not cause an error or inconsistency in the application’s data.</span></span> <span data-ttu-id="121d9-477">中には、自然にそのような性質を備えている操作もあります (格納された値を特定の新しい値に設定するなど)。</span><span class="sxs-lookup"><span data-stu-id="121d9-477">Some operations are naturally idempotent, such as setting a stored value to a specific new value.</span></span> <span data-ttu-id="121d9-478">ただし、格納されている既存の値に対して値を加算する際、格納されている値が、メッセージ送信時と同じであることをチェックしなかった場合は、不整合の原因となります。</span><span class="sxs-lookup"><span data-stu-id="121d9-478">However, operations such as adding a value to an existing stored value without checking that the stored value is still the same as when the message was originally sent will cause inconsistencies.</span></span> <span data-ttu-id="121d9-479">Azure Service Bus のキューは、重複するメッセージを自動的に削除するように構成できます。</span><span class="sxs-lookup"><span data-stu-id="121d9-479">Azure Service Bus queues can be configured to automatically remove duplicated messages.</span></span>
  * <span data-ttu-id="121d9-480">Azure ストレージ キューや Azure Service Bus キューなど、一部のメッセージング システムは、メッセージがキューから読み出された回数を示すデキュー カウント プロパティをサポートしています。</span><span class="sxs-lookup"><span data-stu-id="121d9-480">Some messaging systems, such as Azure storage queues and Azure Service Bus queues, support a de-queue count property that indicates the number of times a message has been read from the queue.</span></span> <span data-ttu-id="121d9-481">反復するメッセージや有害なメッセージの処理には、このプロパティを利用できます。</span><span class="sxs-lookup"><span data-stu-id="121d9-481">This can be useful in handling repeated and poison messages.</span></span> <span data-ttu-id="121d9-482">詳細については、[非同期メッセージングの基本](http://msdn.microsoft.com/library/dn589781.aspx)と [Idempotency パターン](http://blog.jonathanoliver.com/2010/04/idempotency-patterns/)に関するページを参照してください。</span><span class="sxs-lookup"><span data-stu-id="121d9-482">For more information, see [Asynchronous Messaging Primer](http://msdn.microsoft.com/library/dn589781.aspx) and [Idempotency Patterns](http://blog.jonathanoliver.com/2010/04/idempotency-patterns/).</span></span>

## <a name="scaling-and-performance-considerations"></a><span data-ttu-id="121d9-483">スケーリングとパフォーマンスの考慮事項</span><span class="sxs-lookup"><span data-stu-id="121d9-483">Scaling and performance considerations</span></span>
<span data-ttu-id="121d9-484">バックグラウンド タスクは、システムに負荷がかかっている状況下で、アプリケーションをブロックしないこと、また操作に遅延が生じることによる不整合を起こさないことが重要です。そのような事態を引き起こさないだけのパフォーマンスをバックグラウンド タスクには確保する必要があります。</span><span class="sxs-lookup"><span data-stu-id="121d9-484">Background tasks must offer sufficient performance to ensure they do not block the application, or cause inconsistencies due to delayed operation when the system is under load.</span></span> <span data-ttu-id="121d9-485">通常、バックグラウンド タスクをホストするコンピューティング インスタンスをスケーリングすることによってパフォーマンスは向上します。</span><span class="sxs-lookup"><span data-stu-id="121d9-485">Typically, performance is improved by scaling the compute instances that host the background tasks.</span></span> <span data-ttu-id="121d9-486">バックグラウンド タスクを計画、設計する際は、スケーラビリティとパフォーマンスに関して次の点を考慮してください。</span><span class="sxs-lookup"><span data-stu-id="121d9-486">When you are planning and designing background tasks, consider the following points around scalability and performance:</span></span>

* <span data-ttu-id="121d9-487">Azure は自動スケールをサポートしています。Web Apps、Cloud Services の Web ロールと worker ロール、Virtual Machines にホストされたデプロイに対し、そのときどきの需要と負荷に応じて、または、あらかじめ決められたスケジュールに基づいてスケールアウトし、不要になったら再びスケールインする、といったことが可能です。</span><span class="sxs-lookup"><span data-stu-id="121d9-487">Azure supports autoscaling (both scaling out and scaling back in) based on current demand and load--or on a predefined schedule, for Web Apps, Cloud Services web and worker roles, and Virtual Machines hosted deployments.</span></span> <span data-ttu-id="121d9-488">この機能を利用することで、運用コストを最小限に抑えつつ、アプリケーション全体の性能を適切な水準に保つことができます。</span><span class="sxs-lookup"><span data-stu-id="121d9-488">Use this feature to ensure that the application as a whole has sufficient performance capabilities while minimizing runtime costs.</span></span>
* <span data-ttu-id="121d9-489">バックグラウンド タスクに求められるパフォーマンス要件が Cloud Services アプリケーションの他の領域 (たとえば UI や、データ アクセス レイヤーなどのコンポーネント) と異なる場合、バックグラウンド タスクをまとめて別個の worker ロールでホスティングすれば、UI とバックグラウンド タスクのロールを独立にスケーリングしながら負荷に対応することができます。</span><span class="sxs-lookup"><span data-stu-id="121d9-489">Where background tasks have a different performance capability from the other parts of a Cloud Services application (for example, the UI or components such as the data access layer), hosting the background tasks together in a separate worker role allows the UI and background task roles to scale independently to manage the load.</span></span> <span data-ttu-id="121d9-490">バックグラウンド タスク同士でパフォーマンス要件が大きく異なる場合は、それらを別々の worker ロールに分けて、それぞれのロール タイプを別々にスケーリングすることをお勧めします。</span><span class="sxs-lookup"><span data-stu-id="121d9-490">If multiple background tasks have significantly different performance capabilities from each other, consider dividing them into separate worker roles and scaling each role type independently.</span></span> <span data-ttu-id="121d9-491">ただしその場合、より少数のロールに全タスクをまとめた場合と比べ、運用コストが増える可能性があるので注意が必要です。</span><span class="sxs-lookup"><span data-stu-id="121d9-491">However, note that this might increase runtime costs compared to combining all the tasks into fewer roles.</span></span>
* <span data-ttu-id="121d9-492">単純にロールをスケーリングするだけでは、負荷がかかった状況下でのパフォーマンス低下を防ぎきれない場合もあります。</span><span class="sxs-lookup"><span data-stu-id="121d9-492">Simply scaling the roles might not be sufficient to prevent loss of performance under load.</span></span> <span data-ttu-id="121d9-493">処理チェーン全体の 1 か所がボトルネックになってしまうことを防ぐためには、ストレージ キューやその他のリソースをスケーリングすることも、場合によっては必要です。</span><span class="sxs-lookup"><span data-stu-id="121d9-493">You might also need to scale storage queues and other resources to prevent a single point of the overall processing chain from becoming a bottleneck.</span></span> <span data-ttu-id="121d9-494">それ以外にも、アプリケーションとバックグラウンド タスクで使われているストレージや各種サービスの最大スループットなどの制限も考慮してください。</span><span class="sxs-lookup"><span data-stu-id="121d9-494">Also, consider other limitations, such as the maximum throughput of storage and other services that the application and the background tasks rely on.</span></span>
* <span data-ttu-id="121d9-495">バックグラウンド タスクの設計は、スケーリングを想定して行う必要があります。</span><span class="sxs-lookup"><span data-stu-id="121d9-495">Background tasks must be designed for scaling.</span></span> <span data-ttu-id="121d9-496">たとえば、バックグラウンド タスクは、キューで待機したり適切なキューにメッセージを送信したりするために、使用中のストレージ キューの数を動的に検出できなければなりません。</span><span class="sxs-lookup"><span data-stu-id="121d9-496">For example, they must be able to dynamically detect the number of storage queues in use in order to listen on or send messages to the appropriate queue.</span></span>
* <span data-ttu-id="121d9-497">既定では、Web ジョブは、それが関連付けられている Azure Web Apps インスタンスに合わせてスケーリングされます。</span><span class="sxs-lookup"><span data-stu-id="121d9-497">By default, WebJobs scale with their associated Azure Web Apps instance.</span></span> <span data-ttu-id="121d9-498">ただし、Web ジョブを単一のインスタンスとしてのみ実行する必要がある場合は、**{ "is_singleton": true }** という JSON データを含んだ Settings.job ファイルを作成してください。</span><span class="sxs-lookup"><span data-stu-id="121d9-498">However, if you want a WebJob to run as only a single instance, you can create a Settings.job file that contains the JSON data **{ "is_singleton": true }**.</span></span> <span data-ttu-id="121d9-499">これで、関連付けられている Web アプリのインスタンスが複数存在していても、Web ジョブ インスタンスを強制的に 1 つだけ実行させることができます。</span><span class="sxs-lookup"><span data-stu-id="121d9-499">This forces Azure to only run one instance of the WebJob, even if there are multiple instances of the associated web app.</span></span> <span data-ttu-id="121d9-500">スケジュール設定されたジョブで、常に単一インスタンスとして実行する必要がある場合などにこの手法を活用できます。</span><span class="sxs-lookup"><span data-stu-id="121d9-500">This can be a useful technique for scheduled jobs that must run as only a single instance.</span></span>

## <a name="related-patterns"></a><span data-ttu-id="121d9-501">関連するパターン</span><span class="sxs-lookup"><span data-stu-id="121d9-501">Related patterns</span></span>
* [<span data-ttu-id="121d9-502">非同期メッセージングの基本</span><span class="sxs-lookup"><span data-stu-id="121d9-502">Asynchronous Messaging Primer</span></span>](http://msdn.microsoft.com/library/dn589781.aspx)
* [<span data-ttu-id="121d9-503">自動スケール ガイダンス</span><span class="sxs-lookup"><span data-stu-id="121d9-503">Autoscaling Guidance</span></span>](http://msdn.microsoft.com/library/dn589774.aspx)
* [<span data-ttu-id="121d9-504">Compensating Transaction パターン</span><span class="sxs-lookup"><span data-stu-id="121d9-504">Compensating Transaction Pattern</span></span>](http://msdn.microsoft.com/library/dn589804.aspx)
* [<span data-ttu-id="121d9-505">Competing Consumers パターン</span><span class="sxs-lookup"><span data-stu-id="121d9-505">Competing Consumers Pattern</span></span>](http://msdn.microsoft.com/library/dn568101.aspx)
* [<span data-ttu-id="121d9-506">計算分割ガイダンス</span><span class="sxs-lookup"><span data-stu-id="121d9-506">Compute Partitioning Guidance</span></span>](http://msdn.microsoft.com/library/dn589773.aspx)
* [<span data-ttu-id="121d9-507">Compute Resource Consolidation パターン</span><span class="sxs-lookup"><span data-stu-id="121d9-507">Compute Resource Consolidation Pattern</span></span>](http://msdn.microsoft.com/library/dn589778.aspx)
* [<span data-ttu-id="121d9-508">Gatekeeper パターン</span><span class="sxs-lookup"><span data-stu-id="121d9-508">Gatekeeper Pattern</span></span>](http://msdn.microsoft.com/library/dn589793.aspx)
* [<span data-ttu-id="121d9-509">Leader Election パターン</span><span class="sxs-lookup"><span data-stu-id="121d9-509">Leader Election Pattern</span></span>](http://msdn.microsoft.com/library/dn568104.aspx)
* [<span data-ttu-id="121d9-510">Pipes and Filters パターン</span><span class="sxs-lookup"><span data-stu-id="121d9-510">Pipes and Filters Pattern</span></span>](http://msdn.microsoft.com/library/dn568100.aspx)
* [<span data-ttu-id="121d9-511">Priority Queue パターン</span><span class="sxs-lookup"><span data-stu-id="121d9-511">Priority Queue Pattern</span></span>](http://msdn.microsoft.com/library/dn589794.aspx)
* [<span data-ttu-id="121d9-512">Queue-Based Load Leveling パターン</span><span class="sxs-lookup"><span data-stu-id="121d9-512">Queue-based Load Leveling Pattern</span></span>](http://msdn.microsoft.com/library/dn589783.aspx)
* [<span data-ttu-id="121d9-513">Scheduler Agent Supervisor パターン</span><span class="sxs-lookup"><span data-stu-id="121d9-513">Scheduler Agent Supervisor Pattern</span></span>](http://msdn.microsoft.com/library/dn589780.aspx)

## <a name="more-information"></a><span data-ttu-id="121d9-514">詳細情報</span><span class="sxs-lookup"><span data-stu-id="121d9-514">More information</span></span>
* [<span data-ttu-id="121d9-515">worker ロールを使用した Azure アプリケーションのスケーリング</span><span class="sxs-lookup"><span data-stu-id="121d9-515">Scaling Azure Applications with Worker Roles</span></span>](http://msdn.microsoft.com/library/hh534484.aspx#sec8)
* [<span data-ttu-id="121d9-516">バックグラウンド タスクの実行</span><span class="sxs-lookup"><span data-stu-id="121d9-516">Executing Background Tasks</span></span>](http://msdn.microsoft.com/library/ff803365.aspx)
* <span data-ttu-id="121d9-517">[Azure ロールのスタートアップ ライフサイクル](http://blog.syntaxc4.net/post/2011/04/13/windows-azure-role-startup-life-cycle.aspx) (ブログ記事)</span><span class="sxs-lookup"><span data-stu-id="121d9-517">[Azure Role Startup Life Cycle](http://blog.syntaxc4.net/post/2011/04/13/windows-azure-role-startup-life-cycle.aspx) (blog post)</span></span>
* <span data-ttu-id="121d9-518">[Azure Cloud Services ロールのライフサイクル](http://channel9.msdn.com/Series/Windows-Azure-Cloud-Services-Tutorials/Windows-Azure-Cloud-Services-Role-Lifecycle) (ビデオ)</span><span class="sxs-lookup"><span data-stu-id="121d9-518">[Azure Cloud Services Role Lifecycle](http://channel9.msdn.com/Series/Windows-Azure-Cloud-Services-Tutorials/Windows-Azure-Cloud-Services-Role-Lifecycle) (video)</span></span>
* [<span data-ttu-id="121d9-519">Azure Web ジョブ SDK とは</span><span class="sxs-lookup"><span data-stu-id="121d9-519">What is the Azure WebJobs SDK</span></span>](https://docs.microsoft.com/azure/app-service-web/websites-dotnet-webjobs-sdk)
* [<span data-ttu-id="121d9-520">Web ジョブでバックグラウンド タスクを実行する</span><span class="sxs-lookup"><span data-stu-id="121d9-520">Run Background tasks with WebJobs</span></span>](https://docs.microsoft.com/azure/app-service-web/web-sites-create-web-jobs)
* [<span data-ttu-id="121d9-521">Azure キューと Service Bus キューの比較</span><span class="sxs-lookup"><span data-stu-id="121d9-521">Azure Queues and Service Bus Queues - Compared and Contrasted</span></span>](https://docs.microsoft.com/azure/service-bus-messaging/service-bus-azure-and-service-bus-queues-compared-contrasted)
* [<span data-ttu-id="121d9-522">クラウド サービスの診断を有効にする方法</span><span class="sxs-lookup"><span data-stu-id="121d9-522">How to Enable Diagnostics in a Cloud Service</span></span>](https://docs.microsoft.com/azure/cloud-services/cloud-services-dotnet-diagnostics)

