---
title: "マイクロサービスのドメイン分析"
description: "マイクロサービスのドメイン分析"
author: MikeWasson
ms.date: 12/08/2017
ms.openlocfilehash: dc07c5195299c88a946accbe4e13a997afaaff90
ms.sourcegitcommit: a8453c4bc7c870fa1a12bb3c02e3b310db87530c
ms.translationtype: HT
ms.contentlocale: ja-JP
ms.lasthandoff: 12/29/2017
---
# <a name="designing-microservices-domain-analysis"></a><span data-ttu-id="0d8ab-103">マイクロサービスの設計: ドメイン分析</span><span class="sxs-lookup"><span data-stu-id="0d8ab-103">Designing microservices: Domain analysis</span></span> 

<span data-ttu-id="0d8ab-104">マイクロサービスの最大の課題の 1 つは、個々のサービスの境界の定義です。</span><span class="sxs-lookup"><span data-stu-id="0d8ab-104">One of the biggest challenges of microservices is to define the boundaries of individual services.</span></span> <span data-ttu-id="0d8ab-105">原則として 1 つのサービスは "1 つのこと" を行う必要がありますが、その実現のためには慎重な検討が必要です。</span><span class="sxs-lookup"><span data-stu-id="0d8ab-105">The general rule is that a service should do "one thing" &mdash; but putting that rule into practice requires careful thought.</span></span> <span data-ttu-id="0d8ab-106">"適切" な設計を作り出す機械的なプロセスはありません。</span><span class="sxs-lookup"><span data-stu-id="0d8ab-106">There is no mechanical process that will produce the "right" design.</span></span> <span data-ttu-id="0d8ab-107">ビジネス用ドメイン、要件、および目的についてよく考える必要があります。</span><span class="sxs-lookup"><span data-stu-id="0d8ab-107">You have to think deeply about your business domain, requirements, and goals.</span></span> <span data-ttu-id="0d8ab-108">そうしないと、好ましくない特徴 (サービス間の非表示の依存関係、密結合、不完全なデザインのインターフェイスなど) を持つ場当たり的な設計になる可能性があります。</span><span class="sxs-lookup"><span data-stu-id="0d8ab-108">Otherwise, you can end up with a haphazard design that exhibits some undesirable characteristics, such as hidden dependencies between services, tight coupling, or poorly designed interfaces.</span></span> <span data-ttu-id="0d8ab-109">この章では、マイクロサービスを設計するためのドメイン駆動のアプローチについて説明します。</span><span class="sxs-lookup"><span data-stu-id="0d8ab-109">In this chapter, we take a domain-driven approach to designing microservices.</span></span> 

<span data-ttu-id="0d8ab-110">マイクロサービスは、データ アクセスやメッセージングなどの水平レイヤーではなく、ビジネス機能に基づいて設計する必要があります。</span><span class="sxs-lookup"><span data-stu-id="0d8ab-110">Microservices should be designed around business capabilities, not horizontal layers such as data access or messaging.</span></span> <span data-ttu-id="0d8ab-111">また、マイクロサービスには疎結合と機能の高い凝集度が必要です。</span><span class="sxs-lookup"><span data-stu-id="0d8ab-111">In addition, they should have loose coupling and high functional cohesion.</span></span> <span data-ttu-id="0d8ab-112">他のサービスを同時に更新せずにサービスを変更できる場合、マイクロサービス同士は*ゆるやかに結び付いて*います。</span><span class="sxs-lookup"><span data-stu-id="0d8ab-112">Microservices are *loosely coupled* if you can change one service without requiring other services to be updated at the same time.</span></span> <span data-ttu-id="0d8ab-113">明確に定義された 1 つの目的 (ユーザー アカウントの管理、配送履歴の追跡など) を持つマイクロサービスは*高凝集*です。</span><span class="sxs-lookup"><span data-stu-id="0d8ab-113">A microservice is *cohesive* if it has a single, well-defined purpose, such as managing user accounts or tracking delivery history.</span></span> <span data-ttu-id="0d8ab-114">サービスはドメイン ナレッジをカプセル化し、クライアントからそのナレッジを抽象化する必要があります。</span><span class="sxs-lookup"><span data-stu-id="0d8ab-114">A service should encapsulate domain knowledge and abstract that knowledge from clients.</span></span> <span data-ttu-id="0d8ab-115">たとえば、クライアントは、スケジューリング アルゴリズムの詳細やドローン フリートの管理方法を知らなくてもドローンのスケジュールを設定できる必要があります。</span><span class="sxs-lookup"><span data-stu-id="0d8ab-115">For example, a client should be able to schedule a drone without knowing the details of the scheduling algorithm or how the drone fleet is managed.</span></span>

<span data-ttu-id="0d8ab-116">ドメイン駆動設計 (DDD) は、適切に設計された一連のマイクロサービスを作り出すためのフレームワークを提供します。</span><span class="sxs-lookup"><span data-stu-id="0d8ab-116">Domain-driven design (DDD) provides a framework that can get you most of the way to a set of well-designed microservices.</span></span> <span data-ttu-id="0d8ab-117">DDD には 2 つの異なるフェーズ (戦略と戦術) があります。</span><span class="sxs-lookup"><span data-stu-id="0d8ab-117">DDD has two distinct phases, strategic and tactical.</span></span> <span data-ttu-id="0d8ab-118">戦略的 DDD では、システムの大規模な構造を定義します。</span><span class="sxs-lookup"><span data-stu-id="0d8ab-118">In strategic DDD, you are defining the large-scale structure of the system.</span></span> <span data-ttu-id="0d8ab-119">戦略的 DDD は、アーキテクチャがビジネス機能に焦点を当てた状態を維持するために役立ちます。</span><span class="sxs-lookup"><span data-stu-id="0d8ab-119">Strategic DDD helps to ensure that your architecture remains focused on business capabilities.</span></span> <span data-ttu-id="0d8ab-120">戦術的 DDD は、ドメイン モデルの作成に使うことのできる一連の設計パターンを提供します。</span><span class="sxs-lookup"><span data-stu-id="0d8ab-120">Tactical DDD provides a set of design patterns that you can use to create the domain model.</span></span> <span data-ttu-id="0d8ab-121">これらのパターンには、エンティティ、集約、およびドメイン サービスがあります。</span><span class="sxs-lookup"><span data-stu-id="0d8ab-121">These patterns include entities, aggregates, and domain services.</span></span> <span data-ttu-id="0d8ab-122">このような戦術的パターンを使うと、疎結合および高凝集のマイクロサービスを設計できます。</span><span class="sxs-lookup"><span data-stu-id="0d8ab-122">These tactical patterns will help you to design microservices that are both loosely coupled and cohesive.</span></span>

![](./images/ddd-process.png)

<span data-ttu-id="0d8ab-123">この章と次の章では、以下の手順について説明し、それらをドローン配送アプリケーションに適用します。</span><span class="sxs-lookup"><span data-stu-id="0d8ab-123">In this chapter and the next, we'll walk through the following steps, applying them to the Drone Delivery application:</span></span> 

1. <span data-ttu-id="0d8ab-124">最初にビジネス用ドメインを分析し、アプリケーションの機能的な要件を理解します。</span><span class="sxs-lookup"><span data-stu-id="0d8ab-124">Start by analyzing the business domain to understand the application's functional requirements.</span></span> <span data-ttu-id="0d8ab-125">この手順により、正式でないドメインの記述が生成されます。この記述をより正式なドメイン モデルのセットに作り替えることができます。</span><span class="sxs-lookup"><span data-stu-id="0d8ab-125">The output of this step is an informal description of the domain, which can be refined into a more formal set of domain models.</span></span> 

2. <span data-ttu-id="0d8ab-126">次に、ドメインの*境界付けられたコンテキスト*を定義します。</span><span class="sxs-lookup"><span data-stu-id="0d8ab-126">Next, define the *bounded contexts* of the domain.</span></span> <span data-ttu-id="0d8ab-127">境界付けられた各コンテキストには、大規模なアプリケーションの特定のサブドメインを表すドメイン モデルが含まれています。</span><span class="sxs-lookup"><span data-stu-id="0d8ab-127">Each bounded context contains a domain model that represents a particular subdomain of the larger application.</span></span> 

3. <span data-ttu-id="0d8ab-128">境界付けられたコンテキスト内で、戦術的 DDD パターンを適用して、エンティティ、集約、およびドメイン サービスを定義します。</span><span class="sxs-lookup"><span data-stu-id="0d8ab-128">Within a bounded context, apply tactical DDD patterns to define entities, aggregates, and domain services.</span></span> 
 
4. <span data-ttu-id="0d8ab-129">前の手順の結果を使って、アプリケーションのマイクロサービスを識別します。</span><span class="sxs-lookup"><span data-stu-id="0d8ab-129">Use the results from the previous step to identity the microservices in your application.</span></span>

<span data-ttu-id="0d8ab-130">この章では、DDD と主に関連のある最初の 3 つの手順について説明します。</span><span class="sxs-lookup"><span data-stu-id="0d8ab-130">In this chapter, we cover the first three steps, which are primarily concerned with DDD.</span></span> <span data-ttu-id="0d8ab-131">マイクロサービスの識別は次の章で行います。</span><span class="sxs-lookup"><span data-stu-id="0d8ab-131">In the next chapter, we will identify the microservices.</span></span> <span data-ttu-id="0d8ab-132">ただし、DDD は反復的かつ継続的なプロセスであることを覚えておいてください。</span><span class="sxs-lookup"><span data-stu-id="0d8ab-132">However, it's important to remember that DDD is an iterative, ongoing process.</span></span> <span data-ttu-id="0d8ab-133">サービスの境界は固定されていません。</span><span class="sxs-lookup"><span data-stu-id="0d8ab-133">Service boundaries aren't fixed in stone.</span></span> <span data-ttu-id="0d8ab-134">アプリケーションの進化に伴って、1 つのサービスを複数の小さなサービスに分割することができます。</span><span class="sxs-lookup"><span data-stu-id="0d8ab-134">As an application evolves, you may decide to break apart a service into several smaller services.</span></span>

> [!NOTE]
> <span data-ttu-id="0d8ab-135">この章では、ドメインの完全かつ包括的な分析については説明しません。</span><span class="sxs-lookup"><span data-stu-id="0d8ab-135">This chapter is not meant to show a complete and comprehensive domain analysis.</span></span> <span data-ttu-id="0d8ab-136">主要なポイントを示すために、あえて簡単な例を取り上げています。</span><span class="sxs-lookup"><span data-stu-id="0d8ab-136">We deliberately kept the example brief, in order to illustrate the main points.</span></span> <span data-ttu-id="0d8ab-137">DDD の詳しい背景情報については、この用語を最初に紹介した Eric Evans 氏の著書『*Domain-Driven Design*』をお読みになることをお勧めします。</span><span class="sxs-lookup"><span data-stu-id="0d8ab-137">For more background on DDD, we recommend Eric Evans' *Domain-Driven Design*, the book that first introduced the term.</span></span> <span data-ttu-id="0d8ab-138">その他の参考資料としては、Vaughn Vernon 氏の著書『*Implementing Domain-Driven Design*』があります。</span><span class="sxs-lookup"><span data-stu-id="0d8ab-138">Another good reference is *Implementing Domain-Driven Design* by Vaughn Vernon.</span></span> 

## <a name="analyze-the-domain"></a><span data-ttu-id="0d8ab-139">ドメインを分析する</span><span class="sxs-lookup"><span data-stu-id="0d8ab-139">Analyze the domain</span></span>

<span data-ttu-id="0d8ab-140">DDD アプローチを使うと、各サービスがビジネスの機能的な要件に適合するようなマイクロサービスを設計できます。</span><span class="sxs-lookup"><span data-stu-id="0d8ab-140">Using a DDD approach will help you to design microservices so that every service forms a natural fit to a functional business requirement.</span></span> <span data-ttu-id="0d8ab-141">また、組織の境界やテクノロジの選択が設計に影響するというトラップを回避できます。</span><span class="sxs-lookup"><span data-stu-id="0d8ab-141">It can help you to avoid the trap of letting organizational boundaries or technology choices dictate your design.</span></span>

<span data-ttu-id="0d8ab-142">コードを記述する前に、作成するシステムを俯瞰する必要があります。</span><span class="sxs-lookup"><span data-stu-id="0d8ab-142">Before writing any code, you need a bird's eye view of the system that you are creating.</span></span> <span data-ttu-id="0d8ab-143">DDD では、最初にビジネス用ドメインをモデリングして、*ドメイン モデル*を作成します。</span><span class="sxs-lookup"><span data-stu-id="0d8ab-143">DDD starts by modeling the business domain and creating a *domain model*.</span></span> <span data-ttu-id="0d8ab-144">ドメイン モデルはビジネス用ドメインの抽象化モデルです。</span><span class="sxs-lookup"><span data-stu-id="0d8ab-144">The domain model is an abstract model of the business domain.</span></span> <span data-ttu-id="0d8ab-145">このモデルはドメイン ナレッジを抽出して整理し、開発者やドメイン エキスパートに共通の言語を提供します。</span><span class="sxs-lookup"><span data-stu-id="0d8ab-145">It distills and organizes domain knowledge, and provides a common language for developers and domain experts.</span></span> 

<span data-ttu-id="0d8ab-146">最初に、すべてのビジネス機能とその関係をマッピングします。</span><span class="sxs-lookup"><span data-stu-id="0d8ab-146">Start by mapping all of the business functions and their connections.</span></span> <span data-ttu-id="0d8ab-147">これは、ドメイン エキスパート、ソフトウェア アーキテクト、およびその他の関係者が関与する共同作業になる可能性があります。</span><span class="sxs-lookup"><span data-stu-id="0d8ab-147">This will likely be a collaborative effort that involves domain experts, software architects, and other stakeholders.</span></span> <span data-ttu-id="0d8ab-148">特定の形式を使う必要はありません。</span><span class="sxs-lookup"><span data-stu-id="0d8ab-148">You don't need to use any particular formalism.</span></span>  <span data-ttu-id="0d8ab-149">図をスケッチするか、ホワイトボードに描画します。</span><span class="sxs-lookup"><span data-stu-id="0d8ab-149">Sketch a diagram or draw on whiteboard.</span></span>

<span data-ttu-id="0d8ab-150">図を描画したら、個別のサブドメインの識別を開始できます。</span><span class="sxs-lookup"><span data-stu-id="0d8ab-150">As you fill in the diagram, you may start to identify discrete subdomains.</span></span> <span data-ttu-id="0d8ab-151">密接に関連している機能はどれか、</span><span class="sxs-lookup"><span data-stu-id="0d8ab-151">Which functions are closely related?</span></span> <span data-ttu-id="0d8ab-152">ビジネスの中核となる機能はどれか、付帯的なサービスを提供する機能はどれか、</span><span class="sxs-lookup"><span data-stu-id="0d8ab-152">Which functions are core to the business, and which provide ancillary services?</span></span> <span data-ttu-id="0d8ab-153">依存関係グラフとは何かを確認します。</span><span class="sxs-lookup"><span data-stu-id="0d8ab-153">What is the dependency graph?</span></span> <span data-ttu-id="0d8ab-154">この最初のフェーズでは、テクノロジや実装の詳細を気にすることはありません。</span><span class="sxs-lookup"><span data-stu-id="0d8ab-154">During this initial phase, you aren't concerned with technologies or implementation details.</span></span> <span data-ttu-id="0d8ab-155">とは言え、アプリケーションを外部システム (CRM、支払い処理、請求システムなど) と統合する必要のある場所について注意する必要があります。</span><span class="sxs-lookup"><span data-stu-id="0d8ab-155">That said, you should note the place where the application will need to integrate with external systems, such as CRM, payment processing, or billing systems.</span></span> 

## <a name="drone-delivery-analyzing-the-business-domain"></a><span data-ttu-id="0d8ab-156">ドローン配送: ビジネス用ドメインの分析</span><span class="sxs-lookup"><span data-stu-id="0d8ab-156">Drone Delivery: Analyzing the business domain.</span></span>

<span data-ttu-id="0d8ab-157">最初のいくつかのドメイン分析の完了後、Fabrikam のチームはドローン配送ドメインを示すおおまかなスケッチを作成しました。</span><span class="sxs-lookup"><span data-stu-id="0d8ab-157">After some initial domain analysis, the Fabrikam team came up with a rough sketch that depicts the Drone Delivery domain.</span></span>

![](./images/ddd1.svg) 

- <span data-ttu-id="0d8ab-158">**出荷**はビジネスの中核であるため、図の中央に配置します。</span><span class="sxs-lookup"><span data-stu-id="0d8ab-158">**Shipping** is placed in the center of the diagram, because it's core to the business.</span></span> <span data-ttu-id="0d8ab-159">図のそれ以外の要素は、この機能を実現するために存在します。</span><span class="sxs-lookup"><span data-stu-id="0d8ab-159">Everything else in the diagram exists to enable this functionality.</span></span>
- <span data-ttu-id="0d8ab-160">**ドローンの管理**もビジネスの中核です。</span><span class="sxs-lookup"><span data-stu-id="0d8ab-160">**Drone management** is also core to the business.</span></span> <span data-ttu-id="0d8ab-161">ドローン管理と密接に関連する機能には、**ドローンの修理**、および**予測分析**によるドローンの付帯サービスとメンテナンスが必要な時期の予測があります。</span><span class="sxs-lookup"><span data-stu-id="0d8ab-161">Functionality that is closely related to drone management includes **drone repair** and using **predictive analysis** to predict when drones need servicing and maintenance.</span></span> 
- <span data-ttu-id="0d8ab-162">**ETA 分析**は集配の時間を見積もります。</span><span class="sxs-lookup"><span data-stu-id="0d8ab-162">**ETA analysis** provides time estimates for pickup and delivery.</span></span> 
- <span data-ttu-id="0d8ab-163">**サード パーティの輸送**では、荷物をドローンで出荷できない場合の代替輸送方法をアプリケーションでスケジュールできます。</span><span class="sxs-lookup"><span data-stu-id="0d8ab-163">**Third-party transportation** will enable the application to schedule alternative transportation methods if a package cannot be shipped entirely by drone.</span></span>
- <span data-ttu-id="0d8ab-164">**ドローンの共有**は、コア ビジネスを拡張するものです。</span><span class="sxs-lookup"><span data-stu-id="0d8ab-164">**Drone sharing** is a possible extension of the core business.</span></span> <span data-ttu-id="0d8ab-165">企業では、ドローンが空きがある期間に、使われていないドローンを貸し出すことができます。</span><span class="sxs-lookup"><span data-stu-id="0d8ab-165">The company may have excess drone capacity during certain hours, and could rent out drones that would otherwise be idle.</span></span> <span data-ttu-id="0d8ab-166">この機能は、初期リリースには含まれていません。</span><span class="sxs-lookup"><span data-stu-id="0d8ab-166">This feature will not be in the initial release.</span></span>
- <span data-ttu-id="0d8ab-167">**ビデオ監視**は、企業が後から展開する可能性のあるもう 1 つの分野です。</span><span class="sxs-lookup"><span data-stu-id="0d8ab-167">**Video surveillance** is another area that the company might expand into later.</span></span>
- <span data-ttu-id="0d8ab-168">**ユーザー アカウント**、**請求**、および**コール センター**は、コア ビジネスをサポートするサブドメインです。</span><span class="sxs-lookup"><span data-stu-id="0d8ab-168">**User accounts**, **Invoicing**, and **Call center** are subdomains that support the core business.</span></span>
 
<span data-ttu-id="0d8ab-169">プロセスのこの時点では、実装やテクノロジに関する決定を行っていません。</span><span class="sxs-lookup"><span data-stu-id="0d8ab-169">Notice that at this point in the process, we haven't made any decisions about implementation or technologies.</span></span> <span data-ttu-id="0d8ab-170">一部のサブシステムには、外部のソフトウェア システムやサード パーティのサービスが含まれている可能性があります。</span><span class="sxs-lookup"><span data-stu-id="0d8ab-170">Some of the subsystems may involve external software systems or third-party services.</span></span> <span data-ttu-id="0d8ab-171">その場合でも、アプリケーションはこれらのシステムやサービスとやり取りする必要があるため、ドメイン モデルにシステムやサービスを追加することが重要です。</span><span class="sxs-lookup"><span data-stu-id="0d8ab-171">Even so, the application needs to interact with these systems and services, so it's important to include them in the domain model.</span></span> 

> [!NOTE]
> <span data-ttu-id="0d8ab-172">アプリケーションが外部システムに依存する場合は、外部システムのデータ スキーマや API がアプリケーションに漏えいし、最終的にアーキテクチャの設計が損なわれるというリスクがあります。</span><span class="sxs-lookup"><span data-stu-id="0d8ab-172">When an application depends on an external system, there is a risk that the external system's data schema or API will leak into your application, ultimately compromising the architectural design.</span></span> <span data-ttu-id="0d8ab-173">これは、最新のベスト プラクティスに従っていない、および複雑なデータ スキーマや古い API を使っている従来のシステムに特に当てはまります。</span><span class="sxs-lookup"><span data-stu-id="0d8ab-173">This is particularly true with legacy systems that may not follow modern best practices, and may use convoluted data schemas or obsolete APIs.</span></span> <span data-ttu-id="0d8ab-174">その場合は、これらの外部システムとアプリケーション間の境界を明確に定義することが重要です。</span><span class="sxs-lookup"><span data-stu-id="0d8ab-174">In that case, it's important to have a well-defined boundary between these external systems and the application.</span></span> <span data-ttu-id="0d8ab-175">そのためには、[ストラングラー パターン](../patterns/strangler.md)や[破損対策レイヤー パターン](../patterns/anti-corruption-layer.md)の使用を検討してください。</span><span class="sxs-lookup"><span data-stu-id="0d8ab-175">Consider using the [Strangler Pattern](../patterns/strangler.md) or the [Anti-Corruption Layer Pattern](../patterns/anti-corruption-layer.md) for this purpose.</span></span>

## <a name="define-bounded-contexts"></a><span data-ttu-id="0d8ab-176">境界付けられたコンテキストを定義する</span><span class="sxs-lookup"><span data-stu-id="0d8ab-176">Define bounded contexts</span></span>

<span data-ttu-id="0d8ab-177">ドメイン モデルには、世界中に存在する実際のもの (ユーザー、ドローン、荷物など) の表現が含まれます。</span><span class="sxs-lookup"><span data-stu-id="0d8ab-177">The domain model will include representations of real things in the world &mdash; users, drones, packages, and so forth.</span></span> <span data-ttu-id="0d8ab-178">ただし、同じものについてシステム全体で同じ表現を使わなければならないというわけではありません。</span><span class="sxs-lookup"><span data-stu-id="0d8ab-178">But that doesn't mean that every part of the system needs to use the same representations for the same things.</span></span> 

<span data-ttu-id="0d8ab-179">たとえば、ドローンの修理と予測分析を扱うサブシステムでは、ドローンの多くの物理的特性 (メンテナンス履歴、マイレージ、年数、モデル番号、性能の特徴など) を表す必要があります。</span><span class="sxs-lookup"><span data-stu-id="0d8ab-179">For example, subsystems that handle drone repair and predictive analysis will need to represent many physical characteristics drones, such as their maintenance history, mileage, age, model number, performance characteristics, and so on.</span></span> <span data-ttu-id="0d8ab-180">しかし、配送をスケジュールするときは、それらについて考慮しません。</span><span class="sxs-lookup"><span data-stu-id="0d8ab-180">But when it's time to schedule a delivery, we don't care about those things.</span></span> <span data-ttu-id="0d8ab-181">スケジューリング サブシステムでは、ドローンが使用可能か、および集配の ETA だけを把握する必要があります。</span><span class="sxs-lookup"><span data-stu-id="0d8ab-181">The scheduling subsystem only needs to know whether a drone is available, and the ETA for pickup and delivery.</span></span> 

<span data-ttu-id="0d8ab-182">これらの 2 つのサブシステムに対して 1 つのモデルを作成しようとすると、不必要に複雑なモデルになります。</span><span class="sxs-lookup"><span data-stu-id="0d8ab-182">If we tried to create a single model for both of these subsystems, it would be unnecessarily complex.</span></span> <span data-ttu-id="0d8ab-183">また、変更を行う場合に複数のチームが個々のサブシステムに対して作業を行う必要があるため、時間の経過と共にモデルの進化が難しくなります。</span><span class="sxs-lookup"><span data-stu-id="0d8ab-183">It would also become harder for the model to evolve over time, because any changes will need to satisfy multiple teams working on separate subsystems.</span></span> <span data-ttu-id="0d8ab-184">そのため、多くの場合、現実世界のエンティティ (ここではドローン) を 2 つの異なるコンテキストで表す個別のモデルを設計することをお勧めします。</span><span class="sxs-lookup"><span data-stu-id="0d8ab-184">Therefore, it's often better to design separate models that represent the same real-world entity (in this case, a drone) in two different contexts.</span></span> <span data-ttu-id="0d8ab-185">各モデルには、特定のコンテキスト内に関連する機能と属性だけが含まれます。</span><span class="sxs-lookup"><span data-stu-id="0d8ab-185">Each model contains only the features and attributes that are relevant within its particular context.</span></span>

<span data-ttu-id="0d8ab-186">ここで、*境界付けられたコンテキスト*という DDD の概念が作用します。</span><span class="sxs-lookup"><span data-stu-id="0d8ab-186">This is where the DDD concept of *bounded contexts* comes into play.</span></span> <span data-ttu-id="0d8ab-187">境界付けられたコンテキストは、特定のドメイン モデルが適用されるドメイン内の単なる境界です。</span><span class="sxs-lookup"><span data-stu-id="0d8ab-187">A bounded context is simply the boundary within a domain where a particular domain model applies.</span></span> <span data-ttu-id="0d8ab-188">前述の図では、さまざまな機能が 1 つのドメイン モデルを共有するかどうかに従って機能をグループ化できます。</span><span class="sxs-lookup"><span data-stu-id="0d8ab-188">Looking at the previous diagram, we can group functionality according to whether various functions will share a single domain model.</span></span> 

![](./images/ddd2.svg) 
 
<span data-ttu-id="0d8ab-189">境界付けられたコンテキストは、必ずしも互いに分離された状態である必要はありません。</span><span class="sxs-lookup"><span data-stu-id="0d8ab-189">Bounded contexts are not necessarily isolated from one another.</span></span> <span data-ttu-id="0d8ab-190">この図では、境界付けられたコンテキストを結ぶ実線は、2 つの境界付けられたコンテキストがやり取りする場所を表します。</span><span class="sxs-lookup"><span data-stu-id="0d8ab-190">In this diagram, the solid lines connecting the bounded contexts represent places where two bounded contexts interact.</span></span> <span data-ttu-id="0d8ab-191">たとえば、"出荷" は顧客の情報を取得するために "ユーザー アカウント" に依存し、フリートのドローンをスケジュールするために "ドローン管理" に依存します。</span><span class="sxs-lookup"><span data-stu-id="0d8ab-191">For example, Shipping depends on User Accounts to get information about customers, and on Drone Management to schedule drones from the fleet.</span></span>

<span data-ttu-id="0d8ab-192">Eric Evans 氏は、著書『*Domain Driven Design*』で、別の境界付けられたコンテキストとやり取りする際にドメイン モデルの整合性を維持するための複数のパターンについて説明しています。</span><span class="sxs-lookup"><span data-stu-id="0d8ab-192">In the book *Domain Driven Design*, Eric Evans describes several patterns for maintaining the integrity of a domain model when it interacts with another bounded context.</span></span> <span data-ttu-id="0d8ab-193">マイクロサービスの主要な原則の 1 つは、明確に定義された API を通じてサービスがやり取りするということです。</span><span class="sxs-lookup"><span data-stu-id="0d8ab-193">One of the main principles of microservices is that services communicate through well-defined APIs.</span></span> <span data-ttu-id="0d8ab-194">このアプローチは、Evans 氏が Open Host Service および Published Language と呼ぶ 2 つのパターンに対応します。</span><span class="sxs-lookup"><span data-stu-id="0d8ab-194">This approach corresponds to two patterns that Evans calls Open Host Service and Published Language.</span></span> <span data-ttu-id="0d8ab-195">Open Host Service では、サブシステムが他のサブシステムとやり取りするための正式なプロトコル (API) を定義します。</span><span class="sxs-lookup"><span data-stu-id="0d8ab-195">The idea of Open Host Service is that a subsystem defines a formal protocol (API) for other subsystems to communicate with it.</span></span> <span data-ttu-id="0d8ab-196">Published Language は、他のチームがクライアントを記述するために使うことのできる形式で API を発行することにより、この考え方を拡張したものです。</span><span class="sxs-lookup"><span data-stu-id="0d8ab-196">Published Language extends this idea by publishing the API in a form that other teams can use to write clients.</span></span> <span data-ttu-id="0d8ab-197">「[API Design](./api-design.md)」(API の設計) の章では、[OpenAPI 仕様](https://www.openapis.org/specification/repo) (旧称 Swagger) を使って、JSON または YAML 形式で表現された、REST API 用の言語に依存しないインターフェイスの記述を定義する方法について説明します。</span><span class="sxs-lookup"><span data-stu-id="0d8ab-197">In the chapter on [API Design](./api-design.md), we discuss using [OpenAPI Specification](https://www.openapis.org/specification/repo) (formerly known as Swagger) to define language-agnostic interface descriptions for REST APIs, expressed in JSON or YAML format.</span></span>

<span data-ttu-id="0d8ab-198">この記事の以降の部分では、境界付けられたコンテキスト "出荷" について重点的に説明します。</span><span class="sxs-lookup"><span data-stu-id="0d8ab-198">For the rest of this journey, we will focus on the Shipping bounded context.</span></span> 

## <a name="tactical-ddd"></a><span data-ttu-id="0d8ab-199">戦術的 DDD</span><span class="sxs-lookup"><span data-stu-id="0d8ab-199">Tactical DDD</span></span>

<span data-ttu-id="0d8ab-200">DDD の戦略フェーズでは、ビジネス用ドメインを策定し、ドメイン モデルの境界付けられたコンテキストを定義します。</span><span class="sxs-lookup"><span data-stu-id="0d8ab-200">During the strategic phase of DDD, you are mapping out the business domain and defining bounded contexts for your domain models.</span></span> <span data-ttu-id="0d8ab-201">戦術的 DDD では、ドメイン モデルをより正確に定義します。</span><span class="sxs-lookup"><span data-stu-id="0d8ab-201">Tactical DDD is when you define your domain models with more precision.</span></span> <span data-ttu-id="0d8ab-202">戦術的パターンは、1 つの境界付けられたコンテキスト内で適用されます。</span><span class="sxs-lookup"><span data-stu-id="0d8ab-202">The tactical patterns are applied within a single bounded context.</span></span> <span data-ttu-id="0d8ab-203">マイクロサービスのアーキテクチャで特に興味深いのは、エンティティと集約のパターンです。</span><span class="sxs-lookup"><span data-stu-id="0d8ab-203">In a microservices architecture, we are particularly interested in the entity and aggregate patterns.</span></span> <span data-ttu-id="0d8ab-204">これらのパターンを適用すると、アプリケーション内のサービスの自然な境界を識別できます ([次の章](./microservice-boundaries.md)を参照)。</span><span class="sxs-lookup"><span data-stu-id="0d8ab-204">Applying these patterns will help us to identify natural boundaries for the services in our application (see [next chapter](./microservice-boundaries.md)).</span></span> <span data-ttu-id="0d8ab-205">原則として、マイクロサービスは集約よりは大きく、境界付けられたコンテキストよりは小さくする必要があります。</span><span class="sxs-lookup"><span data-stu-id="0d8ab-205">As a general principle, a microservice should be no smaller than an aggregate, and no larger than a bounded context.</span></span> <span data-ttu-id="0d8ab-206">最初に、戦術的パターンを確認します。</span><span class="sxs-lookup"><span data-stu-id="0d8ab-206">First, we'll review the tactical patterns.</span></span> <span data-ttu-id="0d8ab-207">次に、ドローン配送アプリケーションの境界付けられたコンテキスト "出荷" にそのパターンを適用します。</span><span class="sxs-lookup"><span data-stu-id="0d8ab-207">Then we'll apply them to the Shipping bounded context in the Drone Delivery application.</span></span> 

### <a name="overview-of-the-tactical-patterns"></a><span data-ttu-id="0d8ab-208">戦術的パターンの概要</span><span class="sxs-lookup"><span data-stu-id="0d8ab-208">Overview of the tactical patterns</span></span>

<span data-ttu-id="0d8ab-209">ここでは、戦術的 DDD パターンの概要を示します。DDD について既に詳しくご存じの場合は、このセクションをスキップしてもかまいません。</span><span class="sxs-lookup"><span data-stu-id="0d8ab-209">This section provides a brief summary of the tactical DDD patterns, so if you are already familiar with DDD, you can probably skip this section.</span></span> <span data-ttu-id="0d8ab-210">各パターンについて詳しくは、Eric Evans 氏の著書の第 5 章と第 6 章、および Vaughn Vernon 氏の著書『*Implementing Domain-Driven Design*』をご覧ください。</span><span class="sxs-lookup"><span data-stu-id="0d8ab-210">The patterns are described in more detail in chapters 5 &ndash; 6 of Eric Evans' book, and in *Implementing Domain-Driven Design* by Vaughn Vernon.</span></span> 

![](./images/ddd-patterns.png)

<span data-ttu-id="0d8ab-211">**エンティティ**: </span><span class="sxs-lookup"><span data-stu-id="0d8ab-211">**Entities**.</span></span> <span data-ttu-id="0d8ab-212">エンティティは、時間の経過に関係なく保持される一意の ID を持つオブジェクトです。</span><span class="sxs-lookup"><span data-stu-id="0d8ab-212">An entity is an object with a unique identity that persists over time.</span></span> <span data-ttu-id="0d8ab-213">たとえば、銀行取引アプリケーションでは、顧客と口座がエンティティになります。</span><span class="sxs-lookup"><span data-stu-id="0d8ab-213">For example, in a banking application, customers and accounts would be entities.</span></span> 

- <span data-ttu-id="0d8ab-214">システムでは、エンティティに一意識別子が割り当てられており、エンティティの検索や取得に使うことができます。</span><span class="sxs-lookup"><span data-stu-id="0d8ab-214">An entity has a unique identifier in the system, which can be used to look up or retrieve the entity.</span></span> <span data-ttu-id="0d8ab-215">この識別子は必ずユーザーに対して直接公開されているわけではありません。</span><span class="sxs-lookup"><span data-stu-id="0d8ab-215">That doesn't mean the identifier is always exposed directly to users.</span></span> <span data-ttu-id="0d8ab-216">データベースの GUID や主キーがこれに該当します。</span><span class="sxs-lookup"><span data-stu-id="0d8ab-216">It could be a GUID or a primary key in a database.</span></span> 
- <span data-ttu-id="0d8ab-217">ID は複数の境界付けられたコンテキストにまたがり、アプリケーションの有効期間を越えて存続する可能性があります。</span><span class="sxs-lookup"><span data-stu-id="0d8ab-217">An identity may span multiple bounded contexts, and may endure beyond the lifetime of the application.</span></span> <span data-ttu-id="0d8ab-218">たとえば、銀行口座番号や政府発行の ID が特定のアプリケーションの有効期間に関連付けられることはありません。</span><span class="sxs-lookup"><span data-stu-id="0d8ab-218">For example, bank account numbers or government-issued IDs are not tied to the lifetime of a particular application.</span></span>
- <span data-ttu-id="0d8ab-219">エンティティの属性は時間の経過と共に変わる可能性があります。</span><span class="sxs-lookup"><span data-stu-id="0d8ab-219">The attributes of an entity may change over time.</span></span> <span data-ttu-id="0d8ab-220">たとえば、個人名や住所は変わる可能性がありますが、個人は同じ人物のままです。</span><span class="sxs-lookup"><span data-stu-id="0d8ab-220">For example, a person's name or address might change, but they are still the same person.</span></span> 
- <span data-ttu-id="0d8ab-221">エンティティは他のエンティティへの参照を保持できます。</span><span class="sxs-lookup"><span data-stu-id="0d8ab-221">An entity can hold references to other entities.</span></span>
 
<span data-ttu-id="0d8ab-222">**値オブジェクト**: </span><span class="sxs-lookup"><span data-stu-id="0d8ab-222">**Value objects**.</span></span> <span data-ttu-id="0d8ab-223">値オブジェクトには ID がありません。</span><span class="sxs-lookup"><span data-stu-id="0d8ab-223">A value object has no identity.</span></span> <span data-ttu-id="0d8ab-224">このオブジェクトは属性の値でのみ定義されます。</span><span class="sxs-lookup"><span data-stu-id="0d8ab-224">It is defined only by the values of its attributes.</span></span> <span data-ttu-id="0d8ab-225">値オブジェクトも変更できません。</span><span class="sxs-lookup"><span data-stu-id="0d8ab-225">Value objects are also immutable.</span></span> <span data-ttu-id="0d8ab-226">値オブジェクトを更新するには、必ず新しいインスタンスを作成して、古いインスタンスを置き換えます。</span><span class="sxs-lookup"><span data-stu-id="0d8ab-226">To update a value object, you always create a new instance to replace the old one.</span></span> <span data-ttu-id="0d8ab-227">値オブジェクトにはドメイン ロジックをカプセル化する方法が用意されていますが、これらの方法がオブジェクトの状態に対して副次的な影響を及ぼしてはなりません。</span><span class="sxs-lookup"><span data-stu-id="0d8ab-227">Value objects can have methods that encapsulate domain logic, but those methods should have no side-effects on the object's state.</span></span> <span data-ttu-id="0d8ab-228">値オブジェクトの一般的な例として、色、日付と時刻、通貨の値が挙げられます。</span><span class="sxs-lookup"><span data-stu-id="0d8ab-228">Typical examples of value objects include colors, dates and times, and currency values.</span></span> 

<span data-ttu-id="0d8ab-229">**集約**: </span><span class="sxs-lookup"><span data-stu-id="0d8ab-229">**Aggregates**.</span></span> <span data-ttu-id="0d8ab-230">集約では、1 つ以上のエンティティを囲む一貫性の境界を定義します。</span><span class="sxs-lookup"><span data-stu-id="0d8ab-230">An aggregate defines a consistency boundary around one or more entities.</span></span> <span data-ttu-id="0d8ab-231">集約内の 1 つのエンティティはルートです。</span><span class="sxs-lookup"><span data-stu-id="0d8ab-231">Exactly one entity in an aggregate is the root.</span></span> <span data-ttu-id="0d8ab-232">ルート エンティティの識別子を使って、検索が行われます。</span><span class="sxs-lookup"><span data-stu-id="0d8ab-232">Lookup is done using the root entity's identifier.</span></span> <span data-ttu-id="0d8ab-233">集約内のその他のエンティティはルートの子であり、ルートからのポインターをたどることによって参照されます。</span><span class="sxs-lookup"><span data-stu-id="0d8ab-233">Any other entities in the aggregate are children of the root, and are referenced by following pointers from the root.</span></span> 

<span data-ttu-id="0d8ab-234">集約の目的は、トランザクションのインバリアントをモデル化することです。</span><span class="sxs-lookup"><span data-stu-id="0d8ab-234">The purpose of an aggregate is to model transactional invariants.</span></span> <span data-ttu-id="0d8ab-235">現実世界のものには複雑な関係があります。</span><span class="sxs-lookup"><span data-stu-id="0d8ab-235">Things in the real world have complex webs of relationships.</span></span> <span data-ttu-id="0d8ab-236">たとえば、顧客が注文を作成し、注文には商品が含まれ、商品には供給業者が存在する、などの関係です。</span><span class="sxs-lookup"><span data-stu-id="0d8ab-236">Customers create orders, orders contain products, products have suppliers, and so on.</span></span> <span data-ttu-id="0d8ab-237">アプリケーションがいくつかの関連オブジェクトを変更する場合は、どのように一貫性を保証するのでしょうか。</span><span class="sxs-lookup"><span data-stu-id="0d8ab-237">If the application modifies several related objects, how does it guarantee consistency?</span></span> <span data-ttu-id="0d8ab-238">また、インバリアントを追跡して実現するにはどうすればよいでしょうか。</span><span class="sxs-lookup"><span data-stu-id="0d8ab-238">How do we keep track of invariants and enforce them?</span></span>  

<span data-ttu-id="0d8ab-239">従来のアプリケーションでは、多くの場合、データベース トランザクションを使って一貫性を実現します。</span><span class="sxs-lookup"><span data-stu-id="0d8ab-239">Traditional applications have often used database transactions to enforce consistency.</span></span> <span data-ttu-id="0d8ab-240">しかし、分散アプリケーションでは、多くの場合、これを実現できません。</span><span class="sxs-lookup"><span data-stu-id="0d8ab-240">In a distributed application, however, that's often not feasible.</span></span> <span data-ttu-id="0d8ab-241">1 つのビジネス トランザクションが複数のデータ ストアにまたがる場合、トランザクションの実行時間が長い場合、またはトランザクションにサード パーティのサービスが関与する場合があります。</span><span class="sxs-lookup"><span data-stu-id="0d8ab-241">A single business transaction may span multiple data stores, or may be long running, or may involve third-party services.</span></span> <span data-ttu-id="0d8ab-242">最終的に、ドメインに必要なインバリアントの実現は、データ レイヤーではなくアプリケーションに依存します。</span><span class="sxs-lookup"><span data-stu-id="0d8ab-242">Ultimately it's up to the application, not the data layer, to enforce the invariants required for the domain.</span></span> <span data-ttu-id="0d8ab-243">それが集約によってモデル化されるものです。</span><span class="sxs-lookup"><span data-stu-id="0d8ab-243">That's what aggregates are meant to model.</span></span>

> [!NOTE]
> <span data-ttu-id="0d8ab-244">集約は 1 つのエンティティで構成され、子エンティティはありません。</span><span class="sxs-lookup"><span data-stu-id="0d8ab-244">An aggregate might consist of a single entity, without child entities.</span></span> <span data-ttu-id="0d8ab-245">エンティティが集約になるために必要なのはトランザクション境界です。</span><span class="sxs-lookup"><span data-stu-id="0d8ab-245">What makes it an aggregate is the transactional boundary.</span></span>

<span data-ttu-id="0d8ab-246">**ドメイン サービスとアプリケーション サービス**: </span><span class="sxs-lookup"><span data-stu-id="0d8ab-246">**Domain and application services**.</span></span> <span data-ttu-id="0d8ab-247">DDD の用語では、サービスとは、状態を保持せずにいくつかのロジックを実装するオブジェクトです。</span><span class="sxs-lookup"><span data-stu-id="0d8ab-247">In DDD terminology, a service is an object that implements some logic without holding any state.</span></span> <span data-ttu-id="0d8ab-248">Evans 氏は、ドメイン ロジックをカプセル化する*ドメイン サービス*と、技術的な機能 (ユーザー認証や SMS メッセージの送信など) を提供する*アプリケーション サービス*を区別しています。</span><span class="sxs-lookup"><span data-stu-id="0d8ab-248">Evans distinguishes between *domain services*, which encapsulate domain logic, and *application services*, which provide technical functionality, such as user authentication or sending an SMS message.</span></span> <span data-ttu-id="0d8ab-249">ドメイン サービスは、多くの場合、複数のエンティティにまたがる動作のモデル化に使われます。</span><span class="sxs-lookup"><span data-stu-id="0d8ab-249">Domain services are often used to model behavior that spans multiple entities.</span></span> 

> [!NOTE]
> <span data-ttu-id="0d8ab-250">ソフトウェア開発においては、*サービス*という用語に過剰な負荷がかかっています。</span><span class="sxs-lookup"><span data-stu-id="0d8ab-250">The term *service* is overloaded in software development.</span></span> <span data-ttu-id="0d8ab-251">ここでの定義はマイクロサービスに直接関連しません。</span><span class="sxs-lookup"><span data-stu-id="0d8ab-251">The definition here is not directly related to microservices.</span></span>

<span data-ttu-id="0d8ab-252">**ドメイン イベント**: </span><span class="sxs-lookup"><span data-stu-id="0d8ab-252">**Domain events**.</span></span> <span data-ttu-id="0d8ab-253">ドメイン イベントを使うと、何かが発生したときにシステムの他の部分に通知できます。</span><span class="sxs-lookup"><span data-stu-id="0d8ab-253">Domain events can be used to notify other parts of the system when something happens.</span></span> <span data-ttu-id="0d8ab-254">その名前が示すように、ドメイン イベントはドメイン内で発生するイベントです。</span><span class="sxs-lookup"><span data-stu-id="0d8ab-254">As the name suggests, domain events should mean something within the domain.</span></span> <span data-ttu-id="0d8ab-255">たとえば、"レコードがテーブルに挿入された" ことはドメイン イベントではありません。</span><span class="sxs-lookup"><span data-stu-id="0d8ab-255">For example, "a record was inserted into a table" is not a domain event.</span></span> <span data-ttu-id="0d8ab-256">"配送がキャンセルされた" ことはドメイン イベントです。</span><span class="sxs-lookup"><span data-stu-id="0d8ab-256">"A delivery was cancelled" is a domain event.</span></span> <span data-ttu-id="0d8ab-257">ドメイン イベントはマイクロサービスのアーキテクチャに特に関連します。</span><span class="sxs-lookup"><span data-stu-id="0d8ab-257">Domain events are especially relevant in a microservices architecture.</span></span> <span data-ttu-id="0d8ab-258">マイクロサービスは分散型であり、データ ストアを共有しないので、ドメイン イベントはマイクロサービスが互いに連携するための方法を提供します。</span><span class="sxs-lookup"><span data-stu-id="0d8ab-258">Because microservices are distributed and don't share data stores, domain events provide a way for microservices to coordinate with each other.</span></span> <span data-ttu-id="0d8ab-259">「[サービス間の通信](./interservice-communication.md)」の章では、非同期メッセージングについて詳しく説明します。</span><span class="sxs-lookup"><span data-stu-id="0d8ab-259">The chapter [Interservice communication](./interservice-communication.md) discusses asynchronous messaging in more detail.</span></span>
 
<span data-ttu-id="0d8ab-260">ここで説明していない DDD パターンは他にもいくつかあります (ファクトリ、リポジトリ、モジュールなど)。</span><span class="sxs-lookup"><span data-stu-id="0d8ab-260">There are a few other DDD patterns not listed here, including factories, repositories, and modules.</span></span> <span data-ttu-id="0d8ab-261">これらはマイクロサービスの実装時に役立つパターンですが、マイクロサービス間の境界の設計にはあまり関連しません。</span><span class="sxs-lookup"><span data-stu-id="0d8ab-261">These can be useful patterns for when you are implementing a microservice, but they are less relevant when designing the boundaries between microservice.</span></span>

## <a name="drone-delivery-applying-the-patterns"></a><span data-ttu-id="0d8ab-262">ドローン配送: パターンの適用</span><span class="sxs-lookup"><span data-stu-id="0d8ab-262">Drone delivery: Applying the patterns</span></span>

<span data-ttu-id="0d8ab-263">最初に、境界付けられたコンテキスト "出荷" が処理する必要のあるシナリオを見てみましょう。</span><span class="sxs-lookup"><span data-stu-id="0d8ab-263">We start with the scenarios that the Shipping bounded context must handle.</span></span>

- <span data-ttu-id="0d8ab-264">顧客は、ドローン配送サービスに登録された企業からドローンで商品を集荷するよう依頼できます。</span><span class="sxs-lookup"><span data-stu-id="0d8ab-264">A customer can request a drone to pick up goods from a business that is registered with the drone delivery service.</span></span>
- <span data-ttu-id="0d8ab-265">荷送人は、タグ (バーコードまたは RFID) を生成して荷物に取り付けます。</span><span class="sxs-lookup"><span data-stu-id="0d8ab-265">The sender generates a tag (barcode or RFID) to put on the package.</span></span> 
- <span data-ttu-id="0d8ab-266">ドローンが集荷先から荷物を集荷して、配送先に届けます。</span><span class="sxs-lookup"><span data-stu-id="0d8ab-266">A drone will pick up and deliver a package from the source location to the destination location.</span></span>
- <span data-ttu-id="0d8ab-267">顧客が配送をスケジュールするときに、システムはルート情報、気象条件、履歴データに基づいて ETA を提供します。</span><span class="sxs-lookup"><span data-stu-id="0d8ab-267">When a customer schedules a delivery, the system provides an ETA based on route information, weather conditions, and historical data.</span></span> 
- <span data-ttu-id="0d8ab-268">ドローンの飛行中、ユーザーは現在地と最新の ETA を追跡できます。</span><span class="sxs-lookup"><span data-stu-id="0d8ab-268">When the drone is in flight, a user can track the current location and the latest ETA.</span></span> 
- <span data-ttu-id="0d8ab-269">ドローンによる荷物の集荷が完了するまで、顧客は配送をキャンセルできます。</span><span class="sxs-lookup"><span data-stu-id="0d8ab-269">Until a drone has picked up the package, the customer can cancel a delivery.</span></span>
- <span data-ttu-id="0d8ab-270">配送が完了すると、顧客に通知が送信されます。</span><span class="sxs-lookup"><span data-stu-id="0d8ab-270">The customer is notified when the delivery is completed.</span></span>
- <span data-ttu-id="0d8ab-271">荷送人は、署名またはフィンガープリントの形式で顧客から配送の確認を要求できます。</span><span class="sxs-lookup"><span data-stu-id="0d8ab-271">The sender can request delivery confirmation from the customer, in the form of a signature or finger print.</span></span>
- <span data-ttu-id="0d8ab-272">ユーザーは、完了した配送の履歴を検索できます。</span><span class="sxs-lookup"><span data-stu-id="0d8ab-272">Users can look up the history of a completed delivery.</span></span>

<span data-ttu-id="0d8ab-273">これらのシナリオから、開発チームは以下の**エンティティ**を識別しました。</span><span class="sxs-lookup"><span data-stu-id="0d8ab-273">From these scenarios, the development team identified the following **entities**.</span></span>

- <span data-ttu-id="0d8ab-274">配送</span><span class="sxs-lookup"><span data-stu-id="0d8ab-274">Delivery</span></span>
- <span data-ttu-id="0d8ab-275">パッケージ</span><span class="sxs-lookup"><span data-stu-id="0d8ab-275">Package</span></span>
- <span data-ttu-id="0d8ab-276">ドローン</span><span class="sxs-lookup"><span data-stu-id="0d8ab-276">Drone</span></span>
- <span data-ttu-id="0d8ab-277">アカウント</span><span class="sxs-lookup"><span data-stu-id="0d8ab-277">Account</span></span>
- <span data-ttu-id="0d8ab-278">確認</span><span class="sxs-lookup"><span data-stu-id="0d8ab-278">Confirmation</span></span>
- <span data-ttu-id="0d8ab-279">通知</span><span class="sxs-lookup"><span data-stu-id="0d8ab-279">Notification</span></span>
- <span data-ttu-id="0d8ab-280">タグ</span><span class="sxs-lookup"><span data-stu-id="0d8ab-280">Tag</span></span>

<span data-ttu-id="0d8ab-281">最初の 4 つ (配送、荷物、ドローン、アカウント) はすべて、トランザクションの一貫性の境界を表す**集約**です。</span><span class="sxs-lookup"><span data-stu-id="0d8ab-281">The first four, Delivery, Package, Drone, and Account, are all **aggregates** that represent transactional consistency boundaries.</span></span> <span data-ttu-id="0d8ab-282">"確認" と "通知" は "配送" の子エンティティです。"タグ" は "荷物" の子エンティティです。</span><span class="sxs-lookup"><span data-stu-id="0d8ab-282">Confirmations and Notifications are child entities of Deliveries, and Tags are child entities of Packages.</span></span> 

<span data-ttu-id="0d8ab-283">この設計の**値オブジェクト**には Location、ETA、PackageWeight、および PackageSize があります。</span><span class="sxs-lookup"><span data-stu-id="0d8ab-283">The **value objects** in this design include Location, ETA, PackageWeight, and PackageSize.</span></span> 

<span data-ttu-id="0d8ab-284">"配送" 集約の UML 図を次に示します。</span><span class="sxs-lookup"><span data-stu-id="0d8ab-284">To illustrate, here is a UML diagram of the Delivery aggregate.</span></span> <span data-ttu-id="0d8ab-285">この集約は、他の集約 (アカウント、荷物、ドローン) への参照を保持します。</span><span class="sxs-lookup"><span data-stu-id="0d8ab-285">Notice that it holds references to other aggregates, including Account, Package, and Drone.</span></span>

![](./images/delivery-entity.png)

<span data-ttu-id="0d8ab-286">次の 2 つのドメイン イベントがあります。</span><span class="sxs-lookup"><span data-stu-id="0d8ab-286">There are two domain events:</span></span>

- <span data-ttu-id="0d8ab-287">ドローンの飛行中、"ドローン" エンティティはドローンの場所と状態 (飛行中、着陸) を示す DroneStatus イベントを送信します。</span><span class="sxs-lookup"><span data-stu-id="0d8ab-287">While a drone is in flight, the Drone entity sends DroneStatus events that describe the drone's location and status (in-flight, landed).</span></span>

- <span data-ttu-id="0d8ab-288">"配送" エンティティは、配送の段階が変わるたびに DeliveryTracking イベントを送信します。</span><span class="sxs-lookup"><span data-stu-id="0d8ab-288">The Delivery entity sends DeliveryTracking events whenever the stage of a delivery changes.</span></span> <span data-ttu-id="0d8ab-289">これらには、DeliveryCreated、DeliveryRescheduled、DeliveryHeadedToDropoff、DeliveryCompleted があります。</span><span class="sxs-lookup"><span data-stu-id="0d8ab-289">These include DeliveryCreated, DeliveryRescheduled, DeliveryHeadedToDropoff, and DeliveryCompleted.</span></span> 

<span data-ttu-id="0d8ab-290">これらのイベントは、ドメイン モデル内で意味のある内容を示しています。</span><span class="sxs-lookup"><span data-stu-id="0d8ab-290">Notice that these events describe things that are meaningful within the domain model.</span></span> <span data-ttu-id="0d8ab-291">これらはドメインに関する情報を示すものであり、特定のプログラミング言語コンストラクトに関連付けられません。</span><span class="sxs-lookup"><span data-stu-id="0d8ab-291">They describe something about the domain, and aren't tied to a particular programming language construct.</span></span>

<span data-ttu-id="0d8ab-292">開発チームは、これまでに記述されたどのエンティティにも当てはまらないもう 1 つの機能分野を識別しました。</span><span class="sxs-lookup"><span data-stu-id="0d8ab-292">The development team identified one more area of functionality, which doesn't fit neatly into any of the entities described so far.</span></span> <span data-ttu-id="0d8ab-293">システムの一部では、配送のスケジューリングまたは更新に関連するすべての手順を調整する必要があります。</span><span class="sxs-lookup"><span data-stu-id="0d8ab-293">Some part of the system must coordinate all of the steps involved in scheduling or updating a delivery.</span></span> <span data-ttu-id="0d8ab-294">そのため、開発チームは、2 つの**ドメイン サービス** (手順を調整する *Scheduler*、および各手順の状態を監視する *Supervisor*) を設計に追加し、いずれかの手順が失敗またはタイムアウトしたかどうかを検出するようにしました。これは [Scheduler Agent Supervisor パターン](../patterns/scheduler-agent-supervisor.md)のバリエーションです。</span><span class="sxs-lookup"><span data-stu-id="0d8ab-294">Therefore, the development team added two **domain services** to the design: a *Scheduler* that coordinates the steps, and a *Supervisor* that monitors the status of each step, in order to detect whether any steps have failed or timed out. This is a variation of the [Scheduler Agent Supervisor pattern](../patterns/scheduler-agent-supervisor.md).</span></span>

![](./images/drone-ddd.png)

> [!div class="nextstepaction"]
> [<span data-ttu-id="0d8ab-295">マイクロサービス境界の識別</span><span class="sxs-lookup"><span data-stu-id="0d8ab-295">Identifying microservice boundaries</span></span>](./microservice-boundaries.md)
