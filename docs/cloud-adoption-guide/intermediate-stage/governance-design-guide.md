---
title: 'ガバナンス設計ガイド: 複数チーム向けの Azure での新規開発'
description: 複数のチーム、複数のワークロード、および複数の環境を対象とした Azure ガバナンス管理を構成するためのガイダンス
author: petertay
ms.openlocfilehash: 05f1f9bb24af4f4da55b15c1aca2c71bc0b65411
ms.sourcegitcommit: b3d74d8a89b2224fc796ce0e89cea447af43a0d4
ms.translationtype: HT
ms.contentlocale: ja-JP
ms.lasthandoff: 06/11/2018
ms.locfileid: "35291312"
---
# <a name="governance-design-guide-new-development-in-azure-for-multiple-teams"></a>ガバナンス設計ガイド: 複数チーム向けの Azure での新規開発

このガイドの目的は、Azure でのリソース ガバナンス モデルの設計プロセスについて説明することです。  一連のガバナンス要件を例として挙げて、これらの要件に対応する実装サンプルをいくつか紹介します。 

要件を次に示します。
* Azure でさまざまなリソース アクセス要件を持つ複数のチームの ID 管理。 ID 管理システムには、次のユーザーの ID が格納されています。
  1. **サブスクリプション**の所有を担当する組織内の個人。
  2. オンプレミス ネットワークを Azure 仮想ネットワークに接続するときに使用される**共有インフラストラクチャ リソース**を担当する組織内の個人。 
  3. **ワークロード**の管理を担当する組織内の個人 (2 人)。 
* 複数の**環境**のサポート。 既に説明したように、ここで環境とは、同様の管理およびセキュリテの要件を持つリソースの論理的なグループのことです。 ここでは 3 つの環境が必要です。
  1. **共有インフラストラクチャ環境**: 他の環境のワークロードによって共有されるリソースが含まれます。 オンプレミスへの接続性を提供するゲートウェイ サブネットを含む仮想ネットワークなど。
  2. **運用環境**: 最も制限の厳しいセキュリティ ポリシーが適用されます。 内部または外部に接続されるワークロードを含めることができます。
  3. **開発環境**: 概念実証とテストを行うための環境です。 この環境のセキュリティ、コンプライアンス、およびコストの各ポリシーは、運用環境のものとは異なります。
* **最小限の特権のアクセス許可モデル**。既定では、アクセス許可がユーザーに付与されていません。 このモデルは以下をサポートする必要があります。
  * リソース アクセス権を割り当てるアクセス許可を持つ、サブスクリプション スコープの 1 人の信頼されたユーザー。
  * リソースへの各ワークロード所有者によるアクセスが既定で拒否されている。 リソース アクセス権は、サブスクリプション スコープの 1 人の信頼されたユーザーによって明示的に付与されます。
  * 共有インフラストラクチャ リソースへの管理アクセスが、インフラストラクチャ所有者に制限されている。  
  * 各ワークロードへの管理アクセスが、ワークロード所有者に制限されている。
  * [組み込み RBAC ロール][rbac-built-in-roles]のみを使用。 カスタム RBAC ロールは使用しません。
* ワークロード所有者名、環境、またはその両方でコストを追跡。 

## <a name="identity-management"></a>ID 管理

ガバナンス モデルの ID 管理を設計する前に、次の 4 つの主な領域について理解しておくことが重要です。

* 管理: ユーザー ID を作成、編集、および削除するためのプロセスとツール。
* 認証: ユーザー名、パスワードなどの資格情報を検証することにより、ユーザー ID を確認すること。
* 承認: 認証されたユーザーがアクセスできるリソースや、そのユーザーが実行できる操作を決定すること。
* 監査: ログまたはその他の情報を定期的に確認して、ユーザー ID に関連するセキュリティの問題を検出すること。 これには、不審な使用パターンがないかどうかを確認する、ユーザーのアクセス許可が正しいかどうかを定期的に確認する、などが含まれます。

ID に関して Azure が信頼するサービスは Azure Active Directory (AD) の 1 つだけです。 ここではユーザーを Azure AD に追加し、前に示したすべての領域に対して使用しますが、 Azure AD の構成方法を見る前に、これらのサービスへのアクセスの管理に使用される特権アカウントについて理解しておくことが重要です。

ご自身の組織が Azure アカウントにサインアップしたとき、少なくとも 1 人の Azure **アカウント所有者**が割り当てられ、Office 365 など、組織による他の Microsoft サービスの使用に関連付けられている Azure AD **テナント**がなかった場合は、Azure AD テナントが作成されました。 Azure AD テナントに対する完全なアクセス許可を持つ**グローバル管理者**が、そのテナントの作成時に関連付けられました。 

Azure アカウント所有者ユーザー ID と Azure AD グローバル管理者ユーザー ID の両方が、Microsoft によって管理されている安全性の高い ID システムに格納されています。 Azure アカウント所有者には、サブスクリプションを作成、更新、および削除する権限があります。 Azure AD グローバル管理者が Azure AD で許可されているアクションは多数ありますが、この設計ガイドでは、ユーザー ID の作成と削除に注目します。 

> [!NOTE]
> お使いのアカウントに既存の Office 365 または Intune ライセンスが関連付けられている場合は、ご自身の組織に Azure AD テナントが既に存在することがあります。

Azure アカウント所有者には、サブスクリプションを作成、更新、および削除するアクセス許可が付与されています。 

![Azure アカウント マネージャーと Azure AD グローバル管理者が含まれる Azure アカウント](../_images/governance-3-0.png)
*図 1. Azure アカウント マネージャーと Azure AD グローバル管理者が含まれる Azure アカウント。*

Azure AD **グローバル管理者**には、ユーザー アカウントを作成するアクセス許可が付与されています。  

![Azure アカウント マネージャーと Azure AD グローバル管理者が含まれる Azure アカウント](../_images/governance-3-0a.png)
*図 2. Azure AD グローバル管理者は必要なユーザー アカウントをテナントに作成する。*

最初の 2 つのアカウント **App1 ワークロード所有者**と **App2 ワークロード所有者**はそれぞれ、ワークロードの管理を担当する組織内の個人に関連付けられています。 **ネットワーク操作**アカウントは、共有インフラストラクチャ リソースを担当する個人が所有します。 最後の**サブスクリプション所有者**アカウントは、サブスクリプションの所有権を担当する個人と関連付けられています。

## <a name="resource-access-permissions-model-of-least-privilege"></a>最小限の特権のリソース アクセスのアクセス許可モデル

ID 管理システムとユーザー アカウントが作成されたので、次は、最小限の特権のアクセス許可モデルをサポートするために、ロールベースのアクセス制御 (RBAC) ロールを各アカウントにどのように適用するかを決める必要があります。

また、別の要件として、ワークロード所有者が、自身が所有していない他のワークロードに管理アクセスできないように、各ワークロードに関連付けられているリソースがそれぞれ、お互いに独立している必要もあります。 このモデルは、[Azure RBAC の組み込みロール][rbac-built-in-roles]のみを使用して実装する必要があります。

それぞれの RBAC ロールが、**サブスクリプション**、**リソース グループ**、個別の**リソース**の 3 つのスコープのいずれかで適用されます。 ロールは下位のスコープに継承されます。 たとえば、ユーザーに[組み込み所有者ロール][rbac-built-in-owner]がサブスクリプション レベルで割り当てられている場合、そのロールは、オーバーライドされない限り、リソース グループおよび個別のリソース レベルでもユーザーに割り当てられます。

そのため、最小限の特権アクセスのモデルを作成するには、特定のタイプのユーザーが、3 つの各スコープで実行できるアクションを決める必要があります。 たとえば、ここでは、ワークロード所有者には、自身のワークロードに関連付けられているリソースのみに対する管理アクセス許可を付与し、他のリソースは管理できないようにする必要があります。 [組み込み所有者ロール][rbac-built-in-owner]をサブスクリプション スコープで割り当てると、各ワークロード所有者はすべてのワークロードへの管理アクセス権を持つことになります。

この概念がもう少しわかるように、2 つのアクセス許可モデルの例を見てみましょう。 最初の例のモデルでは、サービス管理者のみを信頼してリソース グループを作成します。 2 番目の例のモデルでは、組み込み所有者ロールを、サブスクリプション スコープの各ワークロード所有者に割り当てます。 

両方の例に、サブスクリプション スコープで[組み込み所有者ロール][rbac-built-in-owner]が割り当てられているサブスクリプション サービス管理者がいます。 [組み込み所有者ロール][rbac-built-in-owner]によって、リソースへのアクセス管理を含むすべてのアクセス許可が付与されることを思い出してください。
![所有者ロールを持つサブスクリプション サービス管理者](../_images/governance-2-1.png)
*図 3. 組み込み所有者ロールが割り当てられたサービス管理者が含まれるサブスクリプション。* 

1. 最初の例の**ワークロード所有者 A** にはサブスクリプション スコープのアクセス許可がありません。つまり、既定では、この所有者にリソース アクセス管理のアクセス権はありません。 このユーザーは、そのワークロードに対応したリソースを展開して管理する必要があります。 ワークロード所有者は**サービス管理者**に、リソース グループを作成するように要求する必要があります。
![ワークロード所有者がリソース グループ A の作成を要求する](../_images/governance-2-2.png)  

2. **サービス管理者**はその要求を確認し、**リソース グループ A** を作成します。この時点では、まだ**ワークロード所有者 A** にはアクセス許可がないため、何もできません。
![サービス管理者がリソース グループ A を作成する](../_images/governance-2-3.png)

3. **サービス管理者**は**ワークロード所有者 A** を**リソース グループ A** に追加し、[組み込み共同作成者ロール](/azure/role-based-access-control/built-in-roles#contributor)を割り当てます。 共同作成者ロールによって、**リソース グループ A** には、アクセス管理を除くすべてのアクセス許可が付与されます。
![サービス管理者がワークロード所有者 A をリソース グループ A に追加する](../_images/governance-2-4.png)

4. **ワークロード所有者 A** は、ワークロードの容量計画の一環として、2 人のチーム メンバーが CPU とネットワーク トラフィック監視データを確認できるようにする必要があるとします。 **ワークロード所有者 A** には共同作成者ロールが割り当てられているため、ユーザーを**リソース グループ A** に追加するアクセス許可はありません。そこで、この要求を**サービス管理者**に送信する必要があります。
![ワークロード所有者が、リソース グループへのワークロード共同作成者の追加を要求する](../_images/governance-2-5.png)

5. **サービス管理者**は要求を確認し、2 人の**ワークロードの共同作成者**ユーザーを**リソース グループ A** に追加します。この 2 人のユーザーにはリソース管理のアクセス許可は必要ありません。したがって、[組み込み閲覧者ロール](/azure/role-based-access-control/built-in-roles#contributor)が割り当てられます。 
![サービス管理者がワークロード共同作成者をリソース グループ A に追加する](../_images/governance-2-6.png)

6. さらに、**ワークロード所有者 B** も、自身のワークロードに対するリソースをリソース グループに追加する必要があります。 **ワークロード所有者 A** と同様、**ワークロード所有者 B** にも、サブスクリプション スコープでアクションを実行するためのアクセス許可が最初は付与されていません。そこで、ワークロード所有者 B も**サービス管理者**に要求を送信する必要があります。 
![ワークロード所有者 B がリソース グループ B の作成を要求する](../_images/governance-2-7.png)

7. **サービス管理者**はその要求を確認し、**リソース グループ B** を作成します。![サービス管理者がリソース グループ B を作成する](../_images/governance-2-8.png)

8. 次に、**サービス管理者**は**ワークロード所有者 B** を**リソース グループ B** に追加し、[組み込み共同作成者ロール](https://docs.microsoft.com/en-us/azure/role-based-access-control/built-in-roles#contributor)を割り当てます。 
![サービス管理者がワークロード所有者 B をリソース グループ B に追加する](../_images/governance-2-9.png)

この時点で、ワークロード所有者はそれぞれ、自身のリソース グループで孤立しています。 ワークロード所有者またはそのチーム メンバーが、他のリソース グループのリソースに管理アクセスすることはできません。 

![リソース グループ A とリソース グループ B が含まれるサブスクリプション](../_images/governance-2-10.png)
*図 4. それぞれのリソース グループで孤立している 2 人のワークロード所有者が含まれるサブスクリプション。*

これは最小限の特権モデルです。このモデルでは、各ユーザーに、適切なアクセス許可が適切なリソース管理スコープで割り当てられています。

ただし、この例では、すべてのタスクが**サービス管理者**によって実行されたことに注意してください。 この例ではワークロード所有者が 2 人しかいなかったため、シンプルで、問題がないように見えますが、大規模な組織では問題が発生するのは想像に難くありません。 たとえば、要求のバックログが大きくなれば、**サービス管理者**がボトルネックとなる可能性があり、これが遅延につながります。  

次の 2 番目の例では、**サービス管理者**によって実行されるタスク数が減っています。 

1. このモデルでは、サブスクリプション スコープで**ワークロード所有者 A** に[組み込み所有者ロール][rbac-built-in-owner]が割り当てられており、そのワークロード所有者 A は、自身のリソース グループとして**リソース グループ A** を作成できます。![サービス管理者がワークロード所有者 A をサブスクリプションに追加する](../_images/governance-2-11.png)

2. **リソース グループ A** が作成されるとき、**ワークロード所有者 A** が既定で追加され、この所有者は、[組み込み所有者][rbac-built-in-owner]ロールをサブスクリプション スコープから継承します。
![ワークロード所有者 A がリソース グループ A を作成する](../_images/governance-2-12.png)

3. [組み込み所有者ロール][rbac-built-in-owner]により、**ワークロード所有者 A** に、リソース グループへのアクセスを管理するアクセス許可が付与されます。 **ワークロード所有者 A** が 2 人の**ワークロード共同作成者**を追加し、それぞれに[組み込み閲覧者ロール][rbac-built-in-owner]を割り当てます。 
![ワークロード所有者 A がワークロード共同作成者を追加する](../_images/governance-2-13.png)

4. ここで、**サービス管理者**が、**ワークロード所有者 B** を、組み込み所有者ロールが含まれるサブスクリプションに追加します。 
![サービス管理者がワークロード所有者 B をサブスクリプションに追加する](../_images/governance-2-14.png)

5. **ワークロード所有者 B** が**リソース グループ B** を作成します。ワークロード所有者 B は既定で追加されています。 前と同様、**ワークロード所有者 B** は、組み込み所有者ロールをサブスクリプション スコープから継承します。
![ワークロード所有者 B がリソース グループ B を作成する](../_images/governance-2-15.png)

このモデルでは、**サービス管理者**が実行するアクションが、最初の例よりも少なくなっていることに注意してください。これはそれぞれのワークロード所有者に管理アクセスが委任されているためです。

![リソース グループ A とリソース グループ B が含まれるサブスクリプション](../_images/governance-2-16.png)
*図 5. 組み込み所有者ロールが割り当てられた、サービス管理者と 2 人のワークロード所有者が含まれるサブスクリプション。*

ただし、サブスクリプション スコープで**ワークロード所有者 A** と**ワークロード所有者 B** の両方に組み込み所有者ロールが割り当てられているため、それぞれが、お互いのリソース グループの組み込み所有者ロールを継承しています。 つまり、両方の所有者は、お互いのリソースにフル アクセスできるだけでなく、管理アクセスを、お互いのリソース グループに委任することもできます。 たとえば、**ワークロード所有者 B** が他のユーザーを**リソース グループ A** に追加し、組み込み所有者ロールなど、任意のロールを割り当てることができます。

それぞれの例を要件と比較すると、この 2 つの例では、2 人のワークロード所有者にリソース アクセス権を付与するアクセス許可を持つ 1 人の信頼されたユーザーがサブスクリプション スコープでサポートされていることがわかります。 2 人のワークロード所有者は、既定では、リソース管理にアクセスできなかったため、**サービス管理者**に、アクセス許可を明示的に割り当ててもらう必要がありました。 ただし、最初の例のみが、ワークロード所有者が他のワークロードのリソースにアクセスできないように、各ワークロードに関連付けられているリソースがお互いに独立していなければならない、という要件に対応しています。

## <a name="resource-management-model"></a>リソース管理モデル

これで、最小限の特権のアクセス許可モデルの設計が完了しました。次は、これらのガバナンス モデルの実際の適用例をいくつか見ていきましょう。 次の 3 つの環境をサポートする必要がある、という要件を思い出してください。
1. **共有インフラストラクチャ:** すべてのワークロードで共有されるリソースの 1 つのグループ。 ネットワーク ゲートウェイ、ファイアウォール、セキュリティ サービスなどのリソースです。  
2. **開発:** 複数の非運用対応ワークロードを表す複数のリソース グループ。 これらのリソースは、概念実証、テスト、およびその他の開発者アクティビティ用に使用されます。 これらのリソースのガバナンス モデルは、開発者の俊敏性の向上に対応するために、それほど厳しくない可能性があります。
3. **運用:** 複数の運用ワークロードを表す複数のリソース グループ。 これらのリソースは、プライベートとパブリックのアプリケーション成果物のホストに使用されます。 これらのリソースでは、リソース、アプリケーション コード、およびデータを不正アクセスから保護するために、通常、最も厳しいガバナンスおよびセキュリティ モデルが採用されています。

この 3 つの環境ごとに、**ワークロード所有者**、**環境**、またはその両方について、コスト データを追跡する必要があります。 つまり、**共有インフラストラクチャ**の継続的なコスト、**開発**環境と**運用**環境の両方の個人によって発生するコスト、および**開発**と**運用**の全体的なコストを把握する必要があります。 

リソースのスコープには、**サブスクリプション**と**リソース グループ**の 2 つのレベルがあることは既に説明しました。 したがって、最初は、**サブスクリプション**によって環境を整理する方法を決めます。 可能性は 2 つしかありません。1 つのサブスクリプション、そして複数のサブスクリプションです。 

それぞれのモデルの例を見る前に、Azure 内のサブスクリプションの管理構造を確認しましょう。 

サブスクリプションを担当する個人が組織にいる、という要件を思い出してください。このユーザーは、Azure AD テナント内で**サブスクリプション所有者**アカウントを所有しています。 ただし、このアカウントには、サブスクリプションを作成するためのアクセス許可がありません。 これを行うアクセス許可を持っているのは **Azure アカウント所有者**だけです。![](../_images/governance-3-0b.png)
*図 6. Azure アカウント所有者がサブスクリプションを作成する。*

サブスクリプションが作成されたら、**Azure アカウント所有者**は、**サブスクリプション所有者**アカウントを、**所有者**ロールと共にサブスクリプションに追加できます。

![](../_images/governance-3-0c.png)
*図 7. Azure アカウント所有者は、**サブスクリプション所有者**ユーザー アカウントを**所有者**ロールと共にサブスクリプションに追加する。*

これで、**サブスクリプション所有者**は、**リソース グループ**を作成して、リソース アクセス管理を委任できます。

まず、1 つのサブスクリプションを使用したリソース管理モデルの例を見てみましょう。 最初に、リソース グループを 3 つの環境と連携させる方法を決めます。 2 つのオプションがあります。
1. 各環境を 1 つのリソース グループと連携させる。 共有インフラストラクチャ リソースはすべて、1 つの**共有インフラストラクチャ** リソース グループにデプロイされます。 開発ワークロードに関連付けられているリソースはすべて、1 つの**開発**リソース グループにデプロイされます。 運用ワークロードに関連付けられているリソースについては、**運用**環境の 1 つの**運用**リソース グループにすべてデプロイされます。 
2. ワークロードと個別のリソース グループを連携させ、名前付け規則とタグを使用して、リソース グループを 3 つの環境それぞれと連携させる。  

まずは、最初のオプションについて考えてみましょう。 ここでは、前のセクションで説明したアクセス許可モデルと、1 人のサブスクリプション サービス管理者を使用します。この管理者は、リソース グループを作成し、そのグループに、ユーザーを、組み込み**共同作成者**ロールまたは**閲覧者**ロールと共に追加します。 

1. デプロイされた最初のリソース グループは、**共有インフラストラクチャ**環境を表します。 **サブスクリプション所有者**は、**netops-shared-rg** という名前の共有インフラストラクチャ リソースのリソース グループを作成します。 
![](../_images/governance-3-0d.png)
2. **サブスクリプション所有者**は、**ネットワーク操作ユーザー** アカウントをそのリソース グループに追加し、**共同作成者**ロールを割り当てます。 
![](../_images/governance-3-0e.png)
3. **ネットワーク操作ユーザー**は、[VPN ゲートウェイ](/azure/vpn-gateway/vpn-gateway-about-vpngateways)を作成し、オンプレミス VPN アプライアンスに接続するように構成します。 また、**ネットワーク操作ユーザー**は、*environment:shared* および *managedBy:netOps* という[タグ](/azure/azure-resource-manager/resource-group-using-tags)のペアを各リソースに適用します。 **サブスクリプション サービス管理者**がコスト レポートをエクスポートすると、それぞれのタグに合わせてコストが調整されます。 これにより、**サブスクリプション サービス管理者**が、*environment* タグ *managedBy* タグを使ってコストをピボットできます。 図の右上にある**リソース制限**カウンターをご覧ください。 各 Azure サブスクリプションに[サービス制限](/azure/azure-subscription-service-limits)があります。これらの制限の影響について理解しやすいように、ここでは各サブスクリプションの仮想ネットワークの制限を追跡します。 サブスクリプションあたりの仮想ネットワークの既定の制限は 50 です。1 つ目の仮想ネットワークがデプロイされたため、現在 49 の仮想ネットワークが使用可能です。
![](../_images/governance-3-1.png)
4. さらに 2 つのリソース グループをデプロイします。1 つ目は *prod-rg* という名前です。 このリソース グループは**運用**環境と連携します。 2 つ目の名前は *dev-rg* で、**開発**環境と連携します。 運用ワークロードに関連付けられているリソースはすべて、**運用**環境にデプロイされ、開発ワークロードに関連付けられているリソースはすべて、**開発**環境にデプロイされます。 この例では、この 2 つの環境それぞれにデプロイするワークロードは 2 つだけなので、Azure サブスクリプション サービスの制限に達することはありません。 しかし、リソース数の上限がリソース グループあたり 800 であることを考慮することが重要です。 各リソース グループにワークロードを追加し続けると、この制限に達する可能性があります。 
![](../_images/governance-3-2.png)
5. 最初の**ワークロード所有者**が要求を**サブスクリプション サービス管理者**に送信します。その所有者は、**共同作成者**ロールと共に、**開発**環境と**運用**環境それぞれのリソース グループに追加されます。 前に説明したように、**共同作成者**ロールにより、ユーザーは、別のユーザーへのロールの割り当て以外のすべての操作を実行できます。 最初の**ワークロード所有者**は、自身のワークロードに関連付けられているリソースを作成できます。
![](../_images/governance-3-3.png)
6. 最初の**ワークロード所有者**は、2 つのリソース グループそれぞれに仮想ネットワークを作成します。各仮想ネットワークには 2 つの仮想マシンがあります。 最初の**ワークロード所有者**は、*environment* タグと *managedBy* タグをすべてのリソースに適用します。 Azure サービスの制限カウンターが示す現在の残りの仮想ネットワーク数が 47 であることに注意してください。
![](../_images/governance-3-4.png)
7. 仮想ネットワークが作成されたとき、どちらにもオンプレミスへの接続性はありません。 この種類のアーキテクチャでは、各仮想ネットワークが、**共有インフラストラクチャ**環境の *hub-vnet* にピアリングされていなければなりません。 仮想ネットワークのピアリングにより、2 つの個別の仮想ネットワーク間に接続が作成され、その間をネットワーク トラフィックが行き来できるようになります。 仮想ネットワークのピアリングは、本質的には推移的でないことに注意してください。 ピアリングは、接続されている 2 つの各仮想ネットワークで指定する必要があります。いずれか 1 つの仮想ネットワークでしかピアリングが指定されていない場合、接続は不完全です。 この影響を示すために、最初の**ワークロード所有者**は、**prod-vnet** と **hub-vnet** の間のピアリングを指定します。 この場合、最初のピアリングは作成されますが、トラフィックは行き来しません。**hub-vnet** から **prod-vnet** への補完的なピアリングがまだ指定されていないためです。 最初の**ワークロード所有者**は、**ネットワーク操作**ユーザーに、この補完的なピアリング接続を要求します。
![](../_images/governance-3-5.png)
8. **ネットワーク操作**ユーザーは要求を確認し、承認したうえで、**hub-vnet** の設定でピアリングを指定します。 これでピアリングの接続は完了です。2 つの仮想ネットワーク間を、ネットワーク トラフィックが行き来するようになります。
![](../_images/governance-3-6.png)
9. ここで、もう 1 人の**ワークロード所有者**が要求を**サブスクリプション サービス管理者**に送信します。その所有者は、**共同作成者**ロールと共に、既存の**運用**環境と**開発**環境それぞれのリソース グループに追加されます。 その 2 番目の**ワークロード所有者**には、各リソース グループで、最初の**ワークロード所有者**と同じアクセス許可がすべてのリソースについて付与されます。 
![](../_images/governance-3-7.png)
10. 2 番目の**ワークロード所有者**は、**prod vnet** 仮想ネットワークにサブネットを作成し、2 つの仮想マシンを追加します。 2 番目の**ワークロード所有者**は、*environment* タグと *managedBy* タグを各リソースに適用します。
![](../_images/governance-3-8.png) 

このリソース管理モデルの例では、3 つの必要な環境でリソースを管理できます。 共有インフラストラクチャ リソースが保護されているのは、それらのリソースへのアクセス許可を持つユーザーが、サブスクリプションに 1 人しかいないためです。 共有インフラストラクチャ リソースは、その実際の共有リソース自体に対するアクセス許可がなくても、各ワークロード所有者が利用できます。 この管理モデルは、ワークロード分離の要件を満たしておらず、2 人の**ワークロード所有者**それぞれが、もう一方のワークロードのリソースにアクセスできます。 

また、一見するとわかりにくいかもしれませんが、このモデルには重要な考慮事項がもう 1 つあります。 この例では、オンプレミスとの接続性を提供するために **hub-vnet** とのネットワーク ピアリング接続を要求したのは、**app1 ワークロード所有者**でした。 **ネットワーク操作**ユーザーは、そのワークロードでデプロイされたリソースに基づいてその要求を評価しました。 **サブスクリプション所有者**が **app2 ワークロード所有者**を、**共同作成者**ロールと共に追加したとき、そのユーザーには、**prod-rg** リソース グループのすべてのリソースに対する管理アクセス権がありました。 

![](../_images/governance-3-10.png)

つまり、**app2 ワークロード所有者**には、**prod-vnet** 仮想ネットワーク内に、自身のサブネットと仮想マシンをデプロイするアクセス許可がありました。 既定では、これで、それらの仮想マシンはオンプレミス ネットワークにアクセスできます。 **ネットワーク操作**ユーザーは、これらのマシンを認識せず、そのマシンがオンプレミスに接続するのを承認しませんでした。

次に、さまざまな環境やワークロードに対するリソース グループが複数含まれる 1 つのサブスクリプションを見てみましょう。 前の例では、リソースは環境ごとに分かれ、同じ環境のリソースは同じリソース グループにあったため、各環境のリソースを簡単に特定できました。 そのグループ分けがなくなり、今後は、リソースを特定するために、リソース グループの名前付け規則を使用する必要があります。 

1. **共有インフラストラクチャ** リソースでは引き続きこのモデル内で個別のリソース グループが使用されるため、変更されません。 ワークロードごとに 2 つのリソース グループが必要です。1 つは**開発**環境、もう 1 つは**運用**環境に対して使用されます。 最初のワークロードに対して、**サブスクリプション所有者**は 2 つのリソース グループを作成します。 1 つは **app1-prod-rg**、もう 1 つは **app1-dev-rg** という名前です。 前に説明したように、この名前付け規則により、リソースが、最初のワークロード **app1** と、**dev** 環境または **prod** 環境のいずれかに関連付けられていることが特定されます。 ここでも、"*サブスクリプション*" 所有者は、**app1 ワークロード所有者**を、**共同作成者**ロールと共にリソース グループに追加します。
![](../_images/governance-3-12.png)
2. 最初の例と同様、**app1 ワークロード所有者**が、**app1-prod-vnet** という名前の仮想ネットワークを**運用**環境に、もう 1 つの **app1-dev-vnet** という名前の仮想ネットワークを**開発**環境に追加します。 ここでも、**app1 ワークロード所有者**が、ピアリング接続の作成要求を**ネットワーク操作**ユーザーに送信します。 **app1 ワークロード所有者**が、最初の例と同じタグを追加していることに注意してください。制限カウンターは、サブスクリプションに残っている仮想ネットワークの数を示す 47 に減少しています。
![](../_images/governance-3-13.png)
3. ここで、**サブスクリプション所有者**は、**app2 ワークロード所有者**に対して 2 つのリソース グループを作成します。 **app1 ワークロード所有者**と同じ規則に従って、リソース グループの名前は **app2-prod-rg** と **app2-dev-rg** となります。 **サブスクリプション所有者**は、**app2 ワークロード所有者**を、**共同作成者**ロールと共に各リソース グループに追加します。
![](../_images/governance-3-14.png)
4. "*app2 ワークロード所有者*" が、仮想ネットワークと仮想マシンを、同じ名前付け規則を持つリソース グループにデプロイします。 タグが追加され、制限カウンターは、"*サブスクリプション*" に残っている仮想ネットワークの数を示す 45 に減少しています。
![](../_images/governance-3-15.png)
5. "*app2 ワークロード所有者*" が、"*ネットワーク操作*" ユーザーに対して、*app2-prod-vnet* を *hub-vnet* にピアリングするよう要求します。 "*ネットワーク操作*" ユーザーは、ピアリング接続を作成します。
![](../_images/governance-3-16.png)

結果の管理モデルは最初の例と似ていますが、主に次のような違いがあります。
* 2 つのワークロードはそれぞれ、ワークロードおよび環境によって分離されています。
* このモデルには、最初の例のモデルよりも仮想ネットワークが 2 つ多く必要です。 ワークロードが 2 つだけなので、この違いは重要ではありませんが、このモデルのワークロード数の制限は理論的には 24 個です。 
* それぞれの環境に対応する 1 つのリソース グループに、リソースがグループ化されなくなりました。 リソースをグループ化するには、各環境に使用される名前付け規則を理解する必要があります。 
* ピアリングされた各仮想ネットワーク接続が、"*ネットワーク操作*" ユーザーによって確認および承認されました。

ここで、複数のサブスクリプションを使用したリソース管理モデルを見てみましょう。 このモデルでは、3 つの各環境を、**共有サービス** サブスクリプション、**運用**サブスクリプション、**開発**サブスクリプションの 3 つの個別のサブスクリプションと連携させます。 このモデルに関する考慮事項は、リソース グループとワークロードを連携させる方法を決める必要がある点では、1 つのサブスクリプションを使用するモデルと似ています。 ワークロードごとにリソース グループを作成すると、ワークロードの分離要件に対応できることは既に確認しました。したがって、この例では、そのモデルをそのまま使用します。

1. このモデルには、"*共有インフラストラクチャ*"、"*運用*"、および "*開発*" の 3 つの "*サブスクリプション*" があります。 この 3 つのサブスクリプションそれぞれに、"*サブスクリプション所有者*" が必要で、このシンプルな例では、3 つすべてに同じユーザー アカウントを使用します。 "*共有インフラストラクチャ*" リソースは、上記の最初の 2 つの例と同じように管理されており、最初のワークロードは、"*運用*" 環境の *app1-rg*と、"*開発*" 環境の同じ名前のリソース グループに関連付けられています。 "*app1 ワークロード所有者*" は、"*共同作成者*" ロールと共に各リソース グループに追加されます。 
![](../_images/governance-3-17.png)
2. 前の例と同様に、"*app1 ワークロード所有者*" がリソースを作成し、"*共有インフラストラクチャ*" 仮想ネットワークとのピアリング接続を要求します。 "*app1 ワークロード所有者*" は *managedBy* タグのみを追加します。*environment* タグは必要なくなったためです。 つまり、各環境のリソースが同じ "*サブスクリプション*" にグループ化されるようになり、*environment* タグは不要です。 制限カウンターは、残り 49 仮想ネットワークに減少します。
![](../_images/governance-3-18.png)
3. 最後に、"*サブスクリプション所有者*" は 2 つ目のワークロードに対して処理を繰り返して、共同作成者ロールで "*app2 ワークロード所有者*" を含むリソース グループを追加します。 各環境サブスクリプションの制限カウンターは、残り 48 仮想ネットワークに減少します。 

この管理モデルには、上記の 2 番目の例で示した利点があります。 主な違いは、制限が 2 つの "*サブスクリプション*" に分散されるため、あまり問題にはならないという点です。 欠点は、タグによって追跡されるコスト データを、3 つのすべての "*サブスクリプション*" にわたって集計する必要があることです。 

したがって、ご自身の要件の優先度に応じて、2 つのサンプル リソース管理モデルのいずれかを選択できます。 皆様の組織で 1 つのサブスクリプションのサービス制限に到達しないと思われる場合は、複数のリソース グループを含む 1 つのサブスクリプションを使用できます。 逆に、組織のワークロードが多くなりそうなときは、環境ごとに複数のサブスクリプションを使用することをお勧めします。

<!-- ## Summary



## Next steps -->


<!-- links -->

[rbac-built-in-owner]: /azure/role-based-access-control/built-in-roles#owner
[rbac-built-in-roles]: /azure/role-based-access-control/built-in-roles
