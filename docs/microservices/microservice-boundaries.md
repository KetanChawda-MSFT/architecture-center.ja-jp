---
title: "マイクロサービス境界の識別"
description: "マイクロサービス境界の識別"
author: MikeWasson
ms.date: 12/08/2017
ms.openlocfilehash: e4f11da9f970724c55ad99824f808a10c4558971
ms.sourcegitcommit: 744ad1381e01bbda6a1a7eff4b25e1a337385553
ms.translationtype: HT
ms.contentlocale: ja-JP
ms.lasthandoff: 01/08/2018
---
# <a name="designing-microservices-identifying-microservice-boundaries"></a><span data-ttu-id="d36de-103">マイクロサービスの設計: マイクロサービス境界の識別</span><span class="sxs-lookup"><span data-stu-id="d36de-103">Designing microservices: Identifying microservice boundaries</span></span>

<span data-ttu-id="d36de-104">マイクロサービスの適切なサイズとは何でしょうか。</span><span class="sxs-lookup"><span data-stu-id="d36de-104">What is the right size for a microservice?</span></span> <span data-ttu-id="d36de-105">"大きすぎず小さすぎず" といったことをよく耳にします。確かにそのとおりですが、実際にはほとんど役に立ちません。</span><span class="sxs-lookup"><span data-stu-id="d36de-105">You often hear something to the effect of, "not too big and not too small" &mdash; and while that's certainly correct, it's not very helpful in practice.</span></span> <span data-ttu-id="d36de-106">しかし、慎重に設計されたドメイン モデルから始めると、マイクロサービスについてずっと簡単に類推できます。</span><span class="sxs-lookup"><span data-stu-id="d36de-106">But if you start from a carefully designed domain model, it's much easier to reason about microservices.</span></span>

![](./images/bounded-contexts.png)

## <a name="from-domain-model-to-microservices"></a><span data-ttu-id="d36de-107">ドメイン モデルからマイクロサービスに</span><span class="sxs-lookup"><span data-stu-id="d36de-107">From domain model to microservices</span></span>

<span data-ttu-id="d36de-108">[前の章](./domain-analysis.md)では、ドローン配送アプリケーションの境界付けられたコンテキストのセットを定義しました。</span><span class="sxs-lookup"><span data-stu-id="d36de-108">In the [previous chapter](./domain-analysis.md), we defined a set of bounded contexts for the Drone Delivery application.</span></span> <span data-ttu-id="d36de-109">それから、これらの境界付けられたコンテキストの 1 つである "出荷" 境界付けられたコンテキストを詳しく調べて、その境界付けられたコンテキストのエンティティ、集計、ドメイン サービスのセットを明らかにしました。</span><span class="sxs-lookup"><span data-stu-id="d36de-109">Then we looked more closely at one of these bounded contexts, the Shipping bounded context, and identified a set of entities, aggregates, and domain services for that bounded context.</span></span>

<span data-ttu-id="d36de-110">その結果、ドメイン モデルからアプリケーション設計に移行する準備ができています。</span><span class="sxs-lookup"><span data-stu-id="d36de-110">Now we're ready to go from domain model to application design.</span></span> <span data-ttu-id="d36de-111">ドメイン モデルからマイクロサービスを導き出すために使うことができるアプローチを次に示します。</span><span class="sxs-lookup"><span data-stu-id="d36de-111">Here's an approach that you can use to derive microservices from the domain model.</span></span>

1. <span data-ttu-id="d36de-112">境界付けられたコンテキストから始めます。</span><span class="sxs-lookup"><span data-stu-id="d36de-112">Start with a bounded context.</span></span> <span data-ttu-id="d36de-113">一般に、マイクロサービスの機能は、複数の境界付けられたコンテキストにまたがっていてはなりません。</span><span class="sxs-lookup"><span data-stu-id="d36de-113">In general, the functionality in a microservice should not span more than one bounded context.</span></span> <span data-ttu-id="d36de-114">定義上、境界付けられたコンテキストは特定のドメイン モデルの境界をマークします。</span><span class="sxs-lookup"><span data-stu-id="d36de-114">By definition, a bounded context marks the boundary of a particular domain model.</span></span> <span data-ttu-id="d36de-115">1 つのマイクロサービスに複数の異なるドメイン モデルが含まれることがわかった場合は、前に戻ってドメイン分析を修正する必要があることを示しています。</span><span class="sxs-lookup"><span data-stu-id="d36de-115">If you find that a microservice mixes different domain models together, that's a sign that you may need to go back and refine your domain analysis.</span></span>

2. <span data-ttu-id="d36de-116">次に、ドメイン モデルの集計を確認します。</span><span class="sxs-lookup"><span data-stu-id="d36de-116">Next, look at the aggregates in your domain model.</span></span> <span data-ttu-id="d36de-117">集計はマイクロサービスの適切な候補になることがよくあります。</span><span class="sxs-lookup"><span data-stu-id="d36de-117">Aggregates are often good candidates for microservices.</span></span> <span data-ttu-id="d36de-118">適切に設計された集計は、次のような適切に設計されたマイクロサービスの特徴を多く備えています。</span><span class="sxs-lookup"><span data-stu-id="d36de-118">A well-designed aggregate exhibits many of the characteristics of a well-designed microservice, such as:</span></span>

    - <span data-ttu-id="d36de-119">集計は、データ アクセスやメッセージングなどの技術的な問題ではなく、ビジネス要件から派生します。</span><span class="sxs-lookup"><span data-stu-id="d36de-119">An aggregates is derived from business requirements, rather than technical concerns such as data access or messaging.</span></span>  
    - <span data-ttu-id="d36de-120">集計には、機能の高い凝集度が必要です。</span><span class="sxs-lookup"><span data-stu-id="d36de-120">An aggregate should have high functional cohesion.</span></span>
    - <span data-ttu-id="d36de-121">集計は永続性の境界です。</span><span class="sxs-lookup"><span data-stu-id="d36de-121">An aggregate is a boundary of persistence.</span></span>
    - <span data-ttu-id="d36de-122">集計同士は疎に結合されている必要があります。</span><span class="sxs-lookup"><span data-stu-id="d36de-122">Aggregates should be loosely coupled.</span></span> 
    
3. <span data-ttu-id="d36de-123">ドメイン サービスもマイクロサービスに適した候補です。</span><span class="sxs-lookup"><span data-stu-id="d36de-123">Domain services are also good candidates for microservices.</span></span> <span data-ttu-id="d36de-124">ドメイン サービスは、複数の集計に対するステートレスな操作です。</span><span class="sxs-lookup"><span data-stu-id="d36de-124">Domain services are stateless operations across multiple aggregates.</span></span> <span data-ttu-id="d36de-125">典型的な例は、複数のマイクロサービスを含むワークフローです。</span><span class="sxs-lookup"><span data-stu-id="d36de-125">A typical example is a workflow that involves several microservices.</span></span> <span data-ttu-id="d36de-126">ドローン配送アプリケーションで、その例を見ることができます。</span><span class="sxs-lookup"><span data-stu-id="d36de-126">We'll see an example of this in the Drone Delivery application.</span></span>

4. <span data-ttu-id="d36de-127">最後に、機能以外の要件を検討します。</span><span class="sxs-lookup"><span data-stu-id="d36de-127">Finally, consider non-functional requirements.</span></span> <span data-ttu-id="d36de-128">チームの規模、データの型、テクノロジ、スケーラビリティの要件、可用性の要件、セキュリティの要件などの要因を確認します。</span><span class="sxs-lookup"><span data-stu-id="d36de-128">Look at factors such as team size, data types, technologies, scalability requirements, availability requirements, and security requirements.</span></span> <span data-ttu-id="d36de-129">これらの要因により、1 つのマイクロサービスを複数の小さいサービスにさらに分割したり、その逆に、複数のマイクロサービスを 1 つに結合したりすることになる場合があります。</span><span class="sxs-lookup"><span data-stu-id="d36de-129">These factors may lead you to further decompose a microservice into two or more smaller services, or do the opposite and combine several microservices into one.</span></span> 

<span data-ttu-id="d36de-130">アプリケーション内のマイクロサービスを識別した後は、次の基準に照らし合わせて設計を検証します。</span><span class="sxs-lookup"><span data-stu-id="d36de-130">After you identify the microservices in your application, validate your design against the following criteria:</span></span>

- <span data-ttu-id="d36de-131">各サービスが 1 つの役割を持っていること。</span><span class="sxs-lookup"><span data-stu-id="d36de-131">Each service has a single responsibility.</span></span>
- <span data-ttu-id="d36de-132">サービス間で頻繁な呼び出しが行われないこと。</span><span class="sxs-lookup"><span data-stu-id="d36de-132">There are no chatty calls between services.</span></span> <span data-ttu-id="d36de-133">機能を 2 つのサービスに分割したことによってそれらの間で過度に頻繁に呼び出しが行われる場合、それらの関数が同じサービスに属すことを示している可能性があります。</span><span class="sxs-lookup"><span data-stu-id="d36de-133">If splitting functionality into two services causes them to be overly chatty, it may be a symptom that these functions belong in the same service.</span></span>
- <span data-ttu-id="d36de-134">各サービスが、独立して作業する小規模なチームで構築できるくらいに十分小さいこと。</span><span class="sxs-lookup"><span data-stu-id="d36de-134">Each service is small enough that it can be built by a small team working independently.</span></span>
- <span data-ttu-id="d36de-135">複数のサービスをロックステップでデプロイすることが必要になる相互依存関係がないこと。</span><span class="sxs-lookup"><span data-stu-id="d36de-135">There are no inter-dependencies that will require two or more services to be deployed in lock-step.</span></span> <span data-ttu-id="d36de-136">常に、他のサービスを再デプロイすることなくサービスをデプロイできる必要があります。</span><span class="sxs-lookup"><span data-stu-id="d36de-136">It should always be possible to deploy a service without redeploying any other services.</span></span>
- <span data-ttu-id="d36de-137">サービスが密結合されておらず、個別に展開できること。</span><span class="sxs-lookup"><span data-stu-id="d36de-137">Services are not tightly coupled, and can evolve independently.</span></span>
- <span data-ttu-id="d36de-138">そうすれば、サービスの境界でデータの一貫性や整合性の問題が発生することはありません。</span><span class="sxs-lookup"><span data-stu-id="d36de-138">Your service boundaries will not create problems with data consistency or integrity.</span></span> <span data-ttu-id="d36de-139">場合によっては、単一のマイクロサービスに機能を収めることによってデータの整合性を維持することが重要になります。</span><span class="sxs-lookup"><span data-stu-id="d36de-139">Sometimes it's important to maintain data consistency by putting functionality into a single microservice.</span></span> <span data-ttu-id="d36de-140">ただし、強力な一貫性が本当に必要かどうかを検討する必要があります。</span><span class="sxs-lookup"><span data-stu-id="d36de-140">That said, consider whether you really need strong consistency.</span></span> <span data-ttu-id="d36de-141">分散システムで最終的な整合性に対処するための戦略があり、多くの場合、サービスを分割するメリットの方が、最終的な整合性を管理する難しさより勝ります。</span><span class="sxs-lookup"><span data-stu-id="d36de-141">There are strategies for addressing eventual consistency in a distributed system, and the benefits of decomposing services often outweigh the challenges of managing eventual consistency.</span></span>

<span data-ttu-id="d36de-142">何よりもまず、実際的であること、そしてドメインベースの設計は反復プロセスであることを忘れないようにすることが重要です。</span><span class="sxs-lookup"><span data-stu-id="d36de-142">Above all, it's important to be pragmatic, and remember that domain-driven design is an iterative process.</span></span> <span data-ttu-id="d36de-143">判断に迷うときは、より粒度の粗いマイクロサービスで始めるようにします。</span><span class="sxs-lookup"><span data-stu-id="d36de-143">When in doubt, start with more coarse-grained microservices.</span></span> <span data-ttu-id="d36de-144">1 つのマイクロサービスを 2 つの小さいサービスに分割する方が、既存の複数のマイクロサービスの機能をリファクタリングするより簡単です。</span><span class="sxs-lookup"><span data-stu-id="d36de-144">Splitting a microservice into two smaller services is easier than refactoring functionality across several existing microservices.</span></span>
  
## <a name="drone-delivery-defining-the-microservices"></a><span data-ttu-id="d36de-145">ドローン配送: マイクロサービスの定義</span><span class="sxs-lookup"><span data-stu-id="d36de-145">Drone Delivery: Defining the microservices</span></span>

<span data-ttu-id="d36de-146">開発チームは 4 つの集計 (配送、パッケージ、ドローン、アカウント) と 2 つのドメイン サービス (スケジューラとスーパーバイザー) を識別したことを思い出してください。</span><span class="sxs-lookup"><span data-stu-id="d36de-146">Recall that the development team had identified the four aggregates &mdash; Delivery, Package, Drone, and Account &mdash; and two domain services, Scheduler and Supervisor.</span></span> 

<span data-ttu-id="d36de-147">配送とパッケージは、マイクロサービスの明らかな候補です。</span><span class="sxs-lookup"><span data-stu-id="d36de-147">Delivery and Package are obvious candidates for microservices.</span></span> <span data-ttu-id="d36de-148">スケジューラとスーパーバイザーは、他のマイクロサービスによって実行されるアクティビティを調整するので、これらのドメイン サービスをマイクロサービスとして実装するのは当然のことです。</span><span class="sxs-lookup"><span data-stu-id="d36de-148">The Scheduler and Supervisor coordinate the activities performed by other microservices, so it makes sense to implement these domain services as microservices.</span></span>  

<span data-ttu-id="d36de-149">ドローンとアカウントが興味深いのは、他の境界付けられたコンテキストに属していることです。</span><span class="sxs-lookup"><span data-stu-id="d36de-149">Drone and Account are interesting because they belong to other bounded contexts.</span></span> <span data-ttu-id="d36de-150">1 つのオプションは、スケジューラでドローンとアカウントの境界付けられたコンテキストを直接呼び出すというものです。</span><span class="sxs-lookup"><span data-stu-id="d36de-150">One option is for the Scheduler to call the Drone and Account bounded contexts directly.</span></span> <span data-ttu-id="d36de-151">もう 1 つのオプションは、発送の境界付けられたコンテキストの内部にドローンとアカウントのマイクロサービスを作成することです。</span><span class="sxs-lookup"><span data-stu-id="d36de-151">Another option is to create Drone and Account microservices inside the Shipping bounded context.</span></span> <span data-ttu-id="d36de-152">これらマイクロサービスは、発送コンテキストにより適した API またはデータ スキーマを公開することにより、境界付けられたコンテキストの間を仲介します。</span><span class="sxs-lookup"><span data-stu-id="d36de-152">These microservices would mediate between the bounded contexts, by exposing APIs or data schemas that are more suited to the Shipping context.</span></span>

<span data-ttu-id="d36de-153">ドローンとアカウントの境界付けられたコンテキストの詳細はこのガイドの範囲外なので、参照実装ではこれらのモック サービスを作成しました。</span><span class="sxs-lookup"><span data-stu-id="d36de-153">The details of the Drone and Account bounded contexts are beyond the scope of this guidance, so we created mock services for them in our reference implementation.</span></span> <span data-ttu-id="d36de-154">ただし、この状況では次のような要因を考慮する必要があります。</span><span class="sxs-lookup"><span data-stu-id="d36de-154">But here are some factors to consider in this situation:</span></span>

- <span data-ttu-id="d36de-155">他の境界付けられたコンテキストを直接呼び出すとどのようなネットワーク オーバーヘッドがあるか。</span><span class="sxs-lookup"><span data-stu-id="d36de-155">What is the network overhead of calling directly into the other bounded context?</span></span> 

- <span data-ttu-id="d36de-156">他の境界付けられたコンテキストのデータ スキーマがこのコンテキストに適しているか、またはこの境界付けられたコンテキストに合わせて調整されたスキーマを作成する方がよいか。</span><span class="sxs-lookup"><span data-stu-id="d36de-156">Is the data schema for the other bounded context suitable for this context, or is it better to have a schema that's tailored to this bounded context?</span></span> 

- <span data-ttu-id="d36de-157">他の境界付けられたコンテキストはレガシ システムか。</span><span class="sxs-lookup"><span data-stu-id="d36de-157">Is the other bounded context a legacy system?</span></span> <span data-ttu-id="d36de-158">そうである場合は、[破損対策レイヤー](../patterns/anti-corruption-layer.md)として機能するサービスを作成し、レガシ システムと最新のアプリケーションの間の変換を行うことが考えられます。</span><span class="sxs-lookup"><span data-stu-id="d36de-158">If so, you might create a service that acts as an [anti-corruption layer](../patterns/anti-corruption-layer.md) to translate between the legacy system and the modern application.</span></span> 

- <span data-ttu-id="d36de-159">チームはどのような構造か。</span><span class="sxs-lookup"><span data-stu-id="d36de-159">What is the team structure?</span></span> <span data-ttu-id="d36de-160">他の境界付けられたコンテキストを担当するチームと簡単に通信できるか。</span><span class="sxs-lookup"><span data-stu-id="d36de-160">Is it easy to communicate with the team that's responsible for the other bounded context?</span></span> <span data-ttu-id="d36de-161">そうでない場合は、2 つのコンテキストの間を仲介するサービスを作成すると、チーム間の通信コストの削減に役立つ場合があります。</span><span class="sxs-lookup"><span data-stu-id="d36de-161">If not, creating a service that mediates between the two contexts can help to mitigate the cost of cross-team communication.</span></span>

<span data-ttu-id="d36de-162">これまで、機能以外の要件については考慮してきませんでした。</span><span class="sxs-lookup"><span data-stu-id="d36de-162">So far, we haven't considered any non-functional requirements.</span></span> <span data-ttu-id="d36de-163">アプリケーションのスループット要件を考慮し、開発チームはクライアント要求のインジェストを行うインジェスト マイクロサービスを別に作成することを決定しました。</span><span class="sxs-lookup"><span data-stu-id="d36de-163">Thinking about the application's throughput requirements, the development team decided to create a separate Ingestion microservice that is responsible for ingesting client requests.</span></span> <span data-ttu-id="d36de-164">このマイクロサービスは、着信した要求を処理のためのバッファーに入れることで、[負荷平準化](../patterns/queue-based-load-leveling.md)を実装します。</span><span class="sxs-lookup"><span data-stu-id="d36de-164">This microservice will implement [load leveling](../patterns/queue-based-load-leveling.md) by putting incoming requests into a buffer for processing.</span></span> <span data-ttu-id="d36de-165">スケジューラは、バッファーから要求を読み取って、ワークフローを実行します。</span><span class="sxs-lookup"><span data-stu-id="d36de-165">The Scheduler will read the requests from the buffer and execute the workflow.</span></span> 

<span data-ttu-id="d36de-166">機能以外の要件により、チームは 1 つの追加サービスを作成することにしました。</span><span class="sxs-lookup"><span data-stu-id="d36de-166">Non-functional requirements led the team to create one additional service.</span></span> <span data-ttu-id="d36de-167">これまでのサービスはすべて、パッケージのスケジューリングと配送をリアルタイムで行うプロセスに関するものでした。</span><span class="sxs-lookup"><span data-stu-id="d36de-167">All of the services so far have been about the process of scheduling and delivering packages in real time.</span></span> <span data-ttu-id="d36de-168">しかし、システムでは、データ分析のための長期的な記憶域にすべての配送の履歴を格納する必要もあります。</span><span class="sxs-lookup"><span data-stu-id="d36de-168">But the system also needs to store the history of every delivery in long-term storage for data analysis.</span></span> <span data-ttu-id="d36de-169">チームは、これを配送サービスで行うことを検討しました。</span><span class="sxs-lookup"><span data-stu-id="d36de-169">The team considered making this the responsibility of the Delivery service.</span></span> <span data-ttu-id="d36de-170">ただし、データ記憶域の要件は、履歴分析と処理中の操作ではまったく異なります (「[データに関する考慮事項](./data-considerations.md)」を参照)。</span><span class="sxs-lookup"><span data-stu-id="d36de-170">However, the data storage requirements are quite different for historical analysis versus in-flight operations (see [Data considerations](./data-considerations.md)).</span></span> <span data-ttu-id="d36de-171">そのため、チームは配送履歴サービスを別に作成することにしました。このサービスは、配送サービスからの DeliveryTracking イベントをリッスンし、長期的な記憶域にイベントを書き込みます。</span><span class="sxs-lookup"><span data-stu-id="d36de-171">Therefore, the team decided to create a separate Delivery History service, which will listen for DeliveryTracking events from the Delivery service and write the events into long-term storage.</span></span>

<span data-ttu-id="d36de-172">次の図は、この時点での設計を示したものです。</span><span class="sxs-lookup"><span data-stu-id="d36de-172">The following diagram shows the design at this point:</span></span>
 
![](./images/microservices.png)

## <a name="choosing-a-compute-option"></a><span data-ttu-id="d36de-173">コンピューティング オプションの選択</span><span class="sxs-lookup"><span data-stu-id="d36de-173">Choosing a compute option</span></span>

<span data-ttu-id="d36de-174">"*コンピューティング*" という用語は、アプリケーションがそこで実行されるコンピューティング リソースのホスティング モデルを指します。</span><span class="sxs-lookup"><span data-stu-id="d36de-174">The term *compute* refers to the hosting model for the computing resources that your application runs on.</span></span> <span data-ttu-id="d36de-175">マイクロサービス アーキテクチャでは、2 つのアプローチが特によく使われます。</span><span class="sxs-lookup"><span data-stu-id="d36de-175">For a microservices architecture, two approaches are especially popular:</span></span>

- <span data-ttu-id="d36de-176">専用のノード (VM) で実行されるサービスを管理するサービス オーケストレーター。</span><span class="sxs-lookup"><span data-stu-id="d36de-176">A service orchestrator that manages services running on dedicated nodes (VMs).</span></span>
- <span data-ttu-id="d36de-177">サービスとしての関数 (FaaS) を使うサーバーレス アーキテクチャ。</span><span class="sxs-lookup"><span data-stu-id="d36de-177">A serverless architecture using functions as a service (FaaS).</span></span> 

<span data-ttu-id="d36de-178">オプションはこれらだけではありませんが、どちらも実証済みのマイクロサービス構築方法です。</span><span class="sxs-lookup"><span data-stu-id="d36de-178">While these aren't the only options, they are both proven approaches to building microservices.</span></span> <span data-ttu-id="d36de-179">1 つのアプリケーションに両方のアプローチが含まれることもあります。</span><span class="sxs-lookup"><span data-stu-id="d36de-179">An application might include both approaches.</span></span>

### <a name="service-orchestrators"></a><span data-ttu-id="d36de-180">サービス オーケストレーター</span><span class="sxs-lookup"><span data-stu-id="d36de-180">Service orchestrators</span></span>

<span data-ttu-id="d36de-181">オーケストレーターは、一連のサービスのデプロイと管理に関連するタスクを処理します。</span><span class="sxs-lookup"><span data-stu-id="d36de-181">An orchestrator handles tasks related to deploying and managing a set of services.</span></span> <span data-ttu-id="d36de-182">ノードへのサービスの配置、サービスの正常性の監視、サービス インスタンス間へのネットワーク トラフィックの負荷分散、サービスの検出、サービスのインスタンスの数のスケーリング、構成の更新の適用などのタスクがあります。</span><span class="sxs-lookup"><span data-stu-id="d36de-182">These tasks include placing services on nodes, monitoring the health of services, restarting unhealthy services, load balancing network traffic across service instances, service discovery, scaling the number of instances of a service, and applying configuration updates.</span></span> <span data-ttu-id="d36de-183">よく使われるオーケストレーターとしては、Kubernetes、DC/OS、Docker Swarm、Service Fabric などがあります。</span><span class="sxs-lookup"><span data-stu-id="d36de-183">Popular orchestrators include Kubernetes, DC/OS, Docker Swarm, and Service Fabric.</span></span> 

- <span data-ttu-id="d36de-184">[Azure Container Service](/azure/container-service/) (ACS) は、運用環境に対応した Kubernetes、DC/OS、または Docker Swarm クラスターをデプロイできる Azure サービスです。</span><span class="sxs-lookup"><span data-stu-id="d36de-184">[Azure Container Service](/azure/container-service/) (ACS) is an Azure service that lets you deploy a production-ready Kubernetes, DC/OS, or Docker Swarm cluster.</span></span>

- <span data-ttu-id="d36de-185">[AKS (Azure Container Service)](/azure/aks/) は、管理された Kubernetes サービスです。</span><span class="sxs-lookup"><span data-stu-id="d36de-185">[AKS (Azure Container Service)](/azure/aks/) is a managed Kubernetes service.</span></span> <span data-ttu-id="d36de-186">AKS は、Kubernetes をプロビジョニングして Kubernetes API エンドポイントを公開しますが、Kubernetes 制御プレーンをホストして管理し、自動アップグレード、修正プログラムの自動適用、自動スケーリング、その他の管理タスクを実行します。</span><span class="sxs-lookup"><span data-stu-id="d36de-186">AKS provisions Kubernetes and exposes the Kubernetes API endpoints, but hosts and manages the Kubernetes control plane, performing automated upgrades, automated patching, autoscaling, and other management tasks.</span></span> <span data-ttu-id="d36de-187">AKS は、"サービスとしての Kubernetes API" と考えることができます。</span><span class="sxs-lookup"><span data-stu-id="d36de-187">You can think of AKS as being "Kubernetes APIs as a service."</span></span> <span data-ttu-id="d36de-188">この記事の執筆時点では、AKS はまだプレビュー段階です。</span><span class="sxs-lookup"><span data-stu-id="d36de-188">At the time of writing, AKS is still in preview.</span></span> <span data-ttu-id="d36de-189">ただし、AKS は Azure で Kubernetes を実行するための優先的な手段になるものと予想されます。</span><span class="sxs-lookup"><span data-stu-id="d36de-189">However, it's expected that AKS will become the preferred way to run Kubernetes in Azure.</span></span> 

- <span data-ttu-id="d36de-190">[Service Fabric](/azure/service-fabric/) は、マイクロサービスのパッケージ化、デプロイ、管理を行うための分散システム プラットフォームです。</span><span class="sxs-lookup"><span data-stu-id="d36de-190">[Service Fabric](/azure/service-fabric/) is a distributed systems platform for packaging, deploying, and managing microservices.</span></span> <span data-ttu-id="d36de-191">マイクロサービスは、コンテナー、バイナリ実行可能ファイル、または [Reliable Services](/azure/service-fabric/service-fabric-reliable-services-introduction) として Service Fabric にデプロイできます。</span><span class="sxs-lookup"><span data-stu-id="d36de-191">Microservices can be deployed to Service Fabric as containers, as binary executables, or as [Reliable Services](/azure/service-fabric/service-fabric-reliable-services-introduction).</span></span> <span data-ttu-id="d36de-192">Reliable Services プログラミング モデルを使うと、サービスは Service Fabric プログラミング API を直接使って、システムのクエリ、正常性のレポート、構成とコードの変更に関する通知の受信、他のサービスの検出を行うことができます。</span><span class="sxs-lookup"><span data-stu-id="d36de-192">Using the Reliable Services programming model, services can directly use Service Fabric programming APIs to query the system, report health, receive notifications about configuration and code changes, and discover other services.</span></span> <span data-ttu-id="d36de-193">Service Fabric に関する重要な違いは、Service Fabric では [Reliable Collection](/azure/service-fabric/service-fabric-reliable-services-reliable-collections) を使うステートフル サービスの構築が重視されていることです。</span><span class="sxs-lookup"><span data-stu-id="d36de-193">A key differentiation with Service Fabric is its strong focus on building stateful services using [Reliable Collections](/azure/service-fabric/service-fabric-reliable-services-reliable-collections).</span></span>

### <a name="containers"></a><span data-ttu-id="d36de-194">コンテナー</span><span class="sxs-lookup"><span data-stu-id="d36de-194">Containers</span></span>

<span data-ttu-id="d36de-195">コンテナーとマイクロサービスは同じものであるかのように言われることがあります。</span><span class="sxs-lookup"><span data-stu-id="d36de-195">Sometimes people talk about containers and microservices as if they were the same thing.</span></span> <span data-ttu-id="d36de-196">それは正しくありませんが (マイクロサービスを構築するためにコンテナーは必要ありません)、コンテナーの次のような利点はマイクロサービスに特に関連があります。</span><span class="sxs-lookup"><span data-stu-id="d36de-196">While that's not true &mdash; you don't need containers to build microservices &mdash; containers do have some benefits that are particularly relevant to microservices, such as:</span></span>

- <span data-ttu-id="d36de-197">**移植性**。</span><span class="sxs-lookup"><span data-stu-id="d36de-197">**Portability**.</span></span> <span data-ttu-id="d36de-198">コンテナー イメージは、ライブラリや他の依存関係をインストールする必要なしに実行するスタンドアロン パッケージです。</span><span class="sxs-lookup"><span data-stu-id="d36de-198">A container image is a standalone package that runs without needing to install libraries or other dependencies.</span></span> <span data-ttu-id="d36de-199">そのため簡単にデプロイできます。</span><span class="sxs-lookup"><span data-stu-id="d36de-199">That makes them easy to deploy.</span></span> <span data-ttu-id="d36de-200">コンテナーはすばやく開始および停止できるので、高い負荷の処理やノード障害からの復旧のために新しいインスタンスを開始できます。</span><span class="sxs-lookup"><span data-stu-id="d36de-200">Containers can be started and stopped quickly, so you can spin up new instances to handle more load or to recover from node failures.</span></span> 

- <span data-ttu-id="d36de-201">**密度**。</span><span class="sxs-lookup"><span data-stu-id="d36de-201">**Density**.</span></span> <span data-ttu-id="d36de-202">コンテナーは OS リソースを共有しているため、仮想マシンの実行と比較して軽量です。</span><span class="sxs-lookup"><span data-stu-id="d36de-202">Containers are lightweight compared with running a virtual machine, because they share OS resources.</span></span> <span data-ttu-id="d36de-203">そのため、複数のコンテナーを単一のノードに収めることができ、アプリケーションが多数の小さいサービスで構成される場合に特に便利です。</span><span class="sxs-lookup"><span data-stu-id="d36de-203">That makes it possible to pack multiple containers onto a single node, which is especially useful when the application consists of many small services.</span></span>

- <span data-ttu-id="d36de-204">**リソースの分離**。</span><span class="sxs-lookup"><span data-stu-id="d36de-204">**Resource isolation**.</span></span> <span data-ttu-id="d36de-205">コンテナーで利用できるメモリと CPU の量を制限することができ、ランナウェイ プロセスによってホストのリソースがすべて使われないようにするのに役立ちます。</span><span class="sxs-lookup"><span data-stu-id="d36de-205">You can limit the amount of memory and CPU that is available to a container, which can help to ensure that a runaway process doesn't exhaust the host resources.</span></span> <span data-ttu-id="d36de-206">詳しくは、「[バルクヘッド パターン](../patterns/bulkhead.md)」をご覧ください。</span><span class="sxs-lookup"><span data-stu-id="d36de-206">See the [Bulkhead Pattern](../patterns/bulkhead.md) for more information.</span></span>

### <a name="serverless-functions-as-a-service"></a><span data-ttu-id="d36de-207">サーバーレス (サービスとしての関数)</span><span class="sxs-lookup"><span data-stu-id="d36de-207">Serverless (Functions as a Service)</span></span>

<span data-ttu-id="d36de-208">サーバーレス アーキテクチャでは、ユーザーは仮想マシンまたは仮想ネットワーク インフラストラクチャを管理しません。</span><span class="sxs-lookup"><span data-stu-id="d36de-208">With a serverless architecture, you don't manage the VMs or the virtual network infrastructure.</span></span> <span data-ttu-id="d36de-209">代わりに、ユーザーがコードをデプロイすると、ホスティング サービスがそのコードを VM 上に配置して実行します。</span><span class="sxs-lookup"><span data-stu-id="d36de-209">Instead, you deploy code and the hosting service handles putting that code onto a VM and executing it.</span></span> <span data-ttu-id="d36de-210">このアプローチには、イベント ベースのトリガーを使って調整される小さく細分化された関数が適しています。</span><span class="sxs-lookup"><span data-stu-id="d36de-210">This approach tends to favor small granular functions that are coordinated using event-based triggers.</span></span> <span data-ttu-id="d36de-211">たとえば、メッセージがキューに配置されると、メッセージをキューから読み取って処理する関数がトリガーされるような場合です。</span><span class="sxs-lookup"><span data-stu-id="d36de-211">For example, a message being placed onto a queue might trigger a function that reads from the queue and processes the message.</span></span>

<span data-ttu-id="d36de-212">[Azure Functions][functions] はサーバーレスのコンピューティング サービスであり、HTTP 要求、Service Bus キュー、Event Hubs イベントなど、さまざまな関数トリガーをサポートします。</span><span class="sxs-lookup"><span data-stu-id="d36de-212">[Azure Functions][functions] is a serverless compute service that supports various function triggers, including HTTP requests, Service Bus queues, and Event Hubs events.</span></span> <span data-ttu-id="d36de-213">詳しくは、「[Azure Functions でのトリガーとバインドの概念][functions-triggers]」をご覧ください。</span><span class="sxs-lookup"><span data-stu-id="d36de-213">For a complete list, see [Azure Functions triggers and bindings concepts][functions-triggers].</span></span> <span data-ttu-id="d36de-214">また、Azure の管理されたイベント ルーティング サービスである [Azure Event Grid][event-grid] も検討してください。</span><span class="sxs-lookup"><span data-stu-id="d36de-214">Also consider [Azure Event Grid][event-grid], which is a managed event routing service in Azure.</span></span>

### <a name="orchestrator-or-serverless"></a><span data-ttu-id="d36de-215">オーケストレーターかサーバーレスか</span><span class="sxs-lookup"><span data-stu-id="d36de-215">Orchestrator or serverless?</span></span>

<span data-ttu-id="d36de-216">オーケストレーター アプローチとサーバーレス アプローチのどちらを選ぶかを検討するときの要因を次に示します。</span><span class="sxs-lookup"><span data-stu-id="d36de-216">Here are some factors to consider when choosing between an orchestrator approach and a serverless approach.</span></span>

<span data-ttu-id="d36de-217">**管理の容易性**。サーバーレス アプリケーションは、プラットフォームがすべてのコンピューティング リソースを管理するので、管理が容易です。</span><span class="sxs-lookup"><span data-stu-id="d36de-217">**Manageability** A serverless application is easy to manage, because the platform manages all the of compute resources for you.</span></span> <span data-ttu-id="d36de-218">オーケストレーターはクラスターの管理と構成の一部を抽象化しますが、基になる VM を完全には隠ぺいしません。</span><span class="sxs-lookup"><span data-stu-id="d36de-218">While an orchestrator abstracts some aspects of managing and configuring a cluster, it does not completely hide the underlying VMs.</span></span> <span data-ttu-id="d36de-219">オーケストレーターでは、負荷分散、CPU とメモリの使用量、ネットワークなどの問題について、ユーザーが考える必要があります。</span><span class="sxs-lookup"><span data-stu-id="d36de-219">With an orchestrator, you will need to think about issues such as load balancing, CPU and memory usage, and networking.</span></span>

<span data-ttu-id="d36de-220">**柔軟性と制御**。</span><span class="sxs-lookup"><span data-stu-id="d36de-220">**Flexibility and control**.</span></span> <span data-ttu-id="d36de-221">オーケストレーターでは、サービスおよびクラスターの構成と管理の広い範囲をユーザーが制御できます。</span><span class="sxs-lookup"><span data-stu-id="d36de-221">An orchestrator gives you a great deal of control over configuring and managing your services and the cluster.</span></span> <span data-ttu-id="d36de-222">その代わり、複雑さは増します。</span><span class="sxs-lookup"><span data-stu-id="d36de-222">The tradeoff is additional complexity.</span></span> <span data-ttu-id="d36de-223">サーバーレス アーキテクチャでは、詳細が抽象化されているため、ユーザーが制御できない部分があります。</span><span class="sxs-lookup"><span data-stu-id="d36de-223">With a serverless architecture, you give up some degree of control because these details are abstracted.</span></span>

<span data-ttu-id="d36de-224">**移植性**。</span><span class="sxs-lookup"><span data-stu-id="d36de-224">**Portability**.</span></span> <span data-ttu-id="d36de-225">ここで示したすべてのオーケストレーター (Kubernetes、DC/OS、Docker Swarm、Service Fabric) は、オンプレミスで、または複数のパブリック クラウドで実行できます。</span><span class="sxs-lookup"><span data-stu-id="d36de-225">All of the orchestrators listed here (Kubernetes, DC/OS, Docker Swarm, and Service Fabric) can run on-premises or in multiple public clouds.</span></span> 

<span data-ttu-id="d36de-226">**アプリケーションの統合**。</span><span class="sxs-lookup"><span data-stu-id="d36de-226">**Application integration**.</span></span> <span data-ttu-id="d36de-227">サーバーレス アーキテクチャを使って複雑なアプリケーションを構築するのは、困難な場合があります。</span><span class="sxs-lookup"><span data-stu-id="d36de-227">It can be challenging to build a complex application using a serverless architecture.</span></span> <span data-ttu-id="d36de-228">Azure での 1 つのオプションは、[Azure Logic Apps](/azure/logic-apps/) を使って Azure Functions のセットを調整することです。</span><span class="sxs-lookup"><span data-stu-id="d36de-228">One option in Azure is to use [Azure Logic Apps](/azure/logic-apps/) to coordinate a set of Azure Functions.</span></span> <span data-ttu-id="d36de-229">このアプローチの例については、「[Azure Logic Apps と統合される関数を作成する](/azure/azure-functions/functions-twitter-email)」をご覧ください。</span><span class="sxs-lookup"><span data-stu-id="d36de-229">For an example of this approach, see [Create a function that integrates with Azure Logic Apps](/azure/azure-functions/functions-twitter-email).</span></span>

<span data-ttu-id="d36de-230">**コスト**。</span><span class="sxs-lookup"><span data-stu-id="d36de-230">**Cost**.</span></span> <span data-ttu-id="d36de-231">オーケストレーターでは、クラスターで実行している VM の料金がかかります。</span><span class="sxs-lookup"><span data-stu-id="d36de-231">With an orchestrator, you pay for the VMs that are running in the cluster.</span></span> <span data-ttu-id="d36de-232">サーバーレス アプリケーションでは、実際に消費したコンピューティング リソースについてだけ課金されます。</span><span class="sxs-lookup"><span data-stu-id="d36de-232">With a serverless application, you pay only for the actual compute resources consumed.</span></span> <span data-ttu-id="d36de-233">どちらの場合も、記憶域、データベース、メッセージング サービスなど、追加サービスのコストを考慮する必要があります。</span><span class="sxs-lookup"><span data-stu-id="d36de-233">In both cases, you need to factor in the cost of any additional services, such as storage, databases, and messaging services.</span></span>

<span data-ttu-id="d36de-234">**スケーラビリティ**: </span><span class="sxs-lookup"><span data-stu-id="d36de-234">**Scalability**.</span></span> <span data-ttu-id="d36de-235">Azure Functions は、受信イベントの数に基づき、需要に合わせて自動的にスケーリングします。</span><span class="sxs-lookup"><span data-stu-id="d36de-235">Azure Functions scales automatically to meet demand, based on the number of incoming events.</span></span> <span data-ttu-id="d36de-236">オーケストレーターでは、クラスターで実行するサービス インスタンスの数を増やすことによりスケールアウトできます。</span><span class="sxs-lookup"><span data-stu-id="d36de-236">With an orchestrator, you can scale out by increasing the number of service instances running in the cluster.</span></span> <span data-ttu-id="d36de-237">また、クラスターに VM を追加してスケーリングすることもできます。</span><span class="sxs-lookup"><span data-stu-id="d36de-237">You can also scale by adding additional VMs to the cluster.</span></span>

<span data-ttu-id="d36de-238">この参照実装では主に Kubernetes を使っていますが、配送履歴サービスに対しては Azure Functions を使いました。</span><span class="sxs-lookup"><span data-stu-id="d36de-238">Our reference implementation primarily uses Kubernetes, but we did use Azure Functions for one service, namely the Delivery History service.</span></span> <span data-ttu-id="d36de-239">この特定のサービスはイベント ドリブンのワークロードであるため、Azure Functions が適していました。</span><span class="sxs-lookup"><span data-stu-id="d36de-239">Azure Functions was a good fit for this particular service, because it's is an event-driven workload.</span></span> <span data-ttu-id="d36de-240">Event Hubs のトリガーを使って関数を呼び出すことにより、サービスで必要なコードは最小限の量で済みました。</span><span class="sxs-lookup"><span data-stu-id="d36de-240">By using an Event Hubs trigger to invoke the function, the service needed a minimal amount of code.</span></span> <span data-ttu-id="d36de-241">また、配送履歴サービスはメイン ワークフローの一部ではないので、Kubernetes クラスターの外部で実行しても、ユーザー開始操作のエンド ツー エンドの待機時間には影響がありません。</span><span class="sxs-lookup"><span data-stu-id="d36de-241">Also, the Delivery History service is not part of the main workflow, so running it outside of the Kubernetes cluster doesn't affect the end-to-end latency of user-initiated operations.</span></span> 

> [!div class="nextstepaction"]
> [<span data-ttu-id="d36de-242">データに関する考慮事項</span><span class="sxs-lookup"><span data-stu-id="d36de-242">Data considerations</span></span>](./data-considerations.md)

<!-- links -->

[acs-engine]: https://github.com/Azure/acs-engine
[acs-faq]: /azure/container-service/dcos-swarm/container-service-faq
[event-grid]: /azure/event-grid/
[functions]: /azure/azure-functions/functions-overview
[functions-triggers]: /azure/azure-functions/functions-triggers-bindings
