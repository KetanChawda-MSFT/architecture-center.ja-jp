---
title: Azure アプリケーションの高可用性
description: Microsoft Azure で可用性の高いアプリケーションを設計し、構築するための方法に関する技術的概要と詳細。
author: adamglick
ms.date: 05/31/2017
ms.openlocfilehash: f116b9e64f1722b5141ae90239d5c8a8b4a89487
ms.sourcegitcommit: e67b751f230792bba917754d67789a20810dc76b
ms.translationtype: HT
ms.contentlocale: ja-JP
ms.lasthandoff: 04/06/2018
---
[!INCLUDE [header](../_includes/header.md)]

# <a name="high-availability-for-applications-built-on-microsoft-azure"></a><span data-ttu-id="d1e14-103">Microsoft Azure 上に構築されたアプリケーションの高可用性</span><span class="sxs-lookup"><span data-stu-id="d1e14-103">High availability for applications built on Microsoft Azure</span></span>
<span data-ttu-id="d1e14-104">高可用性アプリケーションは、依存型のサービスとハードウェアの可用性の変動、負荷、一時的な障害を緩和します。</span><span class="sxs-lookup"><span data-stu-id="d1e14-104">A highly available application absorbs fluctuations in availability, load, and temporary failures in dependent services and hardware.</span></span> <span data-ttu-id="d1e14-105">アプリケーションは、ビジネス要件またはアプリケーションのサービス レベル アグリーメント (SLA) に定義されている許容レベルで実行を続けます。</span><span class="sxs-lookup"><span data-stu-id="d1e14-105">The application continues to perform acceptably, as defined by business requirements or application service-level agreements (SLAs).</span></span>

## <a name="azure-high-availability-features"></a><span data-ttu-id="d1e14-106">Azure の高可用性機能</span><span class="sxs-lookup"><span data-stu-id="d1e14-106">Azure high-availability features</span></span>
<span data-ttu-id="d1e14-107">Azure には、可用性の高いアプリケーションをサポートするさまざまなプラットフォーム機能が組み込まれています。</span><span class="sxs-lookup"><span data-stu-id="d1e14-107">Azure has many built-in platform features that support highly available applications.</span></span> <span data-ttu-id="d1e14-108">このセクションでは、それらの主要機能の一部について説明します。</span><span class="sxs-lookup"><span data-stu-id="d1e14-108">This section describes some of those key features.</span></span>

### <a name="fabric-controller"></a><span data-ttu-id="d1e14-109">ファブリック コントローラー</span><span class="sxs-lookup"><span data-stu-id="d1e14-109">Fabric controller</span></span>
<span data-ttu-id="d1e14-110">Azure ファブリック コントローラーは、Azure コンピューティング インスタンスをプロビジョニングし、その状態を監視します。</span><span class="sxs-lookup"><span data-stu-id="d1e14-110">The Azure fabric controller provisions and monitors the condition of Azure compute instances.</span></span> <span data-ttu-id="d1e14-111">このファブリック コントローラーは、ホスト コンピューター インスタンスとゲスト コンピューター インスタンスのハードウェアとソフトウェアの状態を監視します。</span><span class="sxs-lookup"><span data-stu-id="d1e14-111">The fabric controller monitors the status of the hardware and software of the host and guest machine instances.</span></span> <span data-ttu-id="d1e14-112">エラーが検出された場合、VM インスタンスを自動的に再配置し、SLA を維持します。</span><span class="sxs-lookup"><span data-stu-id="d1e14-112">When it detects a failure, it maintains SLAs by automatically relocating the VM instances.</span></span> <span data-ttu-id="d1e14-113">障害ドメインとアップグレード ドメインのコンセプトがコンピューティング SLA をさらにサポートします。</span><span class="sxs-lookup"><span data-stu-id="d1e14-113">The concept of fault and upgrade domains further supports the compute SLA.</span></span>

<span data-ttu-id="d1e14-114">複数のクラウド サービスのロール インスタンスがデプロイされている場合、Azure はこれらのインスタンスを異なる障害ドメインにデプロイします。</span><span class="sxs-lookup"><span data-stu-id="d1e14-114">When multiple Cloud Service role instances are deployed, Azure deploys these instances to different fault domains.</span></span> <span data-ttu-id="d1e14-115">障害ドメインの境界は、基本的に、同じリージョンの異なるハードウェア ラックになります。</span><span class="sxs-lookup"><span data-stu-id="d1e14-115">A fault domain boundary is essentially a different hardware rack in the same region.</span></span> <span data-ttu-id="d1e14-116">障害ドメインは、ローカライズされたハードウェアがアプリケーションのサービスを遮断する可能性を減らします。</span><span class="sxs-lookup"><span data-stu-id="d1e14-116">Fault domains reduce the probability that a localized hardware failure interrupts the service of an application.</span></span> <span data-ttu-id="d1e14-117">worker または Web ロールの障害ドメインの数は管理できません。</span><span class="sxs-lookup"><span data-stu-id="d1e14-117">You cannot manage the number of fault domains of your worker roles or web roles.</span></span> <span data-ttu-id="d1e14-118">ファブリック コントローラーは、Azure でホストされるアプリケーションから分離している専用リソースを使用します。</span><span class="sxs-lookup"><span data-stu-id="d1e14-118">The fabric controller uses dedicated resources that are separate from Azure-hosted applications.</span></span> <span data-ttu-id="d1e14-119">Azure システムの中核としてサービスを提供するため、100% のアップタイムが必要です。</span><span class="sxs-lookup"><span data-stu-id="d1e14-119">It requires 100 percent uptime because it serves as the nucleus of the Azure system.</span></span> <span data-ttu-id="d1e14-120">障害ドメイン全体でロール インスタンスを監視し、管理します。</span><span class="sxs-lookup"><span data-stu-id="d1e14-120">It monitors and manages role instances across fault domains.</span></span>

<span data-ttu-id="d1e14-121">次の図は、異なる障害ドメインにまたがってファブリック コントローラーによりデプロイされ、管理される Azure 共有リソースを示したものです。</span><span class="sxs-lookup"><span data-stu-id="d1e14-121">The following diagram shows Azure shared resources that the fabric controller deploys and manages across different fault domains.</span></span>

![Simplified view of fault domain isolation](./images/high-availability-azure-applications/fault-domain-isolation.png)

<span data-ttu-id="d1e14-123">障害ドメインは障害を軽減するための物理的な分離ですが、アップグレード ドメインは、サービスのインスタンスを特定の時刻にアップグレードするかを決定する、インスタンス分離の論理ユニットです。</span><span class="sxs-lookup"><span data-stu-id="d1e14-123">While fault domains are physical separations to mitigate failure, upgrade domains are logical units of instance separation that determine which instances of a service will be upgraded at a specific time.</span></span> <span data-ttu-id="d1e14-124">既定では、ホストされるサービスのデプロイの場合、5 つのアップグレード ドメインが定義されます。</span><span class="sxs-lookup"><span data-stu-id="d1e14-124">By default, five upgrade domains are defined for your hosted service deployment.</span></span> <span data-ttu-id="d1e14-125">ただし、サービス定義ファイルでその値を変更できます。</span><span class="sxs-lookup"><span data-stu-id="d1e14-125">However, you can change that value in the service definition file.</span></span> <span data-ttu-id="d1e14-126">たとえば、Web ロールの 8 つのインスタンスがある場合は、3 つのアップグレード ドメインに 2 つのインスタンス、1 つのアップグレード ドメインに 2 つのインスタンスがあります。</span><span class="sxs-lookup"><span data-stu-id="d1e14-126">For example, if you have eight instances of your web role, there are two instances in three upgrade domains and two instances in one upgrade domain.</span></span> <span data-ttu-id="d1e14-127">Azure は、アップグレード ドメインの数に基づいて更新順序を定義します。</span><span class="sxs-lookup"><span data-stu-id="d1e14-127">Azure defines the update sequence based on the number of upgrade domains.</span></span> <span data-ttu-id="d1e14-128">詳しくは、「[クラウド サービスの更新方法](/azure/cloud-services/cloud-services-update-azure-service/)」をご覧ください。</span><span class="sxs-lookup"><span data-stu-id="d1e14-128">For more information, see [Update a cloud service](/azure/cloud-services/cloud-services-update-azure-service/).</span></span>

### <a name="features-in-other-services"></a><span data-ttu-id="d1e14-129">その他のサービスの機能</span><span class="sxs-lookup"><span data-stu-id="d1e14-129">Features in other services</span></span>
<span data-ttu-id="d1e14-130">プラットフォーム機能でコンピューティング リソースの高可用性をサポートするだけでなく、Azure は高可用性機能を他のサービスに組み込みます。</span><span class="sxs-lookup"><span data-stu-id="d1e14-130">In addition to the platform features that support high availability of compute resources, Azure embeds high-availability features in its other services.</span></span> <span data-ttu-id="d1e14-131">たとえば、Azure Storage は、すべてのデータの少なくとも 3 つのレプリカを Azure ストレージ アカウントに維持します。</span><span class="sxs-lookup"><span data-stu-id="d1e14-131">For example, Azure Storage maintains at least three replicas of all data in your Azure storage account.</span></span> <span data-ttu-id="d1e14-132">また、geo レプリケーションでデータのコピーをセカンダリ リージョンに格納することもできます。</span><span class="sxs-lookup"><span data-stu-id="d1e14-132">It also enables geo-replication to store copies of your data in a secondary region.</span></span> <span data-ttu-id="d1e14-133">Azure Content Delivery Network は世界中の BLOB をキャッシュし、冗長性、拡張性、待ち時間の短縮を実現します。</span><span class="sxs-lookup"><span data-stu-id="d1e14-133">The Azure Content Delivery Network allows blobs to be cached around the world for redundancy, scalability, and lower latency.</span></span> <span data-ttu-id="d1e14-134">Azure SQL Database はまた、複数のレプリカを維持します。</span><span class="sxs-lookup"><span data-stu-id="d1e14-134">Azure SQL Database maintains multiple replicas as well.</span></span>

<span data-ttu-id="d1e14-135">Azure プラットフォームの可用性機能について詳しくは、「[Resiliency technical guidance](index.md)」(回復性技術ガイダンス) をご覧ください。</span><span class="sxs-lookup"><span data-stu-id="d1e14-135">For a deeper discussion of Azure platform availability features, see [Resiliency technical guidance](index.md).</span></span> <span data-ttu-id="d1e14-136">「[Best practices for designing large-scale services on Windows Azure](https://azure.microsoft.com/blog/best-practices-for-designing-large-scale-services-on-windows-azure/)」(Microsoft Azure で大規模なサービスを設計するためのベスト プラクティス) もご覧ください。</span><span class="sxs-lookup"><span data-stu-id="d1e14-136">Also see [Best practices for designing large-scale services on Windows Azure](https://azure.microsoft.com/blog/best-practices-for-designing-large-scale-services-on-windows-azure/).</span></span>

<span data-ttu-id="d1e14-137">Azure には高可用性をサポートする複数の機能が用意されていますが、その制約を理解することが重要です。</span><span class="sxs-lookup"><span data-stu-id="d1e14-137">Although Azure provides multiple features that support high availability, it's important to understand their limitations:</span></span>

* <span data-ttu-id="d1e14-138">コンピューティングに関しては、あなたのロールが利用できて実行されていることを Azure は保証しますが、あなたのアプリケーションが実行されているのか、過負荷になっているのかは検出できません。</span><span class="sxs-lookup"><span data-stu-id="d1e14-138">For compute, Azure guarantees that your roles are available and running, but it cannot detect whether your application is running or overloaded.</span></span>
* <span data-ttu-id="d1e14-139">Azure SQL Database の場合、データはリージョン内で同期複製されます。</span><span class="sxs-lookup"><span data-stu-id="d1e14-139">For Azure SQL Database, data is replicated synchronously within the region.</span></span> <span data-ttu-id="d1e14-140">アクティブ geo レプリケーションを選択できます。アクティブ geo レプリケーションでは、同じリージョン (または異なるリージョン) にデータベース コピーを 4 つまで保持できます。</span><span class="sxs-lookup"><span data-stu-id="d1e14-140">You can choose active geo-replication, which allows up to four additional database copies in the same region (or different regions).</span></span> <span data-ttu-id="d1e14-141">これらのデータベース レプリカはポイントインタイム バックアップではありませんが、SQL Database はポイントインタイム バックアップ機能を提供します。</span><span class="sxs-lookup"><span data-stu-id="d1e14-141">While these database replicas are not point-in-time backups, SQL Database does provide point-in-time backup capabilities.</span></span> <span data-ttu-id="d1e14-142">詳しくは、「[データベースの自動バックアップを使用した Azure SQL Database の復旧](/azure/sql-database/sql-database-recovery-using-backups#point-in-time-restore)」の「ポイントインタイム リストア」をご覧ください。</span><span class="sxs-lookup"><span data-stu-id="d1e14-142">For more information, see [Recover an Azure SQL Database using automated data backups: Point-in-time restore](/azure/sql-database/sql-database-recovery-using-backups#point-in-time-restore).</span></span>
* <span data-ttu-id="d1e14-143">Azure Storage の場合、テーブル データと BLOB データは既定で代替リージョンにレプリケートされます。</span><span class="sxs-lookup"><span data-stu-id="d1e14-143">For Azure Storage, table data and blob data are replicated by default to an alternate region.</span></span> <span data-ttu-id="d1e14-144">ただし、代替サイトへのフェールオーバーを Microsoft が選択するまで、レプリカにアクセスできません。</span><span class="sxs-lookup"><span data-stu-id="d1e14-144">However, you cannot access the replicas until Microsoft chooses to fail over to the alternate site.</span></span> <span data-ttu-id="d1e14-145">リージョン フェールオーバーは、リージョン全体のサービス中断が長引いた場合にのみ発生します。geo フェールオーバーの時間には SLA はありません。</span><span class="sxs-lookup"><span data-stu-id="d1e14-145">A region failover occurs only during a prolonged region-wide service disruption, and there is no SLA for geo-failover time.</span></span> <span data-ttu-id="d1e14-146">データの破損はすぐにレプリカに広まることにもご留意ください。</span><span class="sxs-lookup"><span data-stu-id="d1e14-146">It's also important to note that any data corruption quickly spreads to the replicas.</span></span> <span data-ttu-id="d1e14-147">これらの理由から、プラットフォームの可用性機能をアプリケーション固有の可用性機能 (BLOB データのポイントインタイム バックアップを作成する BLOB スナップショット機能など) で補完する必要があります。</span><span class="sxs-lookup"><span data-stu-id="d1e14-147">For these reasons, you must supplement platform availability features with application-specific availability features, including the blob snapshot feature to create point-in-time backups of blob data.</span></span>

### <a name="availability-sets-for-azure-virtual-machines"></a><span data-ttu-id="d1e14-148">Azure Virtual Machines の可用性セット</span><span class="sxs-lookup"><span data-stu-id="d1e14-148">Availability sets for Azure Virtual Machines</span></span>
<span data-ttu-id="d1e14-149">このドキュメントでは、サービスとしてのプラットフォーム (PaaS) モデルを使用する、クラウド サービスについて重点的に説明します。</span><span class="sxs-lookup"><span data-stu-id="d1e14-149">This document primarily focuses on cloud services, which use a platform-as-a-service (PaaS) model.</span></span> <span data-ttu-id="d1e14-150">サービスとしてのインフラストラクチャ (IaaS) モデルを使用する、Azure Virtual Machines 固有の可用性機能もあります。</span><span class="sxs-lookup"><span data-stu-id="d1e14-150">There are also specific availability features for Azure Virtual Machines, which use an infrastructure-as-a-service (IaaS) model.</span></span> <span data-ttu-id="d1e14-151">Virtual Machines を使用して高可用性を実現するには、障害ドメインおよびアップグレード ドメインと同様の機能を提供する可用性セットを使用する必要があります。</span><span class="sxs-lookup"><span data-stu-id="d1e14-151">To achieve high availability with Virtual Machines, you must use availability sets, which serve a similar function to fault and upgrade domains.</span></span> <span data-ttu-id="d1e14-152">可用性セット内では、ローカライズされたハードウェアの障害や保守管理行動に起因してグループ内の全コンピューターが停止する事態が回避されるように、Azure は仮想マシンを配置します。</span><span class="sxs-lookup"><span data-stu-id="d1e14-152">Within an availability set, Azure positions the virtual machines in a way that prevents localized hardware faults and maintenance activities from bringing down all the machines in that group.</span></span> <span data-ttu-id="d1e14-153">Virtual Machines の可用性に関する Azure SLA を達成するためには、可用性セットが必要です。</span><span class="sxs-lookup"><span data-stu-id="d1e14-153">Availability sets are required to achieve the Azure SLA for the availability of Virtual Machines.</span></span>

<span data-ttu-id="d1e14-154">次の図は、Web 仮想マシンと SQL Server 仮想マシンの 2 つの可用性セットを示しています。</span><span class="sxs-lookup"><span data-stu-id="d1e14-154">The following diagram shows two availability sets for web and SQL Server virtual machines, respectively.</span></span>

![Azure Virtual Machines の可用性セット](./images/high-availability-azure-applications/availability-set-for-azure-virtual-machines.png)

> [!NOTE]
> <span data-ttu-id="d1e14-156">上の図では、SQL Server が仮想マシンにインストールされ、実行されています。</span><span class="sxs-lookup"><span data-stu-id="d1e14-156">In the preceding diagram, SQL Server is installed and running on virtual machines.</span></span> <span data-ttu-id="d1e14-157">これは、管理サービスとしてデータベースを提供する、Azure SQL Database とは異なります。</span><span class="sxs-lookup"><span data-stu-id="d1e14-157">This is different from Azure SQL Database, which provides a database as a managed service.</span></span>
> 
> 

## <a name="application-strategies-for-high-availability"></a><span data-ttu-id="d1e14-158">高可用性のアプリケーション戦略</span><span class="sxs-lookup"><span data-stu-id="d1e14-158">Application strategies for high availability</span></span>
<span data-ttu-id="d1e14-159">高可用性のアプリケーション戦略の大半は、アプリケーション コンポーネント間の冗長性または強固な依存性の解除に関するものです。</span><span class="sxs-lookup"><span data-stu-id="d1e14-159">Most application strategies for high availability involve either redundancy or the removal of hard dependencies between application components.</span></span> <span data-ttu-id="d1e14-160">アプリケーションを設計するとき、Azure またはサードパーティ サービスの散発的ダウンタイム時の耐障害性を組み込む必要があります。</span><span class="sxs-lookup"><span data-stu-id="d1e14-160">Application design should support fault tolerance during sporadic downtime of Azure or third-party services.</span></span> <span data-ttu-id="d1e14-161">次のセクションでは、クラウド サービスの可用性を上げるアプリケーション パターンを紹介します。</span><span class="sxs-lookup"><span data-stu-id="d1e14-161">The following sections describe application patterns for improving the availability of your cloud services.</span></span>

### <a name="asynchronous-communication-and-durable-queues"></a><span data-ttu-id="d1e14-162">非同期の通信と永続的なキュー</span><span class="sxs-lookup"><span data-stu-id="d1e14-162">Asynchronous communication and durable queues</span></span>
<span data-ttu-id="d1e14-163">Azure アプリケーションの可用性を高めるために、疎結合のサービス間に非同期の通信を取り入れることを検討してください。</span><span class="sxs-lookup"><span data-stu-id="d1e14-163">To increase availability in Azure applications, consider asynchronous communication between loosely coupled services.</span></span> <span data-ttu-id="d1e14-164">このパターンでは、ストレージ キューと Azure Service Bus キューのいずれかにメッセージが書き込まれ、後で処理されます。</span><span class="sxs-lookup"><span data-stu-id="d1e14-164">In this pattern, messages are written to either storage queues or Azure Service Bus queues for later processing.</span></span> <span data-ttu-id="d1e14-165">キューにメッセージが書き込まれると、直後に送信者にコントロールが返されます。</span><span class="sxs-lookup"><span data-stu-id="d1e14-165">When a message is written to the queue, control immediately returns to the sender.</span></span> <span data-ttu-id="d1e14-166">アプリケーションの別のサービス (通常、worker ロールとして実行されます) がメッセージを処理します。</span><span class="sxs-lookup"><span data-stu-id="d1e14-166">Another service of the application (typically implemented as a worker role) processes the message.</span></span> <span data-ttu-id="d1e14-167">処理サービスが停止した場合、そのサービスが元の状態に戻るまで、メッセージはキューに累積されます。</span><span class="sxs-lookup"><span data-stu-id="d1e14-167">If the processing service stops working, the messages accumulate in the queue until the processing service is restored.</span></span> <span data-ttu-id="d1e14-168">フロントエンドの送信者とメッセージの処理者の間に直接的な依存関係はありません。</span><span class="sxs-lookup"><span data-stu-id="d1e14-168">There is no direct dependency between the front-end sender and the message processor.</span></span> <span data-ttu-id="d1e14-169">これにより、分散アプリケーションのボトルネックを引き起こす可能性のある同期サービス呼び出しが排除されます。</span><span class="sxs-lookup"><span data-stu-id="d1e14-169">This eliminates synchronous service calls that can cause bottlenecks in distributed applications.</span></span>

<span data-ttu-id="d1e14-170">このパターンのバリエーションとしては、故障したデータベースの呼び出しに関する情報を Azure Storage (BLOB、テーブル、キュー) または Service Bus のキューに格納する方法があります。</span><span class="sxs-lookup"><span data-stu-id="d1e14-170">A variation of this pattern stores information about failed database calls in Azure Storage (blobs, tables, or queues) or Service Bus queues.</span></span> <span data-ttu-id="d1e14-171">たとえば、あるアプリケーション内で別のサービス (Azure SQL Database など) を同期的に呼び出す行為は繰り返し失敗します。</span><span class="sxs-lookup"><span data-stu-id="d1e14-171">For example, a synchronous call within an application to another service (such as Azure SQL Database) fails repeatedly.</span></span> <span data-ttu-id="d1e14-172">場合によっては、その要求をシリアル化し、永続的なストレージに保存できます。</span><span class="sxs-lookup"><span data-stu-id="d1e14-172">You might be able to serialize that request into durable storage.</span></span> <span data-ttu-id="d1e14-173">後に、サービスまたはデータベースがオンラインに戻ったときに、アプリケーションはストレージから要求を再送信できます。</span><span class="sxs-lookup"><span data-stu-id="d1e14-173">At some later point when the service or database is back online, the application can resubmit the request from storage.</span></span> <span data-ttu-id="d1e14-174">このモデルの違いは、仲介となる場所が、アプリケーション ワークフローの通常の部分としてではなく、フェールオーバー時にのみ使用されるということです。</span><span class="sxs-lookup"><span data-stu-id="d1e14-174">The difference in this model is that the intermediate location is used only during failures, not as a regular part of the application workflow.</span></span>

<span data-ttu-id="d1e14-175">いずれのシナリオでも、非同期通信と中間ストレージの利用により、バックエンド サービスが停止しても、アプリケーション全体が停止する事態が回避されます。</span><span class="sxs-lookup"><span data-stu-id="d1e14-175">In both scenarios, asynchronous communication and intermediate storage prevent a downed back-end service from bringing down the entire application.</span></span> <span data-ttu-id="d1e14-176">キューは論理的な仲介者として機能します。</span><span class="sxs-lookup"><span data-stu-id="d1e14-176">Queues serve as a logical intermediary.</span></span> <span data-ttu-id="d1e14-177">キュー サービス間の選択について詳しくは、「[Azure キューと Service Bus キューの比較&mdash;](/azure/service-bus-messaging/service-bus-azure-and-service-bus-queues-compared-contrasted/)」をご覧ください。</span><span class="sxs-lookup"><span data-stu-id="d1e14-177">For more information on choosing between queuing services, see [Azure queues and Azure Service Bus queues &mdash; compared and contrasted](/azure/service-bus-messaging/service-bus-azure-and-service-bus-queues-compared-contrasted/).</span></span>

### <a name="fault-detection-and-retry-logic"></a><span data-ttu-id="d1e14-178">障害検出と再試行ロジック</span><span class="sxs-lookup"><span data-stu-id="d1e14-178">Fault detection and retry logic</span></span>
<span data-ttu-id="d1e14-179">高可用性アプリケーションの設計で重要なことは、コード内で再試行ロジックを使用し、一時的に使用不可になっているサービスをグレースフルに (劣化を最小限に抑えるように) 処理することです。</span><span class="sxs-lookup"><span data-stu-id="d1e14-179">A key aspect of the design of highly available applications is the use of retry logic within code to gracefully handle a service that is temporarily unavailable.</span></span> <span data-ttu-id="d1e14-180">Azure Storage と Azure Service Bus の最新バージョンの SDK は再試行をネイティブにサポートします。</span><span class="sxs-lookup"><span data-stu-id="d1e14-180">Recent versions of SDKs for both Azure Storage and Azure Service Bus natively support retries.</span></span> <span data-ttu-id="d1e14-181">アプリケーションのカスタムの再試行ロジックの提供について詳しくは、「[Retry pattern](../patterns/retry.md)」(再試行パターン) をご覧ください。</span><span class="sxs-lookup"><span data-stu-id="d1e14-181">For more information on providing custom retry logic for your application, see the [Retry pattern](../patterns/retry.md).</span></span>

### <a name="reference-data-pattern-for-high-availability"></a><span data-ttu-id="d1e14-182">高可用性の参照データ パターン</span><span class="sxs-lookup"><span data-stu-id="d1e14-182">Reference data pattern for high availability</span></span>
<span data-ttu-id="d1e14-183">参照データは、アプリケーションの読み取り専用データです。</span><span class="sxs-lookup"><span data-stu-id="d1e14-183">Reference data is the read-only data of an application.</span></span> <span data-ttu-id="d1e14-184">このデータはビジネス コンテキストを与えます。そのビジネス コンテキストの中で、アプリケーションは業務の際にトランザクション データを生成します。</span><span class="sxs-lookup"><span data-stu-id="d1e14-184">This data provides the business context within which the application generates transactional data during a business operation.</span></span> <span data-ttu-id="d1e14-185">トランザクション データの整合性は、トランザクションの完了時の参照データのスナップショットに依存します。</span><span class="sxs-lookup"><span data-stu-id="d1e14-185">The integrity of transactional data depends on a snapshot of the reference data at the time the transaction was completed.</span></span>

<span data-ttu-id="d1e14-186">アプリケーションの適切な操作には参照データが必要です。</span><span class="sxs-lookup"><span data-stu-id="d1e14-186">Reference data is necessary for the proper operation of the application.</span></span> <span data-ttu-id="d1e14-187">さまざまなアプリケーションが参照データを作成し、維持します。通常、マスター データ管理 (MDM) システムがこの機能を実行します。</span><span class="sxs-lookup"><span data-stu-id="d1e14-187">Various applications create and maintain reference data; master data management (MDM) systems often perform this function.</span></span> <span data-ttu-id="d1e14-188">そのようなシステムは、参照データのライフサイクルを担当します。</span><span class="sxs-lookup"><span data-stu-id="d1e14-188">These systems are responsible for the life cycle of the reference data.</span></span> <span data-ttu-id="d1e14-189">参照データには、たとえば、製品カタログ、社員マスター、部品マスター、設備マスターがあります。</span><span class="sxs-lookup"><span data-stu-id="d1e14-189">Examples of reference data include product catalog, employee master, parts master, and equipment master.</span></span> <span data-ttu-id="d1e14-190">参照データは組織の外部から発生することもあります。郵便番号や税率などです。</span><span class="sxs-lookup"><span data-stu-id="d1e14-190">Reference data can also originate from outside the organization, for example, postal codes or tax rates.</span></span> <span data-ttu-id="d1e14-191">参照データの可用性を高めるための戦略は、一般的に、トランザクション データの場合よりも簡単です。</span><span class="sxs-lookup"><span data-stu-id="d1e14-191">Strategies for increasing the availability of reference data are typically less difficult than those for transactional data.</span></span> <span data-ttu-id="d1e14-192">参照データには、ほとんど変化しないという利点があります。</span><span class="sxs-lookup"><span data-stu-id="d1e14-192">Reference data has the advantage of being mostly immutable.</span></span>

<span data-ttu-id="d1e14-193">アプリケーションと共に参照データをデプロイすることで、Azure Web ロールと worker ロールは実行時に自立的に参照データを利用できます。</span><span class="sxs-lookup"><span data-stu-id="d1e14-193">Azure web and worker roles that consume reference data can be made autonomous at runtime by deploying the reference data along with the application.</span></span> <span data-ttu-id="d1e14-194">この手法は、ローカル ストレージが十分に大きく、このようなデプロイが可能な場合に理想的です。</span><span class="sxs-lookup"><span data-stu-id="d1e14-194">This approach is ideal if the size of the local storage allows such a deployment.</span></span> <span data-ttu-id="d1e14-195">Azure コンピューティングのスケール ユニットの自立性には、ローカルにデプロイされている組み込み SQL データベース、NoSQL データベース、または XML ファイルが役立ちます。</span><span class="sxs-lookup"><span data-stu-id="d1e14-195">Embedded SQL databases, NoSQL databases, or XML files deployed locally help with the autonomy of Azure compute scale units.</span></span> <span data-ttu-id="d1e14-196">ただし、再デプロイしなくても各ロールのデータを更新するメカニズムを用意する必要があります。</span><span class="sxs-lookup"><span data-stu-id="d1e14-196">However, you should have a mechanism to update the data in each role without requiring redeployment.</span></span> <span data-ttu-id="d1e14-197">具体的には、参照データが更新されたら、それをクラウド ストレージ エンドポイント (Azure BLOB ストレージや SQL Database など) に送信します。</span><span class="sxs-lookup"><span data-stu-id="d1e14-197">To do this, place any updates to the reference data at a cloud storage endpoint (for example, Azure Blob storage or SQL Database).</span></span> <span data-ttu-id="d1e14-198">ロールの起動時にコンピューティング ノードにデータ更新をダウンロードするコードを各ロールに追加します。</span><span class="sxs-lookup"><span data-stu-id="d1e14-198">Add code to each role that downloads the data updates into the compute nodes at role startup.</span></span> <span data-ttu-id="d1e14-199">あるいは、ロール インスタンスへの強制ダウンロードを管理者に許可するコードを追加します。</span><span class="sxs-lookup"><span data-stu-id="d1e14-199">Alternatively, add code that allows an administrator to perform a forced download into the role instances.</span></span>

<span data-ttu-id="d1e14-200">ストレージが停止したときに可用性を上げるために、一連の参照データをロールに追加する必要もあります。</span><span class="sxs-lookup"><span data-stu-id="d1e14-200">To increase availability, the roles should also contain a set of reference data in case storage is down.</span></span> <span data-ttu-id="d1e14-201">更新のストレージ リソースが利用できるようになるまで、一連の基本参照データでロールを起動できます。</span><span class="sxs-lookup"><span data-stu-id="d1e14-201">Roles can start with a basic set of reference data until the storage resource becomes available for the updates.</span></span>

![自立的コンピューティング ノードによるアプリケーションの高可用性](./images/high-availability-azure-applications/application-high-availability-through-autonomous-compute-nodes.png)

<span data-ttu-id="d1e14-203">このパターンでは、大量の参照データをデプロイまたはダウンロードする場合に、新しいデプロイまたはロール インスタンスの起動に時間がかかることがあります。</span><span class="sxs-lookup"><span data-stu-id="d1e14-203">With this pattern, new deployments or role instances may take longer to start if you are deploying or downloading large amounts of reference data.</span></span> <span data-ttu-id="d1e14-204">時間が増えたとしても、外部のストレージ サービスに頼ることなく、各ロールで参照データをすぐに利用できるという自立性が与えられるなら許容範囲内となることもあります。</span><span class="sxs-lookup"><span data-stu-id="d1e14-204">This tradeoff might be acceptable for the autonomy of having the reference data immediately available on each role, rather than depending on external storage services.</span></span>

### <a name="transactional-data-pattern-for-high-availability"></a><span data-ttu-id="d1e14-205">高可用性のトランザクション データ パターン</span><span class="sxs-lookup"><span data-stu-id="d1e14-205">Transactional data pattern for high availability</span></span>
<span data-ttu-id="d1e14-206">トランザクション データは、ビジネス コンテキストにおいてアプリケーションによって生成されるデータです。</span><span class="sxs-lookup"><span data-stu-id="d1e14-206">Transactional data is the data that the application generates in a business context.</span></span> <span data-ttu-id="d1e14-207">トランザクション データは、アプリケーションに実装する一連のビジネス プロセスとそのようなプロセスをサポートする参照データを組み合わせたものです。</span><span class="sxs-lookup"><span data-stu-id="d1e14-207">Transactional data is a combination of the set of business processes that the application implements and the reference data that supports these processes.</span></span> <span data-ttu-id="d1e14-208">トランザクション データには、たとえば、注文、事前出荷明細、請求書、顧客関係管理 (CRM) 案件などがあります。</span><span class="sxs-lookup"><span data-stu-id="d1e14-208">Examples of transactional data can include orders, advanced shipping notices, invoices, and customer relationship management (CRM) opportunities.</span></span> <span data-ttu-id="d1e14-209">トランザクション データは記録を保存する外部システムに送信され、さらに処理されます。</span><span class="sxs-lookup"><span data-stu-id="d1e14-209">Transactional data is supplied to external systems for record keeping or for further processing.</span></span>

<span data-ttu-id="d1e14-210">参照データはそのデータを担当するシステム内で変動する場合があります。</span><span class="sxs-lookup"><span data-stu-id="d1e14-210">Reference data can change within the systems that are responsible for that data.</span></span> <span data-ttu-id="d1e14-211">そのような理由から、外部依存性を最小限に抑え、その意味論的な一貫性を維持するために、参照データの特定の時点のコンテキストをトランザクション データで保存する必要があります。</span><span class="sxs-lookup"><span data-stu-id="d1e14-211">Therefore, transactional data must save the point-in-time reference data context to minimize external dependencies for its semantic consistency.</span></span> <span data-ttu-id="d1e14-212">たとえば、注文の完了から数か月後に製品をカタログから削除するとします。</span><span class="sxs-lookup"><span data-stu-id="d1e14-212">For example, a product may be removed from the catalog several months after an order is fulfilled.</span></span> <span data-ttu-id="d1e14-213">トランザクションを使用してできるだけ多くの参照データ コンテキストを格納することをお勧めします。</span><span class="sxs-lookup"><span data-stu-id="d1e14-213">Storing as much reference data context as possible with the transaction is recommended.</span></span> <span data-ttu-id="d1e14-214">この手法では、トランザクションの記録後に参照データが変更された場合でも、トランザクションに関連付けられている意味が失われません。</span><span class="sxs-lookup"><span data-stu-id="d1e14-214">This approach preserves the semantics associated with the transaction, even if the reference data changes after the transaction is captured.</span></span>

<span data-ttu-id="d1e14-215">前述のように、疎結合と非同期通信を使用するアーキテクチャは高いレベルの可用性を提供します。</span><span class="sxs-lookup"><span data-stu-id="d1e14-215">As mentioned previously, architectures that use loose coupling and asynchronous communication can provide higher levels of availability.</span></span> <span data-ttu-id="d1e14-216">それはトランザクション データにも当てはまります。ただし、実装は一層複雑になります。</span><span class="sxs-lookup"><span data-stu-id="d1e14-216">This is true for transactional data as well, but the implementation is more complex.</span></span> <span data-ttu-id="d1e14-217">トランザクションの従来の概念は、通常、トランザクションを請け合うデータベースに依存します。</span><span class="sxs-lookup"><span data-stu-id="d1e14-217">Traditional transactional patterns usually rely on the database for guaranteeing the transaction.</span></span> <span data-ttu-id="d1e14-218">中間層を導入するとき、アプリケーション コードでさまざまな層のデータを正しく処理し、十分な一貫性と耐久性を維持する必要があります。</span><span class="sxs-lookup"><span data-stu-id="d1e14-218">When you introduce intermediate layers, the application code must correctly handle the data at various layers to ensure sufficient consistency and durability.</span></span>

<span data-ttu-id="d1e14-219">次のシーケンスは、トランザクション データの記録とその処理を分離するワークフローを表しています。</span><span class="sxs-lookup"><span data-stu-id="d1e14-219">The following sequence describes a workflow that separates the capture of transactional data from its processing:</span></span>

1. <span data-ttu-id="d1e14-220">Web コンピューティング ノード: 参照データを提示します。</span><span class="sxs-lookup"><span data-stu-id="d1e14-220">Web compute node: Present reference data.</span></span>
2. <span data-ttu-id="d1e14-221">外部ストレージ: 中間トランザクション データを保存します。</span><span class="sxs-lookup"><span data-stu-id="d1e14-221">External storage: Save intermediate transactional data.</span></span>
3. <span data-ttu-id="d1e14-222">Web コンピューティング ノード: エンド ユーザー トランザクションを完了します。</span><span class="sxs-lookup"><span data-stu-id="d1e14-222">Web compute node: Complete the end-user transaction.</span></span>
4. <span data-ttu-id="d1e14-223">Web コンピューティング ノード: 完了したトランザクション データを参照データ コンテキストと共に、応答が予測可能である仮の永続的なストレージに送信します。</span><span class="sxs-lookup"><span data-stu-id="d1e14-223">Web compute node: Send the completed transactional data with its reference data context to temporary durable storage that is guaranteed to give a predictable response.</span></span>
5. <span data-ttu-id="d1e14-224">Web コンピューティング ノード: トランザクションの完了をエンド ユーザーに知らせます。</span><span class="sxs-lookup"><span data-stu-id="d1e14-224">Web compute node: Signal the end-user completion of the transaction.</span></span>
6. <span data-ttu-id="d1e14-225">バックグラウンド コンピューティング ノード: トランザクション データを抽出し、必要に応じてさらに処理し、現在のシステムの最終保存場所に送信します。</span><span class="sxs-lookup"><span data-stu-id="d1e14-225">Background compute node: Extract the transactional data, process it further if necessary, and send it to its final storage location in the current system.</span></span>

<span data-ttu-id="d1e14-226">次の図は、Azure でホストされるクラウド サービスでこの設計を実装した 1 つの例です。</span><span class="sxs-lookup"><span data-stu-id="d1e14-226">The following diagram shows one possible implementation of this design in an Azure-hosted cloud service.</span></span>

![疎結合による高可用性](./images/disaster-recovery-high-availability-azure-applications/application-high-availability-through-loose-coupling.png)

<span data-ttu-id="d1e14-228">上の図の破線矢印は非同期処理を示しています。</span><span class="sxs-lookup"><span data-stu-id="d1e14-228">The dashed arrows in the preceding diagram indicate asynchronous processing.</span></span> <span data-ttu-id="d1e14-229">フロントエンドの web ロールはこの非同期処理を認識しません。</span><span class="sxs-lookup"><span data-stu-id="d1e14-229">The front-end web role is not aware of this asynchronous processing.</span></span> <span data-ttu-id="d1e14-230">結果的に、現在のシステムを参照し、最終的な目的地にトランザクションを保存します。</span><span class="sxs-lookup"><span data-stu-id="d1e14-230">This leads to the storage of the transaction at its final destination with reference to the current system.</span></span> <span data-ttu-id="d1e14-231">この非同期モデルにより導入される待ち時間に起因し、トランザクション データにすぐに照会することはできません。</span><span class="sxs-lookup"><span data-stu-id="d1e14-231">Due to the latency that this asynchronous model introduces, the transactional data is not immediately available for query.</span></span> <span data-ttu-id="d1e14-232">そのため、単位ごとのトランザクション データをキャッシュまたはユーザー セッションに保存し、目下の UI ニーズを満たす必要があります。</span><span class="sxs-lookup"><span data-stu-id="d1e14-232">Therefore, each unit of the transactional data needs to be saved in a cache or a user session to meet the immediate UI needs.</span></span>

<span data-ttu-id="d1e14-233">web ロールはインフラストラクチャの残りの部分から自立します。</span><span class="sxs-lookup"><span data-stu-id="d1e14-233">The web role is autonomous from the rest of the infrastructure.</span></span> <span data-ttu-id="d1e14-234">その可用性は Web ロールと Azure キューの組み合わせであり、インフラストラクチャ全体ではありません。</span><span class="sxs-lookup"><span data-stu-id="d1e14-234">Its availability profile is a combination of the web role and the Azure queue and not the entire infrastructure.</span></span> <span data-ttu-id="d1e14-235">高い可用性に加え、この手法では、バックエンド ストレージに関係なく、Web ロールを水平方向に拡張できます。</span><span class="sxs-lookup"><span data-stu-id="d1e14-235">In addition to high availability, this approach allows the web role to scale horizontally, independent of the back-end storage.</span></span> <span data-ttu-id="d1e14-236">この高可用性モデルは運用の経済性に影響を与える場合があります。</span><span class="sxs-lookup"><span data-stu-id="d1e14-236">This high-availability model can have an impact on the economics of operations.</span></span> <span data-ttu-id="d1e14-237">Azure キューや worker ロールなど、その他のコンポーネントは毎月の利用コストに影響を与える場合があります。</span><span class="sxs-lookup"><span data-stu-id="d1e14-237">Additional components like Azure queues and worker roles can affect monthly usage costs.</span></span>

<span data-ttu-id="d1e14-238">前の図はトランザクション データにこの疎結合手法を実装する一例に過ぎません。</span><span class="sxs-lookup"><span data-stu-id="d1e14-238">The previous diagram shows one implementation of this decoupled approach to transactional data.</span></span> <span data-ttu-id="d1e14-239">他にもさまざまな方法で実装できます。</span><span class="sxs-lookup"><span data-stu-id="d1e14-239">There are many other possible implementations.</span></span> <span data-ttu-id="d1e14-240">次は代替手法の一覧です。</span><span class="sxs-lookup"><span data-stu-id="d1e14-240">The following list provides some alternatives:</span></span>

* <span data-ttu-id="d1e14-241">worker ロールは、Web ロールとストレージ キューの間に置かれることがあります。</span><span class="sxs-lookup"><span data-stu-id="d1e14-241">A worker role might be placed between the web role and the storage queue.</span></span>
* <span data-ttu-id="d1e14-242">Service Bus キューを Azure Storage キューの代わりに使用できます。</span><span class="sxs-lookup"><span data-stu-id="d1e14-242">A Service Bus queue can be used instead of an Azure Storage queue.</span></span>
* <span data-ttu-id="d1e14-243">最終的な宛先は Azure Storage か別のデータベース プロバイダーになります。</span><span class="sxs-lookup"><span data-stu-id="d1e14-243">The final destination might be Azure Storage or a different database provider.</span></span>
* <span data-ttu-id="d1e14-244">Azure キャッシュを Web 層で利用し、トランザクションの直後にキャッシュ要件を与えることができます。</span><span class="sxs-lookup"><span data-stu-id="d1e14-244">Azure Cache can be used at the web layer to provide the immediate caching requirements after the transaction.</span></span>

### <a name="scalability-patterns"></a><span data-ttu-id="d1e14-245">拡張性パターン</span><span class="sxs-lookup"><span data-stu-id="d1e14-245">Scalability patterns</span></span>
<span data-ttu-id="d1e14-246">クラウド サービスの拡張性が可用性に直接影響を与えることにご留意ください。</span><span class="sxs-lookup"><span data-stu-id="d1e14-246">It's important to note that the scalability of a cloud service directly affects availability.</span></span> <span data-ttu-id="d1e14-247">負荷の増加が原因でサービスが応答を停止した場合、ユーザーはアプリケーションが停止したことを認識します。</span><span class="sxs-lookup"><span data-stu-id="d1e14-247">If increased load causes your service to be unresponsive, the user perception is that the application is down.</span></span> <span data-ttu-id="d1e14-248">アプリケーションに予想される負荷と将来の予想値に基づき、拡張性の実証済みのプラクティスを実行します。</span><span class="sxs-lookup"><span data-stu-id="d1e14-248">Follow proven practices for scalability based on your expected application load and future expectations.</span></span> <span data-ttu-id="d1e14-249">規模が最大になると、さまざまな事項を考慮する必要があります。1 つまたは複数のストレージ アカウント、複数のデータベースによる共有、キャッシュ方針などです。</span><span class="sxs-lookup"><span data-stu-id="d1e14-249">Maximizing scale involves many considerations, such as single versus multiple storage accounts, sharing across multiple databases, and caching strategies.</span></span> <span data-ttu-id="d1e14-250">これらのパターンについて詳しくは、「[Best practices for designing large-scale services on Microsoft Azure](https://azure.microsoft.com/blog/best-practices-for-designing-large-scale-services-on-windows-azure/)」(Microsoft Azure で大規模なサービスを設計するためのベスト プラクティス) をご覧ください。</span><span class="sxs-lookup"><span data-stu-id="d1e14-250">For in-depth information about these patterns, see [Best practices for designing large-scale services on Microsoft Azure](https://azure.microsoft.com/blog/best-practices-for-designing-large-scale-services-on-windows-azure/).</span></span>

## <a name="next-steps"></a><span data-ttu-id="d1e14-251">次の手順</span><span class="sxs-lookup"><span data-stu-id="d1e14-251">Next steps</span></span>
<span data-ttu-id="d1e14-252">このシリーズのドキュメントの内容には、Microsoft Azure 上に構築されたアプリケーションのディザスター リカバリーと高可用性が含まれます。</span><span class="sxs-lookup"><span data-stu-id="d1e14-252">This series of documents covers disaster recovery and high availability for applications built on Microsoft Azure.</span></span> <span data-ttu-id="d1e14-253">このシリーズの次の記事は、「[Disaster recovery for applications built on Microsoft Azure](disaster-recovery-azure-applications.md)」(Microsoft Azure 上で構築されたアプリケーションのディザスター リカバリー)です。</span><span class="sxs-lookup"><span data-stu-id="d1e14-253">The next article in the series is [Disaster recovery for applications built on Microsoft Azure](disaster-recovery-azure-applications.md).</span></span>

