---
title: データのパーティション分割のガイダンス
description: パーティションを個別に管理およびアクセスする方法についてのガイダンス
author: dragon119
ms.date: 07/13/2016
pnp.series.title: Best Practices
ms.openlocfilehash: d1d9c1b3cf07f724eb010fc260d86ceb84b789ca
ms.sourcegitcommit: 2e8b06e9c07875d65b91d5431bfd4bc465a7a242
ms.translationtype: HT
ms.contentlocale: ja-JP
ms.lasthandoff: 02/09/2018
---
# <a name="data-partitioning"></a><span data-ttu-id="5c841-103">データのパーティション分割</span><span class="sxs-lookup"><span data-stu-id="5c841-103">Data partitioning</span></span>

<span data-ttu-id="5c841-104">多くの大規模なソリューションでは、個別に管理およびアクセスできる複数のパーティションにデータが分割されています。</span><span class="sxs-lookup"><span data-stu-id="5c841-104">In many large-scale solutions, data is divided into separate partitions that can be managed and accessed separately.</span></span> <span data-ttu-id="5c841-105">パーティション分割戦略は、メリットを最大限に活かし、悪影響を最小限に抑えるために、入念に選択する必要があります。</span><span class="sxs-lookup"><span data-stu-id="5c841-105">The partitioning strategy must be chosen carefully to maximize the benefits while minimizing adverse effects.</span></span> <span data-ttu-id="5c841-106">パーティション分割は、拡張性を向上させ、競合を少なくし、パフォーマンスを最適化します。</span><span class="sxs-lookup"><span data-stu-id="5c841-106">Partitioning can help improve scalability, reduce contention, and optimize performance.</span></span> <span data-ttu-id="5c841-107">また、使用パターンによってデータを分割するメカニズムを提供できるというメリットもあります。</span><span class="sxs-lookup"><span data-stu-id="5c841-107">Another benefit of partitioning is that it can provide a mechanism for dividing data by the pattern of use.</span></span> <span data-ttu-id="5c841-108">たとえば、古いデータや使用頻度の低い (コールド) データを廉価なデータ ストレージにアーカイブできます。</span><span class="sxs-lookup"><span data-stu-id="5c841-108">For example, you can archive older, less active (cold) data in cheaper data storage.</span></span>

## <a name="why-partition-data"></a><span data-ttu-id="5c841-109">データをパーティション分割する理由</span><span class="sxs-lookup"><span data-stu-id="5c841-109">Why partition data?</span></span>
<span data-ttu-id="5c841-110">クラウドのほとんどのアプリケーションやサービスは、動作の一環としてデータを保存および取得します。</span><span class="sxs-lookup"><span data-stu-id="5c841-110">Most cloud applications and services store and retrieve data as part of their operations.</span></span> <span data-ttu-id="5c841-111">アプリケーションが使用するデータ ストアのデザインは、システムのパフォーマンス、スループット、および拡張性に大きく影響します。</span><span class="sxs-lookup"><span data-stu-id="5c841-111">The design of the data stores that an application uses can have a significant bearing on the performance, throughput, and scalability of a system.</span></span> <span data-ttu-id="5c841-112">大規模システムで一般的に使用されるテクニックの 1 つは、データを複数のパーティションに分割することです。</span><span class="sxs-lookup"><span data-stu-id="5c841-112">One technique that is commonly applied in large-scale systems is to divide the data into separate partitions.</span></span>

> <span data-ttu-id="5c841-113">この記事で使用されている *パーティション分割* という用語は、データを異なるデータ ストアに物理的に分割するプロセスを指します。</span><span class="sxs-lookup"><span data-stu-id="5c841-113">In this article, the term *partitioning* means the process of physically dividing data into separate data stores.</span></span> <span data-ttu-id="5c841-114">これは SQL Server テーブルのパーティション分割とは異なります。</span><span class="sxs-lookup"><span data-stu-id="5c841-114">It is not the same as SQL Server table partitioning.</span></span>

<span data-ttu-id="5c841-115">データをパーティション分割することは、さまざまなメリットをもたらします。</span><span class="sxs-lookup"><span data-stu-id="5c841-115">Partitioning data can offer a number of benefits.</span></span> <span data-ttu-id="5c841-116">たとえば、次のニーズを満たすことができます。</span><span class="sxs-lookup"><span data-stu-id="5c841-116">For example, it can be applied in order to:</span></span>

* <span data-ttu-id="5c841-117">**拡張性の向上**。</span><span class="sxs-lookup"><span data-stu-id="5c841-117">**Improve scalability**.</span></span> <span data-ttu-id="5c841-118">単一のデータベース システムをスケールアップすると、最終的には物理的なハードウェア限界に到達します。</span><span class="sxs-lookup"><span data-stu-id="5c841-118">When you scale up a single database system, it will eventually reach a physical hardware limit.</span></span> <span data-ttu-id="5c841-119">データを複数のパーティションに分割し、各パーティションを個別のサーバー上でホストした場合、システムをほとんど無制限にスケールアウトできます。</span><span class="sxs-lookup"><span data-stu-id="5c841-119">If you divide data across multiple partitions, each of which is hosted on a separate server, you can scale out the system almost indefinitely.</span></span>
* <span data-ttu-id="5c841-120">**パフォーマンスの向上**。</span><span class="sxs-lookup"><span data-stu-id="5c841-120">**Improve performance**.</span></span> <span data-ttu-id="5c841-121">各パーティションでのデータ アクセス操作は、より少量のデータに対して実行されます。</span><span class="sxs-lookup"><span data-stu-id="5c841-121">Data access operations on each partition take place over a smaller volume of data.</span></span> <span data-ttu-id="5c841-122">適切な方法でデータをパーティション分割することにより、システムの効率を高めることができます。</span><span class="sxs-lookup"><span data-stu-id="5c841-122">Provided that the data is partitioned in a suitable way, partitioning can make your system more efficient.</span></span> <span data-ttu-id="5c841-123">複数のパーティションに影響する操作は、並列に実行できます。</span><span class="sxs-lookup"><span data-stu-id="5c841-123">Operations that affect more than one partition can run in parallel.</span></span> <span data-ttu-id="5c841-124">使用するアプリケーションの近くに各パーティションを配置することで、ネットワーク遅延を最小化することができます。</span><span class="sxs-lookup"><span data-stu-id="5c841-124">Each partition can be located near the application that uses it to minimize network latency.</span></span>
* <span data-ttu-id="5c841-125">**可用性の向上**。</span><span class="sxs-lookup"><span data-stu-id="5c841-125">**Improve availability**.</span></span> <span data-ttu-id="5c841-126">データを複数のサーバーにまたがって分割することで、単一障害点を避けることができます。</span><span class="sxs-lookup"><span data-stu-id="5c841-126">Separating data across multiple servers avoids a single point of failure.</span></span> <span data-ttu-id="5c841-127">サーバーで障害が発生するか、計画的なメンテナンスが実行される場合、利用できなくなるのは、そのサーバーのパーティションに格納されているデータだけです。</span><span class="sxs-lookup"><span data-stu-id="5c841-127">If a server fails, or is undergoing planned maintenance, only the data in that partition is unavailable.</span></span> <span data-ttu-id="5c841-128">その他のパーティションでの操作は、続行できます。</span><span class="sxs-lookup"><span data-stu-id="5c841-128">Operations on other partitions can continue.</span></span> <span data-ttu-id="5c841-129">パーティションの数を増やすと、単一サーバーの障害が発生しても、利用できなくなるデータの割合は小さくなるので、相対的なインパクトを小さくすることができます。</span><span class="sxs-lookup"><span data-stu-id="5c841-129">Increasing the number of partitions reduces the relative impact of a single server failure by reducing the percentage of data that will be unavailable.</span></span> <span data-ttu-id="5c841-130">各パーティションをレプリケートすると、単一パーティション障害が運用に及ぼす影響をさらに小さくすることができます。</span><span class="sxs-lookup"><span data-stu-id="5c841-130">Replicating each partition can further reduce the chance of a single partition failure affecting operations.</span></span> <span data-ttu-id="5c841-131">また、連続的かつ高度に可用性を保つ必要のある機密データを、可用性の要件と価値の低い (ログ ファイルなどの) データから分離することができます。</span><span class="sxs-lookup"><span data-stu-id="5c841-131">It also makes it possible to separate critical data that must be continually and highly available from low-value data that has lower availability requirements (log files, for example).</span></span>
* <span data-ttu-id="5c841-132">**セキュリティの向上**。</span><span class="sxs-lookup"><span data-stu-id="5c841-132">**Improve security**.</span></span> <span data-ttu-id="5c841-133">データの特性およびパーティション分割の方法によっては、機密データと非機密データを分割して異なるパーティション、したがって異なるサーバーまたはデータ ストアに格納することが可能です。</span><span class="sxs-lookup"><span data-stu-id="5c841-133">Depending on the nature of the data and how it is partitioned, it might be possible to separate sensitive and non-sensitive data into different partitions, and therefore into different servers or data stores.</span></span> <span data-ttu-id="5c841-134">こうすることで、特に機密データに対するセキュリティを最適化することができます。</span><span class="sxs-lookup"><span data-stu-id="5c841-134">Security can then be specifically optimized for the sensitive data.</span></span>
* <span data-ttu-id="5c841-135">**運用上の柔軟性の向上**。</span><span class="sxs-lookup"><span data-stu-id="5c841-135">**Provide operational flexibility**.</span></span> <span data-ttu-id="5c841-136">パーティション分割は、運用の微調整、管理効率の最大化、およびコストの最小化を達成するための多くの機会を提供します。</span><span class="sxs-lookup"><span data-stu-id="5c841-136">Partitioning offers many opportunities for fine tuning operations, maximizing administrative efficiency, and minimizing cost.</span></span> <span data-ttu-id="5c841-137">たとえば、各パーティションのデータの重要性に基づいて、管理、監視、バックアップと復元、および他の管理タスクについて、異なる戦略を定義することができます。</span><span class="sxs-lookup"><span data-stu-id="5c841-137">For example, you can define different strategies for management, monitoring, backup and restore, and other administrative tasks based on the importance of the data in each partition.</span></span>
* <span data-ttu-id="5c841-138">**データ ストアと使用パターンの一致**。</span><span class="sxs-lookup"><span data-stu-id="5c841-138">**Match the data store to the pattern of use**.</span></span> <span data-ttu-id="5c841-139">パーティション分割では、コストとデータ ストアが提供する組み込み機能に基づいて、各パーティションを異なるタイプのデータ ストアにデプロイできます。</span><span class="sxs-lookup"><span data-stu-id="5c841-139">Partitioning allows each partition to be deployed on a different type of data store, based on cost and the built-in features that data store offers.</span></span> <span data-ttu-id="5c841-140">たとえば、大量のバイナリ データを BLOB データ ストアに格納し、構造化されたデータをドキュメント データベースに保持することができます。</span><span class="sxs-lookup"><span data-stu-id="5c841-140">For example, large binary data can be stored in a blob data store, while more structured data can be held in a document database.</span></span> <span data-ttu-id="5c841-141">詳細については、Microsoft Web サイトで提供されているパターンおよびプラクティス ガイドの「[Building a Polyglot Solution (多言語ソリューションの構築)]」および「[Data access for highly-scalable solutions: Using SQL, NoSQL, and Polyglot Persistence (拡張性の高いソリューション用のデータ アクセス: SQL、NoSQL、および Polyglot の永続化機能の使用)]」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="5c841-141">For more information, see [Building a polyglot solution] in the patterns & practices guide and [Data access for highly-scalable solutions: Using SQL, NoSQL, and polyglot persistence] on the Microsoft website.</span></span>

<span data-ttu-id="5c841-142">一部のシステムでは、メリットよりもコストの方が大きいと見なされて、パーティション分割が実装されていません。</span><span class="sxs-lookup"><span data-stu-id="5c841-142">Some systems do not implement partitioning because it is considered a cost rather than an advantage.</span></span> <span data-ttu-id="5c841-143">この論拠の一般的な理由を次に示します。</span><span class="sxs-lookup"><span data-stu-id="5c841-143">Common reasons for this rationale include:</span></span>

* <span data-ttu-id="5c841-144">多くのデータ ストレージ システムは、パーティション間にまたがる結合をサポートしません。また、パーティション化されたシステムでは参照整合性を維持することは困難になる可能性があります。</span><span class="sxs-lookup"><span data-stu-id="5c841-144">Many data storage systems do not support joins across partitions, and it can be difficult to maintain referential integrity in a partitioned system.</span></span> <span data-ttu-id="5c841-145">(パーティション分割レイヤーの) アプリケーション コードで結合や整合性チェックを頻繁に実装する必要があります。この結果、余分に I/O が発生したり、アプリケーションの複雑度が大きくなったりする可能性があります。</span><span class="sxs-lookup"><span data-stu-id="5c841-145">It is frequently necessary to implement joins and integrity checks in application code (in the partitioning layer), which can result in additional I/O and application complexity.</span></span>
* <span data-ttu-id="5c841-146">パーティションを維持する作業は、必ずしも簡単なタスクではありません。</span><span class="sxs-lookup"><span data-stu-id="5c841-146">Maintaining partitions is not always a trivial task.</span></span> <span data-ttu-id="5c841-147">データの揮発性が高いシステムでは、パーティションを定期的に再調整し、競合とホット スポットを少なくする必要があります。</span><span class="sxs-lookup"><span data-stu-id="5c841-147">In a system where the data is volatile, you might need to rebalance partitions periodically to reduce contention and hot spots.</span></span>
* <span data-ttu-id="5c841-148">一部の一般的なツールは、パーティション化されたデータに対して、そのままでは動作しません。</span><span class="sxs-lookup"><span data-stu-id="5c841-148">Some common tools do not work naturally with partitioned data.</span></span>

## <a name="designing-partitions"></a><span data-ttu-id="5c841-149">パーティションの設計</span><span class="sxs-lookup"><span data-stu-id="5c841-149">Designing partitions</span></span>
<span data-ttu-id="5c841-150">データは、水平的パーティション分割、垂直的パーティション分割、または機能的パーティション分割の方法でパーティション分割することができます。</span><span class="sxs-lookup"><span data-stu-id="5c841-150">Data can be partitioned in different ways: horizontally, vertically, or functionally.</span></span> <span data-ttu-id="5c841-151">選択する戦略は、データをパーティション分割する理由、およびデータを使用するアプリケーションとサービスの要件によって決定されます。</span><span class="sxs-lookup"><span data-stu-id="5c841-151">The strategy you choose depends on the reason for partitioning the data, and the requirements of the applications and services that will use the data.</span></span>

> [!NOTE]
> <span data-ttu-id="5c841-152">このガイダンスで取り上げられているパーティション分割構成は、基になるデータ ストレージ テクノロジに依存しない方法で説明されます。</span><span class="sxs-lookup"><span data-stu-id="5c841-152">The partitioning schemes described in this guidance are explained in a way that is independent of the underlying data storage technology.</span></span> <span data-ttu-id="5c841-153">それらの構成は、リレーショナル データベースおよび NoSQL データベースを含む多くのタイプのデータ ストアに適用できます。</span><span class="sxs-lookup"><span data-stu-id="5c841-153">They can be applied to many types of data stores, including relational and NoSQL databases.</span></span>
>
>

### <a name="partitioning-strategies"></a><span data-ttu-id="5c841-154">パーティション分割戦略</span><span class="sxs-lookup"><span data-stu-id="5c841-154">Partitioning strategies</span></span>
<span data-ttu-id="5c841-155">データをパーティション分割する際に使用される、典型的な 3 つの戦略を次に示します。</span><span class="sxs-lookup"><span data-stu-id="5c841-155">The three typical strategies for partitioning data are:</span></span>

* <span data-ttu-id="5c841-156">**水平的パーティション分割** (しばしば "*シャーディング*" と呼ばれます)。</span><span class="sxs-lookup"><span data-stu-id="5c841-156">**Horizontal partitioning** (often called *sharding*).</span></span> <span data-ttu-id="5c841-157">この戦略では、各パーティションは、自身の権限を持つデータ ストアですが、すべてのパーティションは同じスキーマを持ちます。</span><span class="sxs-lookup"><span data-stu-id="5c841-157">In this strategy, each partition is a data store in its own right, but all partitions have the same schema.</span></span> <span data-ttu-id="5c841-158">各パーティションは "*シャード*" と呼ばれ、データの特定のサブセット、たとえば、e コマース アプリケーションにおける特定の顧客グループのすべての注文などを保持します。</span><span class="sxs-lookup"><span data-stu-id="5c841-158">Each partition is known as a *shard* and holds a specific subset of the data, such as all the orders for a specific set of customers in an e-commerce application.</span></span>
* <span data-ttu-id="5c841-159">**垂直的パーティション分割**。</span><span class="sxs-lookup"><span data-stu-id="5c841-159">**Vertical partitioning**.</span></span> <span data-ttu-id="5c841-160">この戦略では、各パーティションはデータ ストアに含まれる項目のフィールドのサブセットを含みます。</span><span class="sxs-lookup"><span data-stu-id="5c841-160">In this strategy, each partition holds a subset of the fields for items in the data store.</span></span> <span data-ttu-id="5c841-161">フィールドは、それらの使用パターンに従って分割されます。</span><span class="sxs-lookup"><span data-stu-id="5c841-161">The fields are divided according to their pattern of use.</span></span> <span data-ttu-id="5c841-162">たとえば、頻繁にアクセスされるフィールドを 1 つの垂直的パーティションに、使用頻度の少ないフィールドをまとめて別の垂直的パーティションに配置します。</span><span class="sxs-lookup"><span data-stu-id="5c841-162">For example, frequently accessed fields might be placed in one vertical partition and less frequently accessed fields in another.</span></span>
* <span data-ttu-id="5c841-163">**機能的パーティション分割**。</span><span class="sxs-lookup"><span data-stu-id="5c841-163">**Functional partitioning**.</span></span> <span data-ttu-id="5c841-164">この戦略では、システム内の区分可能な各コンテキストによって使用される方法に従って、データは集約されます。</span><span class="sxs-lookup"><span data-stu-id="5c841-164">In this strategy, data is aggregated according to how it is used by each bounded context in the system.</span></span> <span data-ttu-id="5c841-165">たとえば、請求処理と製品在庫の管理用に複数の個別のビジネス機能を実装する e コマース システムでは、請求データを 1 つのパーティションに、製品在庫データを別のパーティションに格納することができます。</span><span class="sxs-lookup"><span data-stu-id="5c841-165">For example, an e-commerce system that implements separate business functions for invoicing and managing product inventory might store invoice data in one partition and product inventory data in another.</span></span>

<span data-ttu-id="5c841-166">ここで説明する 3 つの戦略は、組み合わせて使用できることに注意してください。</span><span class="sxs-lookup"><span data-stu-id="5c841-166">It’s important to note that the three strategies described here can be combined.</span></span> <span data-ttu-id="5c841-167">これらの戦略は相互に排他的ではなく、パーティション分割構成を設計する際には、これらすべてを考慮することをお勧めします。</span><span class="sxs-lookup"><span data-stu-id="5c841-167">They are not mutually exclusive, and we recommend that you consider them all when you design a partitioning scheme.</span></span> <span data-ttu-id="5c841-168">たとえば、データをシャードに分割し、次に垂直的パーティション分割を使用して、各シャード内のデータをさら分割することができます。</span><span class="sxs-lookup"><span data-stu-id="5c841-168">For example, you might divide data into shards and then use vertical partitioning to further subdivide the data in each shard.</span></span> <span data-ttu-id="5c841-169">同様に、機能的パーティション分割内のデータをシャードに分割することもできます (垂直的にパーティション分割することもできます)。</span><span class="sxs-lookup"><span data-stu-id="5c841-169">Similarly, the data in a functional partition can be split into shards (which can also be vertically partitioned).</span></span>

<span data-ttu-id="5c841-170">ただし、各戦略の異なる要件により、いくつかの競合する問題が発生することがあります。</span><span class="sxs-lookup"><span data-stu-id="5c841-170">However, the differing requirements of each strategy can raise a number of conflicting issues.</span></span> <span data-ttu-id="5c841-171">システムの全体的なデータ処理パフォーマンス目標を満たすパーティション分割構成を設計するときに、すべての戦略を評価および調整する必要があります。</span><span class="sxs-lookup"><span data-stu-id="5c841-171">You must evaluate and balance all of these when designing a partitioning scheme that meets the overall data processing performance targets for your system.</span></span> <span data-ttu-id="5c841-172">以降のセクションでは、各戦略について、さらに詳細に説明します。</span><span class="sxs-lookup"><span data-stu-id="5c841-172">The following sections explore each of the strategies in more detail.</span></span>

### <a name="horizontal-partitioning-sharding"></a><span data-ttu-id="5c841-173">水平的パーティション分割 (シャーディング)</span><span class="sxs-lookup"><span data-stu-id="5c841-173">Horizontal partitioning (sharding)</span></span>
<span data-ttu-id="5c841-174">図 1 は、水平的パーティション分割またはシャーディングの概要を示します。</span><span class="sxs-lookup"><span data-stu-id="5c841-174">Figure 1 shows an overview of horizontal partitioning or sharding.</span></span> <span data-ttu-id="5c841-175">この例では、製品在庫データが製品キーに基づいてシャードに分割されます。</span><span class="sxs-lookup"><span data-stu-id="5c841-175">In this example, product inventory data is divided into shards based on the product key.</span></span> <span data-ttu-id="5c841-176">各シャードは、シャード キーの連続する範囲 (A ～ G および H ～ Z) のデータを保持し、アルファベット順に編成されます。</span><span class="sxs-lookup"><span data-stu-id="5c841-176">Each shard holds the data for a contiguous range of shard keys (A-G and H-Z), organized alphabetically.</span></span>

![パーティション キーに基づく水平的パーティション分割 (シャーディング) データ](./images/data-partitioning/DataPartitioning01.png)

<span data-ttu-id="5c841-178">*図 1: パーティション キーに基づく水平的パーティション分割 (シャーディング) データ*</span><span class="sxs-lookup"><span data-stu-id="5c841-178">*Figure 1. Horizontally partitioning (sharding) data based on a partition key*</span></span>

<span data-ttu-id="5c841-179">シャーディングを使用して負荷をより多くのコンピューターに分散することにより、競合を少なくし、パフォーマンスを向上させることができます。</span><span class="sxs-lookup"><span data-stu-id="5c841-179">Sharding helps you spread the load over more computers, which reduces contention and improves performance.</span></span> <span data-ttu-id="5c841-180">別のサーバーで動作するシャードをさらに追加することで、システムをスケールアウトすることができます。</span><span class="sxs-lookup"><span data-stu-id="5c841-180">You can scale the system out by adding further shards that run on additional servers.</span></span>

<span data-ttu-id="5c841-181">このパーティション分割戦略を実装する場合に最も重要な要因は、シャーディング キーを選択する方法です。</span><span class="sxs-lookup"><span data-stu-id="5c841-181">The most important factor when implementing this partitioning strategy is the choice of sharding key.</span></span> <span data-ttu-id="5c841-182">システムが運用状態に移行した後にキーを変更することは、非常に困難になる可能性があります。</span><span class="sxs-lookup"><span data-stu-id="5c841-182">It can be difficult to change the key after the system is in operation.</span></span> <span data-ttu-id="5c841-183">キーは、ワークロードがシャード間で可能な限り均等になるようにデータがパーティション分割されるものである必要があります。</span><span class="sxs-lookup"><span data-stu-id="5c841-183">The key must ensure that data is partitioned so that the workload is as even as possible across the shards.</span></span>

<span data-ttu-id="5c841-184">シャード間でデータ量が同じになるようにする必要はありません。</span><span class="sxs-lookup"><span data-stu-id="5c841-184">Note that different shards do not have to contain similar volumes of data.</span></span> <span data-ttu-id="5c841-185">要求の数が均等になるようにすることの方が重要です。</span><span class="sxs-lookup"><span data-stu-id="5c841-185">Rather, the more important consideration is to balance the number of requests.</span></span> <span data-ttu-id="5c841-186">シャードにより、大量の項目が格納されていても各項目へのアクセス操作は少ないものや、</span><span class="sxs-lookup"><span data-stu-id="5c841-186">Some shards might be very large, but each item is the subject of a low number of access operations.</span></span> <span data-ttu-id="5c841-187">項目数は少なくても各項目へのアクセスは非常に頻繁に発生するものがあります。</span><span class="sxs-lookup"><span data-stu-id="5c841-187">Other shards might be smaller, but each item is accessed much more frequently.</span></span> <span data-ttu-id="5c841-188">また、単一のシャードが、シャードをホストするために使用されているデータ ストアのスケール制限を (容量と処理リソースの観点で) 超えないようにする必要があります。</span><span class="sxs-lookup"><span data-stu-id="5c841-188">It is also important to ensure that a single shard does not exceed the scale limits (in terms of capacity and processing resources) of the data store that's being used to host that shard.</span></span>

<span data-ttu-id="5c841-189">シャーディング構成を使用する場合は、パフォーマンスと可用性に影響する可能性のあるホットスポット (またはホット パーティション) が作成されないようにする必要があります。</span><span class="sxs-lookup"><span data-stu-id="5c841-189">If you use a sharding scheme, avoid creating hotspots (or hot partitions) that can affect performance and availability.</span></span> <span data-ttu-id="5c841-190">たとえば、顧客の名前の最初の文字ではなく、顧客 ID のハッシュを使用する場合は、使用頻度にばらつきのある先頭文字を使用することにより発生する不均等を防ぐことができます。</span><span class="sxs-lookup"><span data-stu-id="5c841-190">For example, if you use a hash of a customer identifier instead of the first letter of a customer’s name, you prevent the unbalanced distribution that results from common and less common initial letters.</span></span> <span data-ttu-id="5c841-191">これは、データをパーティション間で均等に分散するために役立つ典型的な手法です。</span><span class="sxs-lookup"><span data-stu-id="5c841-191">This is a typical technique that helps distribute data more evenly across partitions.</span></span>

<span data-ttu-id="5c841-192">将来、大きなシャードを小さなシャードに分割する、小さなシャードをマージして大きなシャードにする、またはシャード セットに格納されているデータを定義するスキーマを変更する、などの要件ができるだけ発生しないような、シャーディング キーを選択します。</span><span class="sxs-lookup"><span data-stu-id="5c841-192">Choose a sharding key that minimizes any future requirements to split large shards into smaller pieces, coalesce small shards into larger partitions, or change the schema that describes the data stored in a set of partitions.</span></span> <span data-ttu-id="5c841-193">これらの操作は非常に時間がかかる可能性があり、実行時に 1 つ以上のシャードをオフラインにすることが必要になる場合があります。</span><span class="sxs-lookup"><span data-stu-id="5c841-193">These operations can be very time consuming, and might require taking one or more shards offline while they are performed.</span></span>

<span data-ttu-id="5c841-194">シャードをレプリケートすると、他のシャードの分割、マージ、または再構成を行うときに、一部のレプリカをオンラインにしておくことができる場合があります。</span><span class="sxs-lookup"><span data-stu-id="5c841-194">If shards are replicated, it might be possible to keep some of the replicas online while others are split, merged, or reconfigured.</span></span> <span data-ttu-id="5c841-195">ただし、再構成が行われているときには、これらのシャードに含まれるデータ上で実行できる操作を制限することが必要になることがあります。</span><span class="sxs-lookup"><span data-stu-id="5c841-195">However, the system might need to limit the operations that can be performed on the data in these shards while the reconfiguration is taking place.</span></span> <span data-ttu-id="5c841-196">たとえば、シャードの再構成時には、レプリカのデータを読み取り専用にして、不整合の発生を防ぐことが必要になる場合があります。</span><span class="sxs-lookup"><span data-stu-id="5c841-196">For example, the data in the replicas can be marked as read-only to limit the scope of inconsistences that might occur while shards are being restructured.</span></span>

> <span data-ttu-id="5c841-197">これらの考慮事項の多くについての詳細やガイダンス、および水平的パーティション分割を実装するデータ ストアを設計するためのベスト プラクティス手法については、「 [Sharding Pattern (シャーディング パターン)]」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="5c841-197">For more detailed information and guidance about many of these considerations, and good practice techniques for designing data stores that implement horizontal partitioning, see [Sharding pattern].</span></span>
>
>

### <a name="vertical-partitioning"></a><span data-ttu-id="5c841-198">垂直的パーティション分割</span><span class="sxs-lookup"><span data-stu-id="5c841-198">Vertical partitioning</span></span>
<span data-ttu-id="5c841-199">垂直的パーティション分割を使用する最も一般的な目的は、最も頻繁にアクセスされる項目をフェッチする操作に関連する I/O とパフォーマンスのコストを削減することです。</span><span class="sxs-lookup"><span data-stu-id="5c841-199">The most common use for vertical partitioning is to reduce the I/O and performance costs associated with fetching the items that are accessed most frequently.</span></span> <span data-ttu-id="5c841-200">図 2 は、垂直的パーティション分割の例です。</span><span class="sxs-lookup"><span data-stu-id="5c841-200">Figure 2 shows an example of vertical partitioning.</span></span> <span data-ttu-id="5c841-201">この例では、各データ項目のさまざまなプロパティが異なるパーティションで保持されています。</span><span class="sxs-lookup"><span data-stu-id="5c841-201">In this example, different properties for each data item are held in different partitions.</span></span> <span data-ttu-id="5c841-202">一方のパーティションには、製品の名前、説明、価格情報といったアクセス頻度の高いデータが保持されています。</span><span class="sxs-lookup"><span data-stu-id="5c841-202">One partition holds data that is accessed more frequently, including the name, description, and price information for products.</span></span> <span data-ttu-id="5c841-203">他のパーティションには、在庫量や最終注文日が保持されています。</span><span class="sxs-lookup"><span data-stu-id="5c841-203">Another holds the volume in stock and the last ordered date.</span></span>

![使用パターンによるデータの垂直的パーティション分割](./images/data-partitioning/DataPartitioning02.png)

<span data-ttu-id="5c841-205">*図 2: 使用パターンによるデータの垂直的パーティション分割*</span><span class="sxs-lookup"><span data-stu-id="5c841-205">*Figure 2. Vertically partitioning data by its pattern of use*</span></span>

<span data-ttu-id="5c841-206">この例では、アプリケーションは、製品の詳細を顧客に表示する際は常に、製品の名前、説明、および価格をクエリします。</span><span class="sxs-lookup"><span data-stu-id="5c841-206">In this example, the application regularly queries the product name, description, and price when displaying the product details to customers.</span></span> <span data-ttu-id="5c841-207">在庫レベルおよび製造元からの最終注文日の 2 つの項目は通常一緒に使用されるので、別のパーティションに保持されています。</span><span class="sxs-lookup"><span data-stu-id="5c841-207">The stock level and date when the product was last ordered from the manufacturer are held in a separate partition because these two items are commonly used together.</span></span>

<span data-ttu-id="5c841-208">このパーティション分割構成のメリットは、変動することが比較的少ないデータ (製品の名前、説明、および価格) を、より動的なデータ (在庫レベルおよび最終注文日) から分離していることです。</span><span class="sxs-lookup"><span data-stu-id="5c841-208">This partitioning scheme has the added advantage that the relatively slow-moving data (product name, description, and price) is separated from the more dynamic data (stock level and last ordered date).</span></span> <span data-ttu-id="5c841-209">アプリケーションにとっては、変動することの少ないデータが頻繁にアクセスされる場合に、それらをメモリ上にキャッシュできるというメリットがあります。</span><span class="sxs-lookup"><span data-stu-id="5c841-209">An application might find it beneficial to cache the slow-moving data in memory if it is frequently accessed.</span></span>

<span data-ttu-id="5c841-210">このパーティション分割戦略の別の典型的なシナリオは、機密データのセキュリティを最大化することです。</span><span class="sxs-lookup"><span data-stu-id="5c841-210">Another typical scenario for this partitioning strategy is to maximize the security of sensitive data.</span></span> <span data-ttu-id="5c841-211">たとえば、クレジット カードの番号とセキュリティ コードをそれぞれ別のパーティションに格納することで、それを実現できます。</span><span class="sxs-lookup"><span data-stu-id="5c841-211">For example, you can do this by storing credit card numbers and the corresponding card security verification numbers in separate partitions.</span></span>

<span data-ttu-id="5c841-212">垂直的パーティション分割は、データに対して必要な同時アクセスの量を減らすこともできます。</span><span class="sxs-lookup"><span data-stu-id="5c841-212">Vertical partitioning can also reduce the amount of concurrent access that's needed to the data.</span></span>

> <span data-ttu-id="5c841-213">垂直的パーティション分割は、データ ストア内のエンティティ レベルで動作します。エンティティを部分的に正規化して、"*多数の*" 項目で構成されるエンティティを "*少数の*" 項目で構成される複数のエンティティに分割します。</span><span class="sxs-lookup"><span data-stu-id="5c841-213">Vertical partitioning operates at the entity level within a data store, partially normalizing an entity to break it down from a *wide* item to a set of *narrow* items.</span></span> <span data-ttu-id="5c841-214">垂直的パーティション分割は、HBase や Cassandra など、列指向のデータ ストアに理想的に適しています。</span><span class="sxs-lookup"><span data-stu-id="5c841-214">It is ideally suited for column-oriented data stores such as HBase and Cassandra.</span></span> <span data-ttu-id="5c841-215">変化する可能性が低い列コレクションのデータの場合は、SQL Server の列ストアを使用することも検討してください。</span><span class="sxs-lookup"><span data-stu-id="5c841-215">If the data in a collection of columns is unlikely to change, you can also consider using column stores in SQL Server.</span></span>
>
>

### <a name="functional-partitioning"></a><span data-ttu-id="5c841-216">機能的パーティション分割</span><span class="sxs-lookup"><span data-stu-id="5c841-216">Functional partitioning</span></span>
<span data-ttu-id="5c841-217">アプリケーションで各ビジネス エリアまたはサービスの区分のあるコンテキストを識別できる場合、機能的パーティション分割は、分離とデータ アクセスのパフォーマンスを向上する手法を提供します。</span><span class="sxs-lookup"><span data-stu-id="5c841-217">For systems where it is possible to identify a bounded context for each distinct business area or service in the application, functional partitioning provides a technique for improving isolation and data access performance.</span></span> <span data-ttu-id="5c841-218">機能的パーティション分割の別の一般的な使用法は、読み書き可能なデータをレポート目的で使用される読み取り専用データから分離することです。</span><span class="sxs-lookup"><span data-stu-id="5c841-218">Another common use of functional partitioning is to separate read-write data from read-only data that's used for reporting purposes.</span></span> <span data-ttu-id="5c841-219">図 3 は、機能的パーティション分割の概要を示しており、在庫データが顧客データから分離されています。</span><span class="sxs-lookup"><span data-stu-id="5c841-219">Figure 3 shows an overview of functional partitioning where inventory data is separated from customer data.</span></span>

![区分のあるコンテキストまたはサブドメインによりデータが分割された機能的パーティション分割](./images/data-partitioning/DataPartitioning03.png)

<span data-ttu-id="5c841-221">*図 3: 区分のあるコンテキストまたはサブドメインによりデータが分割された機能的パーティション分割*</span><span class="sxs-lookup"><span data-stu-id="5c841-221">*Figure 3. Functionally partitioning data by bounded context or subdomain*</span></span>

<span data-ttu-id="5c841-222">このパーティション分割戦略は、システムのさまざまな部分にまたがるデータ アクセスの競合を少なくするのに役立ちます。</span><span class="sxs-lookup"><span data-stu-id="5c841-222">This partitioning strategy can help reduce data access contention across different parts of a system.</span></span>

## <a name="designing-partitions-for-scalability"></a><span data-ttu-id="5c841-223">拡張性の観点でのパーティション分割の設計</span><span class="sxs-lookup"><span data-stu-id="5c841-223">Designing partitions for scalability</span></span>
<span data-ttu-id="5c841-224">各パーティションのサイズとワークロードを考慮して、それらを均等に分散することにより、最大の拡張性を達成することが重要です。</span><span class="sxs-lookup"><span data-stu-id="5c841-224">It's vital to consider size and workload for each partition and balance them so that data is distributed to achieve maximum scalability.</span></span> <span data-ttu-id="5c841-225">ただし、データのパーティションが単一のパーティション ストアの拡張制限を超えないようにすることも必要です。</span><span class="sxs-lookup"><span data-stu-id="5c841-225">However, you must also partition the data so that it does not exceed the scaling limits of a single partition store.</span></span>

<span data-ttu-id="5c841-226">拡張性の観点でパーティション分割を設計する際には、次の手順に従います。</span><span class="sxs-lookup"><span data-stu-id="5c841-226">Follow these steps when designing partitions for scalability:</span></span>

1. <span data-ttu-id="5c841-227">アプリケーションを分析して、各クエリで返される結果セットのサイズ、アクセス頻度、固有の遅延時間、サーバー側のコンピューティング処理要件など、データ アクセス パターンを理解します。</span><span class="sxs-lookup"><span data-stu-id="5c841-227">Analyze the application to understand the data access patterns, such as the size of the result set returned by each query, the frequency of access, the inherent latency, and the server-side compute processing requirements.</span></span> <span data-ttu-id="5c841-228">多くの場合、少数の主要なエンティティが最大の処理リソースを要求します。</span><span class="sxs-lookup"><span data-stu-id="5c841-228">In many cases, a few major entities will demand most of the processing resources.</span></span>
2. <span data-ttu-id="5c841-229">この分析を使用して、データ サイズやワークロードなどの現在および将来の拡張性目標を決定します。</span><span class="sxs-lookup"><span data-stu-id="5c841-229">Use this analysis to determine the current and future scalability targets, such as data size and workload.</span></span> <span data-ttu-id="5c841-230">そして、拡張性目標を満たすようにパーティション全体にデータを分散します。</span><span class="sxs-lookup"><span data-stu-id="5c841-230">Then distribute the data across the partitions to meet the scalability target.</span></span> <span data-ttu-id="5c841-231">水平的パーティション分割戦略では、均等に分散するために適切なシャード キーを選択する必要があります。</span><span class="sxs-lookup"><span data-stu-id="5c841-231">In the horizontal partitioning strategy, choosing the appropriate shard key is important to make sure distribution is even.</span></span> <span data-ttu-id="5c841-232">詳細については、「 [Sharding Pattern (シャーディング パターン)]」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="5c841-232">For more information, see the [Sharding pattern].</span></span>
3. <span data-ttu-id="5c841-233">各パーティションで利用できるリソースが、データ サイズとスループットの観点で拡張性の要件を満たすことを確認します。</span><span class="sxs-lookup"><span data-stu-id="5c841-233">Make sure that the resources available to each partition are sufficient to handle the scalability requirements in terms of data size and throughput.</span></span> <span data-ttu-id="5c841-234">たとえば、パーティションをホストしているノードで、ストレージ領域、処理能力、またはネットワーク帯域幅のサイズに関してハード面の制限があることがあります。</span><span class="sxs-lookup"><span data-stu-id="5c841-234">For example, the node that's hosting a partition might impose a hard limit on the amount of storage space, processing power, or network bandwidth that it provides.</span></span> <span data-ttu-id="5c841-235">ストレージと処理能力の要件がこれらの制限を超える可能性がある場合、パーティション分割戦略を再調整するか、データをさらに分割することが必要になることがあります。</span><span class="sxs-lookup"><span data-stu-id="5c841-235">If the data storage and processing requirements are likely to exceed these limits, it might be necessary to refine your partitioning strategy or split data out further.</span></span> <span data-ttu-id="5c841-236">たとえば、1 つの拡張性アプローチとして、ログ データを主要なアプリケーション機能から分離することがあります。</span><span class="sxs-lookup"><span data-stu-id="5c841-236">For example, one scalability approach might be to separate logging data from the core application features.</span></span> <span data-ttu-id="5c841-237">そのためには、別のデータ ストアを使用して、データ ストレージ全体での要件がノードの拡張性制限を超えないようにします。</span><span class="sxs-lookup"><span data-stu-id="5c841-237">You do this by using separate data stores to prevent the total data storage requirements from exceeding the scaling limit of the node.</span></span> <span data-ttu-id="5c841-238">データ ストアの総数がノード制限を超える場合、別のストレージ ノードを使用することが必要になる場合があります。</span><span class="sxs-lookup"><span data-stu-id="5c841-238">If the total number of data stores exceeds the node limit, it might be necessary to use separate storage nodes.</span></span>
4. <span data-ttu-id="5c841-239">使用中のシステムを監視して、データが想定どおりに分散されており、それぞれのパーティションで負荷が適切に処理されていることを検証します。</span><span class="sxs-lookup"><span data-stu-id="5c841-239">Monitor the system under use to verify that the data is distributed as expected and that the partitions can handle the load that is imposed on them.</span></span> <span data-ttu-id="5c841-240">使用状況が分析で期待されたものと一致しない場合があります。</span><span class="sxs-lookup"><span data-stu-id="5c841-240">It's possible that the usage does not match the usage that's anticipated by the analysis.</span></span> <span data-ttu-id="5c841-241">そのような場合、パーティションを再調整できることがあります。</span><span class="sxs-lookup"><span data-stu-id="5c841-241">In that case, it might be possible to rebalance the partitions.</span></span> <span data-ttu-id="5c841-242">再調整できない場合、必要とされる均等性を達成するために、システムの一部を再設計することが必要になる場合があります。</span><span class="sxs-lookup"><span data-stu-id="5c841-242">Failing that, it might be necessary to redesign some parts of the system to gain the required balance.</span></span>

<span data-ttu-id="5c841-243">クラウド環境によっては、リソースがインフラストラクチャ境界の観点で割り当てられることに注意してください。</span><span class="sxs-lookup"><span data-stu-id="5c841-243">Note that some cloud environments allocate resources in terms of infrastructure boundaries.</span></span> <span data-ttu-id="5c841-244">選択した境界の制限が、データ ストレージ、処理能力、および帯域幅の観点で、データ量の想定される成長を収容できることを確認する必要があります。</span><span class="sxs-lookup"><span data-stu-id="5c841-244">Ensure that the limits of your selected boundary provide enough room for any anticipated growth in the volume of data, in terms of data storage, processing power, and bandwidth.</span></span>

<span data-ttu-id="5c841-245">たとえば、Azure Table Storage を使用する場合、アクセス頻度の高いシャードは単一パーティションが要求を処理するために利用できるリソースよりも多くのリソースを必要とすることがあります</span><span class="sxs-lookup"><span data-stu-id="5c841-245">For example, if you use Azure table storage, a busy shard might require more resources than are available to a single partition to handle requests.</span></span> <span data-ttu-id="5c841-246">(一定期間内に単一パーティションで処理できる要求の量には制限があります。</span><span class="sxs-lookup"><span data-stu-id="5c841-246">(There is a limit to the volume of requests that can be handled by a single partition in a particular period of time.</span></span> <span data-ttu-id="5c841-247">詳細については、Microsoft Web サイトの「[Azure Storage のスケーラビリティおよびパフォーマンスのターゲット]」のページを参照してください。</span><span class="sxs-lookup"><span data-stu-id="5c841-247">See the page [Azure storage scalability and performance targets] on the Microsoft website for more details.)</span></span>

 <span data-ttu-id="5c841-248">この場合、負荷を分散するために、シャードを再パーティション分割することが必要な場合があります。</span><span class="sxs-lookup"><span data-stu-id="5c841-248">If this is the case, the shard might need to be repartitioned to spread the load.</span></span> <span data-ttu-id="5c841-249">これらのテーブルの合計サイズまたはスループットがストレージ アカウントの容量を超える場合、追加のストレージ アカウントを作成して、テーブルをそれらのアカウント全体で分散することが必要な場合があります。</span><span class="sxs-lookup"><span data-stu-id="5c841-249">If the total size or throughput of these tables exceeds the capacity of a storage account, it might be necessary to create additional storage accounts and spread the tables across these accounts.</span></span> <span data-ttu-id="5c841-250">ストレージ アカウントの数がサブスクリプションで利用できるストレージ アカウントの数を超える場合、複数のサブスクリプションを使用することが必要な場合があります。</span><span class="sxs-lookup"><span data-stu-id="5c841-250">If the number of storage accounts exceeds the number of accounts that are available to a subscription, then it might be necessary to use multiple subscriptions.</span></span>

## <a name="designing-partitions-for-query-performance"></a><span data-ttu-id="5c841-251">クエリ パフォーマンスの観点でのパーティション分割の設計</span><span class="sxs-lookup"><span data-stu-id="5c841-251">Designing partitions for query performance</span></span>
<span data-ttu-id="5c841-252">クエリのパフォーマンスは、多くの場合、小さなデータ セットを使用し、並列クエリを実行することで、格段に向上できます。</span><span class="sxs-lookup"><span data-stu-id="5c841-252">Query performance can often be boosted by using smaller data sets and by running parallel queries.</span></span> <span data-ttu-id="5c841-253">各パーティションには、データ セット全体の小さな割合を収容する必要があります。</span><span class="sxs-lookup"><span data-stu-id="5c841-253">Each partition should contain a small proportion of the entire data set.</span></span> <span data-ttu-id="5c841-254">そうすると、容量が小さくなるので、クエリのパフォーマンスが向上します。</span><span class="sxs-lookup"><span data-stu-id="5c841-254">This reduction in volume can improve the performance of queries.</span></span> <span data-ttu-id="5c841-255">ただし、パーティション分割は、データベースを適切に設計および構成することの代替にはなりません。</span><span class="sxs-lookup"><span data-stu-id="5c841-255">However, partitioning is not an alternative for designing and configuring a database appropriately.</span></span> <span data-ttu-id="5c841-256">たとえば、リレーショナル データベースを使用している場合は、必要なインデックスが構成されていることを確認します。</span><span class="sxs-lookup"><span data-stu-id="5c841-256">For example, make sure that you have the necessary indexes in place if you are using a relational database.</span></span>

<span data-ttu-id="5c841-257">クエリ パフォーマンスの観点でパーティション分割を設計する際には、次の手順に従います。</span><span class="sxs-lookup"><span data-stu-id="5c841-257">Follow these steps when designing partitions for query performance:</span></span>

1. <span data-ttu-id="5c841-258">アプリケーションの要件とパフォーマンスを検証します。</span><span class="sxs-lookup"><span data-stu-id="5c841-258">Examine the application requirements and performance:</span></span>
   * <span data-ttu-id="5c841-259">ビジネス要件を使用して、常に高速に実行する必要のある重要なクエリを決定します。</span><span class="sxs-lookup"><span data-stu-id="5c841-259">Use the business requirements to determine the critical queries that must always perform quickly.</span></span>
   * <span data-ttu-id="5c841-260">システムを監視して、低速で実行するクエリを識別します。</span><span class="sxs-lookup"><span data-stu-id="5c841-260">Monitor the system to identify any queries that perform slowly.</span></span>
   * <span data-ttu-id="5c841-261">最も頻繁に実行されるクエリを見つけます。</span><span class="sxs-lookup"><span data-stu-id="5c841-261">Establish which queries are performed most frequently.</span></span> <span data-ttu-id="5c841-262">各クエリの単一インスタンスのコストは少ない場合でも、累積されたリソース消費量は非常に大きくなる場合があります。</span><span class="sxs-lookup"><span data-stu-id="5c841-262">A single instance of each query might have minimal cost, but the cumulative consumption of resources could be significant.</span></span> <span data-ttu-id="5c841-263">これらのクエリによって取得されるデータを個別のパーティションまたはキャッシュに配置することが適切な場合があります。</span><span class="sxs-lookup"><span data-stu-id="5c841-263">It might be beneficial to separate the data that's retrieved by these queries into a distinct partition, or even a cache.</span></span>
2. <span data-ttu-id="5c841-264">パフォーマンスの低下を引き起こしているデータをパーティション分割します。</span><span class="sxs-lookup"><span data-stu-id="5c841-264">Partition the data that is causing slow performance:</span></span>
   * <span data-ttu-id="5c841-265">クエリの応答時間がターゲット時間内になるように各パーティションのサイズを制限します。</span><span class="sxs-lookup"><span data-stu-id="5c841-265">Limit the size of each partition so that the query response time is within target.</span></span>
   * <span data-ttu-id="5c841-266">水平的パーティション分割を実装しようとしている場合、アプリケーションが簡単にパーティションを見つけられるようにシャード キーを設計します。</span><span class="sxs-lookup"><span data-stu-id="5c841-266">Design the shard key so that the application can easily find the partition if you are implementing horizontal partitioning.</span></span> <span data-ttu-id="5c841-267">これにより、クエリがすべてのパーティションを通してスキャンする必要がなくなります。</span><span class="sxs-lookup"><span data-stu-id="5c841-267">This prevents the query from having to scan through every partition.</span></span>
   * <span data-ttu-id="5c841-268">パーティションの場所を検討してください。</span><span class="sxs-lookup"><span data-stu-id="5c841-268">Consider the location of a partition.</span></span> <span data-ttu-id="5c841-269">可能な限り、パーティションのデータを、それにアクセスするアプリケーションやユーザーに地理的に近い場所に維持します。</span><span class="sxs-lookup"><span data-stu-id="5c841-269">If possible, try to keep data in partitions that are geographically close to the applications and users that access it.</span></span>
3. <span data-ttu-id="5c841-270">エンティティにスループットとクエリ パフォーマンスの要件がある場合、そのエンティティに基づく機能的パーティション分割を使用します。</span><span class="sxs-lookup"><span data-stu-id="5c841-270">If an entity has throughput and query performance requirements, use functional partitioning based on that entity.</span></span> <span data-ttu-id="5c841-271">それでも要件が満たされない場合は、水平的パーティション分割も適用します。</span><span class="sxs-lookup"><span data-stu-id="5c841-271">If this still doesn't satisfy the requirements, apply horizontal partitioning as well.</span></span> <span data-ttu-id="5c841-272">ほとんどの場合、単一のパーティション分割戦略で十分ですが、両方の戦略を組み合わせて使用することが効果的な場合があります。</span><span class="sxs-lookup"><span data-stu-id="5c841-272">In most cases a single partitioning strategy will suffice, but in some cases it is more efficient to combine both strategies.</span></span>
4. <span data-ttu-id="5c841-273">パフォーマンスを向上させるために、パーティション全体で並列に実行する非同期クエリを使用することを検討します。</span><span class="sxs-lookup"><span data-stu-id="5c841-273">Consider using asynchronous queries that run in parallel across partitions to improve performance.</span></span>

## <a name="designing-partitions-for-availability"></a><span data-ttu-id="5c841-274">可用性の観点でのパーティション分割の設計</span><span class="sxs-lookup"><span data-stu-id="5c841-274">Designing partitions for availability</span></span>
<span data-ttu-id="5c841-275">データをパーティション分割すると、データセット全体が単一障害点となることはなく、またデータセットの個々のサブセットを個別に管理できるので、アプリケーションの可用性が向上します。</span><span class="sxs-lookup"><span data-stu-id="5c841-275">Partitioning data can improve the availability of applications by ensuring that the entire dataset does not constitute a single point of failure and that individual subsets of the dataset can be managed independently.</span></span> <span data-ttu-id="5c841-276">機密データを含んでいるパーティションをレプリケートすることでも、可用性を向上できます。</span><span class="sxs-lookup"><span data-stu-id="5c841-276">Replicating partitions that contain critical data can also improve availability.</span></span>

<span data-ttu-id="5c841-277">パーティションを設計および実装する際には、可用性に影響する次の要因を検討します。</span><span class="sxs-lookup"><span data-stu-id="5c841-277">When designing and implementing partitions, consider the following factors that affect availability:</span></span>

* <span data-ttu-id="5c841-278">**業務に対するデータの重要度**。</span><span class="sxs-lookup"><span data-stu-id="5c841-278">**How critical the data is to business operations**.</span></span> <span data-ttu-id="5c841-279">一部のデータは、請求書の詳細や銀行取引情報など、ビジネス上の機密情報を含むことがあります。</span><span class="sxs-lookup"><span data-stu-id="5c841-279">Some data might include critical business information such as invoice details or bank transactions.</span></span> <span data-ttu-id="5c841-280">その他のデータは、ログ ファイルやパフォーマンス トレースなど、単純に機密性の低い運用データである可能性があります。</span><span class="sxs-lookup"><span data-stu-id="5c841-280">Other data might include less critical operational data, such as log files, performance traces, and so on.</span></span> <span data-ttu-id="5c841-281">各データの種類を識別したら、次の点を考慮します。</span><span class="sxs-lookup"><span data-stu-id="5c841-281">After identifying each type of data, consider:</span></span>
  * <span data-ttu-id="5c841-282">機密データを可用性の高いパーティションに格納し、適切なバックアップ プランを構築します。</span><span class="sxs-lookup"><span data-stu-id="5c841-282">Storing critical data in highly-available partitions with an appropriate backup plan.</span></span>
  * <span data-ttu-id="5c841-283">各データセットのさまざまな重要度に応じて、個別の管理および監視のメカニズムまたは手順を確立します。</span><span class="sxs-lookup"><span data-stu-id="5c841-283">Establishing separate management and monitoring mechanisms or procedures for the different criticalities of each dataset.</span></span> <span data-ttu-id="5c841-284">同じレベルの重要度を持つデータを同じパーティションに配置して、適切な頻度で一緒にバックアップできるようにします。</span><span class="sxs-lookup"><span data-stu-id="5c841-284">Place data that has the same level of criticality in the same partition so that it can be backed up together at an appropriate frequency.</span></span> <span data-ttu-id="5c841-285">たとえば、銀行取引のデータを保持するパーティションでは、ログ情報またはトレース情報を保持するパーティションよりも頻繁にバックアップすることが必要な場合があります。</span><span class="sxs-lookup"><span data-stu-id="5c841-285">For example, partitions that hold data for bank transactions might need to be backed up more frequently than partitions that hold logging or trace information.</span></span>
* <span data-ttu-id="5c841-286">**個々のパーティションを管理する方法**。</span><span class="sxs-lookup"><span data-stu-id="5c841-286">**How individual partitions can be managed**.</span></span> <span data-ttu-id="5c841-287">個別に管理および保守ができるようにパーティションを設計すると、いくつかのメリットが生じます。</span><span class="sxs-lookup"><span data-stu-id="5c841-287">Designing partitions to support independent management and maintenance provides several advantages.</span></span> <span data-ttu-id="5c841-288">例: </span><span class="sxs-lookup"><span data-stu-id="5c841-288">For example:</span></span>
  * <span data-ttu-id="5c841-289">1 つのパーティションで障害が発生した場合、他のパーティションのデータにアクセスするアプリケーションのインスタンスに影響を及ぼすことなく、そのパーティションを個別に復旧できます。</span><span class="sxs-lookup"><span data-stu-id="5c841-289">If a partition fails, it can be recovered independently without affecting instances of applications that access data in other partitions.</span></span>
  * <span data-ttu-id="5c841-290">地理的な場所に基づいてデータをパーティション分割すると、各場所のオフピーク時間に保守タスクが実行されるようにスケジュールできます。</span><span class="sxs-lookup"><span data-stu-id="5c841-290">Partitioning data by geographical area allows scheduled maintenance tasks to occur at off-peak hours for each location.</span></span> <span data-ttu-id="5c841-291">計画された保守タスクがこの期間内に完了するように、パーティションのサイズが大きすぎないことを確認します。</span><span class="sxs-lookup"><span data-stu-id="5c841-291">Ensure that partitions are not too big to prevent any planned maintenance from being completed during this period.</span></span>
* <span data-ttu-id="5c841-292">**機密データをパーティション全体でレプリケートすることの必要性**。</span><span class="sxs-lookup"><span data-stu-id="5c841-292">**Whether to replicate critical data across partitions**.</span></span> <span data-ttu-id="5c841-293">この戦略は、可用性とパフォーマンスを向上させますが、整合性に関して問題を発生させることもあります。</span><span class="sxs-lookup"><span data-stu-id="5c841-293">This strategy can improve availability and performance, although it can also introduce consistency issues.</span></span> <span data-ttu-id="5c841-294">パーティションのデータに対して行われた変更がすべてのレプリカと同期されるには時間がかかります。</span><span class="sxs-lookup"><span data-stu-id="5c841-294">It takes time for changes made to data in a partition to be synchronized with every replica.</span></span> <span data-ttu-id="5c841-295">この期間は、さまざまなパーティションが異なるデータ値を持つ可能性があります。</span><span class="sxs-lookup"><span data-stu-id="5c841-295">During this period, different partitions will contain different data values.</span></span>

## <a name="understanding-how-partitioning-affects-design-and-development"></a><span data-ttu-id="5c841-296">設計および開発へのパーティション分割の影響</span><span class="sxs-lookup"><span data-stu-id="5c841-296">Understanding how partitioning affects design and development</span></span>
<span data-ttu-id="5c841-297">パーティション分割を使用すると、システムの設計および開発で複雑さが増大します。</span><span class="sxs-lookup"><span data-stu-id="5c841-297">Using partitioning adds complexity to the design and development of your system.</span></span> <span data-ttu-id="5c841-298">初期においてシステムが単一のパーティションのみを含んでいる場合でも、パーティション分割をシステム設計の基盤として考慮する必要があります。</span><span class="sxs-lookup"><span data-stu-id="5c841-298">Consider partitioning as a fundamental part of system design even if the system initially only contains a single partition.</span></span> <span data-ttu-id="5c841-299">システムでパフォーマンスおよび拡張性の問題が発生しだしてから、パーティション分割を付け足しで構築しようとすると、保守する必要のあるライブ システムが既に存在するので、複雑さが大きくなります。</span><span class="sxs-lookup"><span data-stu-id="5c841-299">If you address partitioning as an afterthought, when the system starts to suffer performance and scalability issues, the complexity increases because you already have a live system to maintain.</span></span>

<span data-ttu-id="5c841-300">この環境でパーティション分割に対応できるようにシステムを更新する場合、データ アクセス ロジックを変更する必要があります。</span><span class="sxs-lookup"><span data-stu-id="5c841-300">If you update the system to incorporate partitioning in this environment, it necessitates modifying the data access logic.</span></span> <span data-ttu-id="5c841-301">また、ユーザーがシステムを使い続けることができると期待している期間に、大量の既存データをパーティション全体に分散して移行する必要もあります。</span><span class="sxs-lookup"><span data-stu-id="5c841-301">It can also involve migrating large quantities of existing data to distribute it across partitions, often while users expect to be able to continue using the system.</span></span>

<span data-ttu-id="5c841-302">場合によっては、初期のデータ セットが小さく、単一サーバーで容易に処理できるので、パーティション分割は重要ではないと見なされます。</span><span class="sxs-lookup"><span data-stu-id="5c841-302">In some cases, partitioning is not considered important because the initial dataset is small and can be easily handled by a single server.</span></span> <span data-ttu-id="5c841-303">これは、システムが初期サイズを超えてスケールすることはないと想定されるシステムでは正しいですが、多くの商用システムでは、ユーザー数の増加に従って、拡張することが必要になります。</span><span class="sxs-lookup"><span data-stu-id="5c841-303">This might be true in a system that is not expected to scale beyond its initial size, but many commercial systems need to expand as the number of users increases.</span></span> <span data-ttu-id="5c841-304">この拡張は、一般的に、データ量の増加を伴います。</span><span class="sxs-lookup"><span data-stu-id="5c841-304">This expansion is typically accompanied by a growth in the volume of data.</span></span>

<span data-ttu-id="5c841-305">パーティション分割は必ずしも大規模データ ストア用の機能ではないことを理解することも重要です。</span><span class="sxs-lookup"><span data-stu-id="5c841-305">It's also important to understand that partitioning is not always a function of large data stores.</span></span> <span data-ttu-id="5c841-306">たとえば、小さなデータ ストアが数百の同時クライアントによって過度にアクセスされることがあります。</span><span class="sxs-lookup"><span data-stu-id="5c841-306">For example, a small data store might be heavily accessed by hundreds of concurrent clients.</span></span> <span data-ttu-id="5c841-307">このような状況でデータをパーティション分割すると、競合を少なくし、スループットを向上させることができます。</span><span class="sxs-lookup"><span data-stu-id="5c841-307">Partitioning the data in this situation can help to reduce contention and improve throughput.</span></span>

<span data-ttu-id="5c841-308">データパーティション分割構成を設計する際には、次の点を考慮する必要があります。</span><span class="sxs-lookup"><span data-stu-id="5c841-308">Consider the following points when you design a data partitioning scheme:</span></span>

* <span data-ttu-id="5c841-309">**可能な限り、最も頻度の高いデータベース操作で対象となるデータを各パーティションで一緒になるように配置して、パーティションをまたがるデータ アクセス操作を最小限にします**。</span><span class="sxs-lookup"><span data-stu-id="5c841-309">**Where possible, keep data for the most common database operations together in each partition to minimize cross-partition data access operations**.</span></span> <span data-ttu-id="5c841-310">パーティションをまたがるクエリは、単一パーティション内だけのクエリよりも時間がかかることがあります。また、あるクエリ セットに対してパーティションを最適化すると、別のクエリ セットが悪影響を受けることがあります。</span><span class="sxs-lookup"><span data-stu-id="5c841-310">Querying across partitions can be more time-consuming than querying only within a single partition, but optimizing partitions for one set of queries might adversely affect other sets of queries.</span></span> <span data-ttu-id="5c841-311">パーティションをまたがるクエリを回避できない場合は、並列クエリを実行することによってクエリ時間を最小限に、アプリケーション内で結果を集計します。</span><span class="sxs-lookup"><span data-stu-id="5c841-311">When you can't avoid querying across partitions, minimize query time by running parallel queries and aggregating the results within the application.</span></span> <span data-ttu-id="5c841-312">この方法は状況によっては実現できないことがあります。たとえば、あるクエリの結果を取得して、次のクエリで使用することが必要な場合です。</span><span class="sxs-lookup"><span data-stu-id="5c841-312">This approach might not be possible in some cases, such as when it's necessary to obtain a result from one query and use it in the next query.</span></span>
* <span data-ttu-id="5c841-313">**クエリで、郵便番号表や製品リストなど比較的静的な参照データが使用される場合、すべてのパーティションでこのデータをレプリケートして、それぞれのパーティションで個別の検索操作が必要にならないようにすることを検討します**。</span><span class="sxs-lookup"><span data-stu-id="5c841-313">**If queries make use of relatively static reference data, such as postal code tables or product lists, consider replicating this data in all of the partitions to reduce the requirement for separate lookup operations in different partitions**.</span></span> <span data-ttu-id="5c841-314">この方法は、参照データが、システム全体からの過度なトラフィックの対象である "ホット" データセットになる可能性も小さくします。</span><span class="sxs-lookup"><span data-stu-id="5c841-314">This approach can also reduce the likelihood of the reference data becoming a "hot" dataset that is subject to heavy traffic from across the entire system.</span></span> <span data-ttu-id="5c841-315">ただし、この参照データに対して発生する可能性のあるあらゆる変更を同期化することに伴う追加コストも発生します。</span><span class="sxs-lookup"><span data-stu-id="5c841-315">However,   there is an additional cost associated with synchronizing any changes that might occur to this reference data.</span></span>
* <span data-ttu-id="5c841-316">**可能な限り、垂直的パーティション間、および機能的パーティション間での参照整合性の要件を最小化します**。</span><span class="sxs-lookup"><span data-stu-id="5c841-316">**Where possible, minimize requirements for referential integrity across vertical and functional partitions**.</span></span> <span data-ttu-id="5c841-317">これらの構成では、データが更新および消費された場合に、パーティション間での参照整合性を、アプリケーション自体が維持する必要があります。</span><span class="sxs-lookup"><span data-stu-id="5c841-317">In these schemes, the application itself is responsible for maintaining referential integrity across partitions when data is updated and consumed.</span></span> <span data-ttu-id="5c841-318">複数のパーティション間でデータを結合する必要のあるクエリは、同一パーティション内でのみデータを結合するクエリよりも低速に実行します。これは、アプリケーションが一般的に、キーに基づいてクエリを実行し、続いて外部キーに基づいてクエリを実行する必要があるためです。</span><span class="sxs-lookup"><span data-stu-id="5c841-318">Queries that must join data across multiple partitions run more slowly than queries that join data only within the same partition because the application typically needs to perform consecutive queries based on a key and then on a foreign key.</span></span> <span data-ttu-id="5c841-319">このような状況では、パーティション分割の代わりに、関連するデータのレプリケートまたは非正規化を検討します。</span><span class="sxs-lookup"><span data-stu-id="5c841-319">Instead, consider replicating or de-normalizing the relevant data.</span></span> <span data-ttu-id="5c841-320">パーティション間結合が必要な場合にクエリ時間を最小化するには、パーティション上で並列クエリを実行し、データをアプリケーション内で結合します。</span><span class="sxs-lookup"><span data-stu-id="5c841-320">To minimize the query time where cross-partition joins are necessary, run parallel queries over the partitions and join the data within the application.</span></span>
* <span data-ttu-id="5c841-321">**パーティション分割構成がパーティション間のデータ整合性に及ぼす影響を考慮します。**</span><span class="sxs-lookup"><span data-stu-id="5c841-321">**Consider the effect that the partitioning scheme might have on the data consistency across partitions.**</span></span> <span data-ttu-id="5c841-322">強力な整合性が実際に要件であるかどうかを評価します。</span><span class="sxs-lookup"><span data-stu-id="5c841-322">Evaluate whether strong consistency is actually a requirement.</span></span> <span data-ttu-id="5c841-323">クラウドでの一般的な手法では、強力な整合性の代わりに、結果整合性を実装します。</span><span class="sxs-lookup"><span data-stu-id="5c841-323">Instead, a common approach in the cloud is to implement eventual consistency.</span></span> <span data-ttu-id="5c841-324">各パーティションのデータは個別に更新され、アプリケーションのロジックはすべての更新が正常に完了したことを確認します。</span><span class="sxs-lookup"><span data-stu-id="5c841-324">The data in each partition is updated separately, and the application logic ensures that the updates are all completed successfully.</span></span> <span data-ttu-id="5c841-325">また、結果整合性の操作が実行している間、データをクエリすることにより発生する可能性のある不整合を処理することができます。</span><span class="sxs-lookup"><span data-stu-id="5c841-325">It also handles the inconsistencies that can arise from querying data while an eventually consistent operation is running.</span></span> <span data-ttu-id="5c841-326">結果整合性を実装する方法の詳細については、「 [Data consistency primer (データ整合性入門)]」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="5c841-326">For more information about implementing eventual consistency, see the [Data consistency primer].</span></span>
* <span data-ttu-id="5c841-327">**クエリが正しいパーティションを見つける方法を考慮します**。</span><span class="sxs-lookup"><span data-stu-id="5c841-327">**Consider how queries locate the correct partition**.</span></span> <span data-ttu-id="5c841-328">必要なデータを見つけるためにクエリがすべてのパーティションをスキャンする必要がある場合、複数の並列クエリが実行中である場合でも、パフォーマンスに非常に大きな影響を及ぼします。</span><span class="sxs-lookup"><span data-stu-id="5c841-328">If a query must scan all partitions to locate the required data, there is a significant impact on performance, even when multiple parallel queries are running.</span></span> <span data-ttu-id="5c841-329">垂直的パーティション分割および機能的パーティション分割と共に使用されるクエリは、本質的にパーティションを指定できますが、</span><span class="sxs-lookup"><span data-stu-id="5c841-329">Queries that are used with vertical and functional partitioning strategies can naturally specify the partitions.</span></span> <span data-ttu-id="5c841-330">水平的パーティション分割 (シャーディング) が使用される場合、すべてのシャードが同じスキーマを持つので、項目を見つけることが困難になる可能性があります。</span><span class="sxs-lookup"><span data-stu-id="5c841-330">However, horizontal partitioning (sharding) can make locating an item difficult because every shard has the same schema.</span></span> <span data-ttu-id="5c841-331">シャーディングに対する一般的な解決法は、データの特定の項目のシャード場所を検索するために使用できるマップを維持することです。</span><span class="sxs-lookup"><span data-stu-id="5c841-331">A typical solution for sharding is to maintain a map that can be used to look up the shard location for specific items of data.</span></span> <span data-ttu-id="5c841-332">このマップは、アプリケーションのシャーディング ロジックに実装することも、データ ストアが透過的シャーディングをサポートする場合にはデータ ストアにより維持されるようにすることもできます。</span><span class="sxs-lookup"><span data-stu-id="5c841-332">This map can be implemented in the sharding logic of the application, or maintained by the data store if it supports transparent sharding.</span></span>
* <span data-ttu-id="5c841-333">**水平的パーティション分割戦略を使用する場合、シャードを定期的に再調整します**。</span><span class="sxs-lookup"><span data-stu-id="5c841-333">**When using a horizontal partitioning strategy, consider periodically rebalancing the shards**.</span></span> <span data-ttu-id="5c841-334">これにより、サイズおよびワークロードが均等になるようにデータを分散することにより、ホットスポットの最小化、クエリ パフォーマンスの最大化、および物理ストレージ制限の回避を達成します。</span><span class="sxs-lookup"><span data-stu-id="5c841-334">This helps distribute the data evenly by size and by workload to minimize hotspots, maximize query performance, and work around physical storage limitations.</span></span> <span data-ttu-id="5c841-335">ただし、これは複雑なタスクで、多くの場合、カスタム ツールまたはカスタム プロセスの使用が必要になります。</span><span class="sxs-lookup"><span data-stu-id="5c841-335">However, this is a complex task that often requires the use of a custom tool or process.</span></span>
* <span data-ttu-id="5c841-336">**各パーティションをレプリケートする場合、障害に対する保護能力が高まります**。</span><span class="sxs-lookup"><span data-stu-id="5c841-336">**If you replicate each partition, it provides additional protection against failure**.</span></span> <span data-ttu-id="5c841-337">単一のレプリカで障害が発生しても、動作しているコピーにクエリを振り向けることができます。</span><span class="sxs-lookup"><span data-stu-id="5c841-337">If a single replica fails, queries can be directed towards a working copy.</span></span>
* <span data-ttu-id="5c841-338">**パーティション分割戦略の物理制限に到達した場合、拡張性を別のレベルに拡張することが必要な場合があります**。</span><span class="sxs-lookup"><span data-stu-id="5c841-338">**If you reach the physical limits of a partitioning strategy, you might need to extend the scalability to a different level**.</span></span> <span data-ttu-id="5c841-339">たとえば、パーティション分割がデータベース レベルで行われる場合、パーティションを複数のデータベースで配置したりレプリケートしたりすることが必要になる場合があります。</span><span class="sxs-lookup"><span data-stu-id="5c841-339">For example, if partitioning is at the database level, you might need to locate or replicate partitions in multiple databases.</span></span> <span data-ttu-id="5c841-340">パーティション分割が既にデータベース レベルで行われており、物理制限が問題になっている場合、パーティションを複数のホスティング アカウントで配置したりレプリケートしたりすることが必要な可能性があります。</span><span class="sxs-lookup"><span data-stu-id="5c841-340">If partitioning is already at the database level, and physical limitations are an issue, it might mean that you need to locate or replicate partitions in multiple hosting accounts.</span></span>
* <span data-ttu-id="5c841-341">**トランザクションでは、複数のパーティションのデータにアクセスしないようにします**。</span><span class="sxs-lookup"><span data-stu-id="5c841-341">**Avoid transactions that access data in multiple partitions**.</span></span> <span data-ttu-id="5c841-342">一部のデータ ストアには、データを変更する操作に対してトランザクション レベルの一貫性と整合性を保つ機能を実装していますが、これが有効になるのは、データが単一のパーティションに配置されている場合だけです。</span><span class="sxs-lookup"><span data-stu-id="5c841-342">Some data stores implement transactional consistency and integrity for operations that modify data, but only when the data is located in a single partition.</span></span> <span data-ttu-id="5c841-343">複数のパーティションにまたがってトランザクション レベルのサポートを必要とする場合、ほとんどのパーティション分割システムでこの機能はネイティブにサポートされていないので、アプリケーション ロジックの一部として実装することが必要になる可能性があります。</span><span class="sxs-lookup"><span data-stu-id="5c841-343">If you need transactional support across multiple partitions, you will probably need to implement this as part of your application logic because most partitioning systems do not provide native support.</span></span>

<span data-ttu-id="5c841-344">すべてのデータ ストアで運用の管理および監視のアクティビティが必要です。</span><span class="sxs-lookup"><span data-stu-id="5c841-344">All data stores require some operational management and monitoring activity.</span></span> <span data-ttu-id="5c841-345">これらのタスクには、データのロード、データのバックアップおよび復元、データの再編成、システムが正しく効率よく動作していることの確認などがあります。</span><span class="sxs-lookup"><span data-stu-id="5c841-345">The tasks can range from loading data, backing up and restoring data, reorganizing data, and ensuring that the system is performing correctly and efficiently.</span></span>

<span data-ttu-id="5c841-346">運用管理に影響する次の要因を考慮してください。</span><span class="sxs-lookup"><span data-stu-id="5c841-346">Consider the following factors that affect operational management:</span></span>

* <span data-ttu-id="5c841-347">**データをパーティション分割するとき、適切な管理と運用のタスクを実装する方法**。</span><span class="sxs-lookup"><span data-stu-id="5c841-347">**How to implement appropriate management and operational tasks when the data is partitioned**.</span></span> <span data-ttu-id="5c841-348">バックアップと復元、データのアーカイブ、システムの監視、その他の管理タスクなどです。</span><span class="sxs-lookup"><span data-stu-id="5c841-348">These tasks might include backup and restore, archiving data, monitoring the system, and other administrative tasks.</span></span> <span data-ttu-id="5c841-349">たとえば、バックアップと復元の操作では論理的な一貫性を維持することが課題になります。</span><span class="sxs-lookup"><span data-stu-id="5c841-349">For example, maintaining logical consistency during backup and restore operations can be a challenge.</span></span>
* <span data-ttu-id="5c841-350">**データを複数のパーティションにロードする方法と、他のソースから到着する新しいデータを追加する方法**。</span><span class="sxs-lookup"><span data-stu-id="5c841-350">**How to load the data into multiple partitions and add new data that's arriving from other sources**.</span></span> <span data-ttu-id="5c841-351">一部のツールおよびユーティリティでは、データを正しいパーティションにロードするなど、シャード化されているデータの操作がサポートされていないことがあります。</span><span class="sxs-lookup"><span data-stu-id="5c841-351">Some tools and utilities might not support sharded data operations such as loading data into the correct partition.</span></span> <span data-ttu-id="5c841-352">このため、新しいツールおよびユーティリティの作成または取得が必要になることがあります。</span><span class="sxs-lookup"><span data-stu-id="5c841-352">This means that you might have to create or obtain new tools and utilities.</span></span>
* <span data-ttu-id="5c841-353">**定期的にデータをアーカイブして削除する方法**。</span><span class="sxs-lookup"><span data-stu-id="5c841-353">**How to archive and delete the data on a regular basis**.</span></span> <span data-ttu-id="5c841-354">パーティションの過度な成長を防止するために、定期的に (たとえば、月単位で) データをアーカイブして削除する必要があります。</span><span class="sxs-lookup"><span data-stu-id="5c841-354">To prevent the excessive growth of partitions, you need to archive and delete data on a regular basis (perhaps monthly).</span></span> <span data-ttu-id="5c841-355">異なるアーカイブ スキーマに一致するように、データを変換することが必要な場合があります。</span><span class="sxs-lookup"><span data-stu-id="5c841-355">It might be necessary to transform the data to match a different archive schema.</span></span>
* <span data-ttu-id="5c841-356">**データ整合性の問題を見つける方法**。</span><span class="sxs-lookup"><span data-stu-id="5c841-356">**How to locate data integrity issues**.</span></span> <span data-ttu-id="5c841-357">あるパーティションに存在するデータが別のパーティションに存在しない情報を参照しているなど、データ整合性の問題を見つけるプロセスを定期的に実行することを検討します。</span><span class="sxs-lookup"><span data-stu-id="5c841-357">Consider running a periodic process to locate any data integrity issues such as data in one partition that references missing information in another.</span></span> <span data-ttu-id="5c841-358">このようなプロセスでは、問題を自動的に修復するか、問題を手動で修正してもらうために、オペレーターに警告を発行するかのいずれかを実装できることがあります。</span><span class="sxs-lookup"><span data-stu-id="5c841-358">The process can either attempt to fix these issues automatically or raise an alert to an operator to correct the problems manually.</span></span> <span data-ttu-id="5c841-359">たとえば、e コマース アプリケーションでは、注文情報が 1 つのパーティションで保持されているが、各注文を構成する行項目が別のパーティションで保持されていることがあります。</span><span class="sxs-lookup"><span data-stu-id="5c841-359">For example, in an e-commerce application, order information might be held in one partition but the line items that constitute each order might be held in another.</span></span> <span data-ttu-id="5c841-360">注文を格納するプロセスは、データを両方のパーティションに追加する必要があります。</span><span class="sxs-lookup"><span data-stu-id="5c841-360">The process of placing an order needs to add data to other partitions.</span></span> <span data-ttu-id="5c841-361">このプロセスに障害が発生すると、対応する注文のない行項目が格納される可能性があります。</span><span class="sxs-lookup"><span data-stu-id="5c841-361">If this process fails, there might be line items stored for which there is no corresponding order.</span></span>

<span data-ttu-id="5c841-362">一般的に、データ ストレージ テクノロジそれぞれに、パーティション分割をサポートするための独自の機能があります。</span><span class="sxs-lookup"><span data-stu-id="5c841-362">Different data storage technologies typically provide their own features to support partitioning.</span></span> <span data-ttu-id="5c841-363">次のセクションでは、Azure アプリケーションで一般的に使用されるデータ ストアによって実装されるオプションの概要について説明します。</span><span class="sxs-lookup"><span data-stu-id="5c841-363">The following sections summarize the options that are implemented by data stores commonly used by Azure applications.</span></span> <span data-ttu-id="5c841-364">これらの機能を最大限に活用できるようにアプリケーションを設計するための考慮事項についても説明します。</span><span class="sxs-lookup"><span data-stu-id="5c841-364">They also describe considerations for designing applications that can best take advantage of these features.</span></span>

## <a name="partitioning-strategies-for-azure-sql-database"></a><span data-ttu-id="5c841-365">Azure SQL Database 用のパーティション分割戦略</span><span class="sxs-lookup"><span data-stu-id="5c841-365">Partitioning strategies for Azure SQL Database</span></span>
<span data-ttu-id="5c841-366">Azure SQL Database はクラウドで動作するサービスとしてのリレーショナル データベースです。</span><span class="sxs-lookup"><span data-stu-id="5c841-366">Azure SQL Database is a relational database-as-a-service that runs in the cloud.</span></span> <span data-ttu-id="5c841-367">Microsoft SQL Server を基盤にしています。</span><span class="sxs-lookup"><span data-stu-id="5c841-367">It is based on Microsoft SQL Server.</span></span> <span data-ttu-id="5c841-368">リレーショナル データベースでは、情報はテーブルに分割されます。各テーブルは、エンティティに関する情報を一連の行として保持します。</span><span class="sxs-lookup"><span data-stu-id="5c841-368">A relational database divides information into tables, and each table holds information about entities as a series of rows.</span></span> <span data-ttu-id="5c841-369">各行には、エンティティの個々のフィールドのデータを保持する列が含まれます。</span><span class="sxs-lookup"><span data-stu-id="5c841-369">Each row contains columns that hold the data for the individual fields of an entity.</span></span> <span data-ttu-id="5c841-370">Microsoft Web サイトの「[SQL Database とは]」のページでは、SQL データベースの作成と使用に関する詳細な資料が提供されています。</span><span class="sxs-lookup"><span data-stu-id="5c841-370">The page [What is Azure SQL Database?] on the Microsoft website provides detailed documentation about creating and using SQL databases.</span></span>

## <a name="horizontal-partitioning-with-elastic-database"></a><span data-ttu-id="5c841-371">Elastic Database での水平的パーティション分割</span><span class="sxs-lookup"><span data-stu-id="5c841-371">Horizontal partitioning with Elastic Database</span></span>
<span data-ttu-id="5c841-372">1 つの SQL データベースには保持できるデータ量に制限があります。</span><span class="sxs-lookup"><span data-stu-id="5c841-372">A single SQL database has a limit to the volume of data that it can contain.</span></span> <span data-ttu-id="5c841-373">スループットにはアーキテクチャ上の要因とアーキテクチャがサポートする同時接続数による制約があります。</span><span class="sxs-lookup"><span data-stu-id="5c841-373">Throughput is constrained by architectural factors and the number of concurrent connections that it supports.</span></span> <span data-ttu-id="5c841-374">SQL Database の Elastic Database 機能は、SQL データベースの水平スケーリングをサポートします。</span><span class="sxs-lookup"><span data-stu-id="5c841-374">The Elastic Database feature of SQL Database supports horizontal scaling for a SQL database.</span></span> <span data-ttu-id="5c841-375">Elastic Database を使用することで、複数の SQL データベースにまたがってデータをシャードにパーティション分割できます。</span><span class="sxs-lookup"><span data-stu-id="5c841-375">Using Elastic Database, you can partition your data into shards that are spread across multiple SQL databases.</span></span> <span data-ttu-id="5c841-376">また、処理する必要のあるデータ量が増加または減少する場合にシャードを追加または削除できます。</span><span class="sxs-lookup"><span data-stu-id="5c841-376">You can also add or remove shards as the volume of data that you need to handle grows and shrinks.</span></span> <span data-ttu-id="5c841-377">さらに、Elastic Database を使用して負荷をデータベース全体に分散することにより、競合を少なくすることもできます。</span><span class="sxs-lookup"><span data-stu-id="5c841-377">Using Elastic Database can also help reduce contention by distributing the load across databases.</span></span>

> [!NOTE]
> <span data-ttu-id="5c841-378">Elastic Database は、Azure SQL Database の Federations 機能に代わるものです。</span><span class="sxs-lookup"><span data-stu-id="5c841-378">Elastic Database is a replacement for the Federations feature of Azure SQL Database.</span></span> <span data-ttu-id="5c841-379">既存の SQL Database Federations のインストール環境は、Federations 移行ユーティリティを使用して Elastic Database に移行できます。</span><span class="sxs-lookup"><span data-stu-id="5c841-379">Existing SQL Database Federation installations can be migrated to Elastic Database by using the Federations migration utility.</span></span> <span data-ttu-id="5c841-380">また、Elastic Database によって提供される機能がユーザーのシナリオに本質的に適合しない場合は、独自のシャーディング メカニズムを実装することもできます。</span><span class="sxs-lookup"><span data-stu-id="5c841-380">Alternatively, you can implement your own sharding mechanism if your scenario does not lend itself naturally to the features that are provided by Elastic Database.</span></span>
>
>

<span data-ttu-id="5c841-381">各シャードは、SQL データベースとして実装されます。</span><span class="sxs-lookup"><span data-stu-id="5c841-381">Each shard is implemented as a SQL database.</span></span> <span data-ttu-id="5c841-382">1 つのシャードは、"*シャードレット*" と呼ばれる複数のデータセットを保持できます。</span><span class="sxs-lookup"><span data-stu-id="5c841-382">A shard can hold more than one dataset (referred to as a *shardlet*).</span></span> <span data-ttu-id="5c841-383">各データベースは、それが含むシャードレットを定義するメタデータを維持します。</span><span class="sxs-lookup"><span data-stu-id="5c841-383">Each database maintains metadata that describes the shardlets that it contains.</span></span> <span data-ttu-id="5c841-384">シャードレットは単一のデータ項目であることも、同じシャードレット キーを共有する項目グループであることもできます。</span><span class="sxs-lookup"><span data-stu-id="5c841-384">A shardlet can be a single data item, or it can be a group of items that share the same shardlet key.</span></span> <span data-ttu-id="5c841-385">たとえば、マルチテナント アプリケーションでデータをシャーディングしている場合、シャードレット キーをテナント ID にし、特定のテナントのすべてのデータを同じシャードレットの一部として保持することができます。</span><span class="sxs-lookup"><span data-stu-id="5c841-385">For example, if you are sharding data in a multitenant application, the shardlet key can be the tenant ID, and all data for a given tenant can be held as part of the same shardlet.</span></span> <span data-ttu-id="5c841-386">他のテナントのデータは、異なるシャードレットに保持されます。</span><span class="sxs-lookup"><span data-stu-id="5c841-386">Data for other tenants would be held in different shardlets.</span></span>

<span data-ttu-id="5c841-387">プログラマーは、データセットをシャードレット キーに関連付ける処理を実装する必要があります。</span><span class="sxs-lookup"><span data-stu-id="5c841-387">It is the programmer's responsibility to associate a dataset with a shardlet key.</span></span> <span data-ttu-id="5c841-388">個別の SQL データベースは、グローバル シャード マップ マネージャーとして機能します。</span><span class="sxs-lookup"><span data-stu-id="5c841-388">A separate SQL database acts as a global shard map manager.</span></span> <span data-ttu-id="5c841-389">このデータベースには、システム内のすべてのシャードとシャードレットの一覧が含まれています。</span><span class="sxs-lookup"><span data-stu-id="5c841-389">This database contains a list of all the shards and shardlets in the system.</span></span> <span data-ttu-id="5c841-390">データにアクセスするクライアント アプリケーションは、最初に、グローバル シャード マップ マネージャー データベースに接続し、シャード マップ (シャードとシャードレットの一覧) のコピーを取得して、ローカルにキャッシュします。</span><span class="sxs-lookup"><span data-stu-id="5c841-390">A client application that accesses data connects first to the global shard map manager database to obtain a copy of the shard map (listing shards and shardlets), which it then caches locally.</span></span>

<span data-ttu-id="5c841-391">次に、アプリケーションはこの情報を使用して、データ要求を該当するシャードに転送します。</span><span class="sxs-lookup"><span data-stu-id="5c841-391">The application then uses this information to route data requests to the appropriate shard.</span></span> <span data-ttu-id="5c841-392">この機能は、NuGet パッケージとして利用できる Azure SQL Database Elastic Database Client Library に含まれる一連の API の背後に隠されています。</span><span class="sxs-lookup"><span data-stu-id="5c841-392">This functionality is hidden behind a series of APIs that are contained in the Azure SQL Database Elastic Database Client Library, which is available as a NuGet package.</span></span> <span data-ttu-id="5c841-393">Elastic Database の包括的な情報については、Microsoft Web サイトの「 [Elastic Database の機能の概要] 」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="5c841-393">The page [Elastic Database features overview] on the Microsoft website provides a more comprehensive introduction to Elastic Database.</span></span>

> [!NOTE]
> <span data-ttu-id="5c841-394">グローバル シャード マップ マネージャー データベースをレプリケートすることにより、遅延を小さくし、可用性を向上させることができます。</span><span class="sxs-lookup"><span data-stu-id="5c841-394">You can replicate the global shard map manager database to reduce latency and improve availability.</span></span> <span data-ttu-id="5c841-395">Premium 価格レベルの 1 つを使用してデータベースを実装する場合、アクティブ geo レプリケーションを構成して、データを異なるリージョン内のデータベースに連続してコピーできます。</span><span class="sxs-lookup"><span data-stu-id="5c841-395">If you implement the database by using one of the Premium pricing tiers, you can configure active geo-replication to continuously copy data to databases in different regions.</span></span> <span data-ttu-id="5c841-396">ユーザーが存在する各リージョンにデータベースのコピーを作成します。</span><span class="sxs-lookup"><span data-stu-id="5c841-396">Create a copy of the database in each region in which users are based.</span></span> <span data-ttu-id="5c841-397">そして、このコピーに接続してシャード マップを取得するようにアプリケーションを構成します。</span><span class="sxs-lookup"><span data-stu-id="5c841-397">Then configure your application to connect to this copy to obtain the shard map.</span></span>
>
> <span data-ttu-id="5c841-398">別の方法として、Azure SQL データ同期または Azure Data Factory パイプラインを使用して、リージョン間でシャード マップ マネージャー データベースをレプリケートします。</span><span class="sxs-lookup"><span data-stu-id="5c841-398">An alternative approach is to use Azure SQL Data Sync or an Azure Data Factory pipeline to replicate the shard map manager database across regions.</span></span> <span data-ttu-id="5c841-399">この形態のレプリケーションは定期的に実行され、シャードマップの変更がまれな場合に適しています。</span><span class="sxs-lookup"><span data-stu-id="5c841-399">This form of replication runs periodically and is more suitable if the shard map changes infrequently.</span></span> <span data-ttu-id="5c841-400">さらに、シャード マップ マネージャー データベースは、Premium の価格レベルを使用して作成する必要はありません。</span><span class="sxs-lookup"><span data-stu-id="5c841-400">Additionally, the shard map manager database does not have to be created by using a Premium pricing tier.</span></span>
>
>

<span data-ttu-id="5c841-401">Elastic Database では、データをシャードレットにマップし、シャードに格納するために、2 つの構成を利用できます。</span><span class="sxs-lookup"><span data-stu-id="5c841-401">Elastic Database provides two schemes for mapping data to shardlets and storing them in shards:</span></span>

* <span data-ttu-id="5c841-402">**リスト シャード マップ** は、単一キーとシャードレットとの間の関連を定義します。</span><span class="sxs-lookup"><span data-stu-id="5c841-402">A **list shard map** describes an association between a single key and a shardlet.</span></span> <span data-ttu-id="5c841-403">たとえば、マルチテナント システムで、各テナント用のデータを一意のキーに関連付けて、独自のシャードレットに格納することができます。</span><span class="sxs-lookup"><span data-stu-id="5c841-403">For example, in a multitenant system, the data for each tenant can be associated with a unique key and stored in its own shardlet.</span></span> <span data-ttu-id="5c841-404">プライバシーと分離を保証するために (つまり、テナントが別のテナントに提供されているデータ ストレージ リソースを枯渇させないようにするために)、各シャードレットは独自のシャード内に保持できます。</span><span class="sxs-lookup"><span data-stu-id="5c841-404">To guarantee privacy and isolation (that is, to prevent one tenant from exhausting the data storage resources available to others), each shardlet can be held within its own shard.</span></span>

![リスト シャード マップを使用してテナント データを個別のシャードに格納](./images/data-partitioning/PointShardlet.png)

<span data-ttu-id="5c841-406">*図 4: リスト シャード マップを使用してテナント データを個別のシャードに格納*</span><span class="sxs-lookup"><span data-stu-id="5c841-406">*Figure 4. Using a list shard map to store tenant data in separate shards*</span></span>

* <span data-ttu-id="5c841-407">**範囲シャード マップ** は、一連の連続するキー値とシャードレットとの間の関連を定義します。</span><span class="sxs-lookup"><span data-stu-id="5c841-407">A **range shard map** describes an association between a set of contiguous key values and a shardlet.</span></span> <span data-ttu-id="5c841-408">前に取り上げたマルチテナントの例で、専用のシャードレットを実装する代わりに、それぞれに独自のキーを持つ一連のテナントのデータを、同一のシャードレット内にグループ化できます。</span><span class="sxs-lookup"><span data-stu-id="5c841-408">In the multitenant example described previously, as an alternative to implementing dedicated shardlets, you can group the data for a set of tenants (each with their own key) within the same shardlet.</span></span> <span data-ttu-id="5c841-409">この構成は、複数のテナントがデータ ストレージ リソースを共有するので、最初の構成よりも安価ですが、データのプライバシーと分離が維持できなくなるリスクもあります。</span><span class="sxs-lookup"><span data-stu-id="5c841-409">This scheme is less expensive than the first (because tenants share data storage resources), but it also creates a risk of reduced data privacy and isolation.</span></span>

![範囲シャードマップを使用してある範囲のテナントのデータを 1 つのシャードに格納](./images/data-partitioning/RangeShardlet.png)

<span data-ttu-id="5c841-411">*図 5: 範囲シャードマップを使用してある範囲のテナントのデータを 1 つのシャードに格納*</span><span class="sxs-lookup"><span data-stu-id="5c841-411">*Figure 5. Using a range shard map to store data for a range of tenants in a shard*</span></span>

<span data-ttu-id="5c841-412">単一のシャードは複数のシャードレットのデータを含むことができることに注意してください。</span><span class="sxs-lookup"><span data-stu-id="5c841-412">Note that a single shard can contain the data for several shardlets.</span></span> <span data-ttu-id="5c841-413">たとえば、リスト シャードレットを使用してさまざまな非連続テナントのデータを同一のシャードに格納できることがあります。</span><span class="sxs-lookup"><span data-stu-id="5c841-413">For example, you can use list shardlets to store data for different non-contiguous tenants in the same shard.</span></span> <span data-ttu-id="5c841-414">同一のシャード内で範囲シャードレットとリスト シャードレットを混在させることもできます。ただし、それぞれは、グローバル シャード マップ マネージャー データベースの別のマップを通してアドレス指定されます</span><span class="sxs-lookup"><span data-stu-id="5c841-414">You can also mix range shardlets and list shardlets in the same shard, although they will be addressed through different maps in the global shard map manager database.</span></span> <span data-ttu-id="5c841-415">(グローバル シャード マップ マネージャー データベースは、複数のシャード マップを含むことができます)。図 6 は、この手法を説明しています。</span><span class="sxs-lookup"><span data-stu-id="5c841-415">(The global shard map manager database can contain multiple shard maps.) Figure 6 depicts this approach.</span></span>

![複数のシャード マップの実装](./images/data-partitioning/MultipleShardMaps.png)

<span data-ttu-id="5c841-417">*図 6: 複数のシャード マップの実装*</span><span class="sxs-lookup"><span data-stu-id="5c841-417">*Figure 6. Implementing multiple shard maps*</span></span>

<span data-ttu-id="5c841-418">パーティション分割構成の実装方法によっては、システムのパフォーマンスに非常に大きな影響を与えることがあります。</span><span class="sxs-lookup"><span data-stu-id="5c841-418">The partitioning scheme that you implement can have a significant bearing on the performance of your system.</span></span> <span data-ttu-id="5c841-419">また、シャードの追加/削除の頻度、またはシャード全体でデータを再パーティション分割する必要がある頻度にも影響を及ぼします。</span><span class="sxs-lookup"><span data-stu-id="5c841-419">It can also affect the rate at which shards have to be added or removed, or the rate at which data must be repartitioned across shards.</span></span> <span data-ttu-id="5c841-420">Elastic Database を使用してデータをパーティション分割するときは、次の点を考慮する必要があります。</span><span class="sxs-lookup"><span data-stu-id="5c841-420">Consider the following points when you use Elastic Database to partition data:</span></span>

* <span data-ttu-id="5c841-421">一緒に使用されるデータを同一のシャードにグループ化し、複数のシャードに保持されているデータにアクセスする必要のある操作が発生しないようにします。</span><span class="sxs-lookup"><span data-stu-id="5c841-421">Group data that is used together in the same shard, and avoid operations that need to access data that's held in multiple shards.</span></span> <span data-ttu-id="5c841-422">Elastic Database では、シャードは独自の権限を持つ SQL データベースで、Azure SQL Database はデータベース間結合 (クライアント側で実行される必要があります) をサポートしません。</span><span class="sxs-lookup"><span data-stu-id="5c841-422">Keep in mind that with Elastic Database, a shard is a SQL database in its own right, and Azure SQL Database does not support cross-database joins (which have to be performed on the client side).</span></span> <span data-ttu-id="5c841-423">また、Azure SQL Database では、1 つのデータベース内の参照整合性制約、トリガー、およびストアド プロシージャは、別のデータベースのオブジェクトを参照できません。</span><span class="sxs-lookup"><span data-stu-id="5c841-423">Remember also that in Azure SQL Database, referential integrity constraints, triggers, and stored procedures in one database cannot reference objects in another.</span></span> <span data-ttu-id="5c841-424">このため、シャード間に依存関係のあるシステムを設計しないでください。</span><span class="sxs-lookup"><span data-stu-id="5c841-424">Therefore, don't design a system that has dependencies between shards.</span></span> <span data-ttu-id="5c841-425">ただし、SQL データベースでは、クエリや他の操作で頻繁に使用される参照データのコピーを保持するテーブルを持つことができます。</span><span class="sxs-lookup"><span data-stu-id="5c841-425">A SQL database can, however, contain tables that hold copies of reference data frequently used by queries and other operations.</span></span> <span data-ttu-id="5c841-426">これらのテーブルは、特定のシャードレットに属する必要はありません。</span><span class="sxs-lookup"><span data-stu-id="5c841-426">These tables do not have to belong to any specific shardlet.</span></span> <span data-ttu-id="5c841-427">このデータをシャード間でレプリケートすると、データベースをまたがってデータを結合する必要性をなくすことができる可能性があります。</span><span class="sxs-lookup"><span data-stu-id="5c841-427">Replicating this data across shards can help remove the need to join data that spans databases.</span></span> <span data-ttu-id="5c841-428">理想的には、そのようなデータは静的であるか移動頻度が低く、レプリケーション負荷が最小であり、無効となる機会がないものにする必要があります。</span><span class="sxs-lookup"><span data-stu-id="5c841-428">Ideally, such data should be static or slow-moving to minimize the replication effort and reduce the chances of it becoming stale.</span></span>

  > [!NOTE]
  > <span data-ttu-id="5c841-429">SQL Database はデータベース間結合をサポートしませんが、Elastic Database API を使用すると、シャード間クエリを実行できます。</span><span class="sxs-lookup"><span data-stu-id="5c841-429">Although SQL Database does not support cross-database joins, you can perform cross-shard queries with the Elastic Database API.</span></span> <span data-ttu-id="5c841-430">これらのクエリは、シャード マップにより参照されるすべてのシャードレットに保持されているデータ全体を透過的に反復処理できます。</span><span class="sxs-lookup"><span data-stu-id="5c841-430">These queries can transparently iterate through the data held in all the shardlets that are referenced by a shard map.</span></span> <span data-ttu-id="5c841-431">Elastic Database API はシャード間クエリを一連の個々のクエリ (データベースごとに 1 つずつ) に分割し、結果をマージします。</span><span class="sxs-lookup"><span data-stu-id="5c841-431">The Elastic Database API breaks cross-shard queries down into a series of individual queries (one for each database) and then merges the results.</span></span> <span data-ttu-id="5c841-432">詳細については、Microsoft Web サイトの「 [マルチシャード クエリ実行] 」のページを参照してください。</span><span class="sxs-lookup"><span data-stu-id="5c841-432">For more information, see the page [Multi-shard querying] on the Microsoft website.</span></span>
  >
  >
* <span data-ttu-id="5c841-433">同じシャードマップに属するシャードレットに格納されるデータは、同じスキーマを持つ必要があります。</span><span class="sxs-lookup"><span data-stu-id="5c841-433">The data stored in shardlets that belong to the same shard map should have the same schema.</span></span> <span data-ttu-id="5c841-434">たとえば、テナント データを含むシャードレットと製品情報を含む別のシャードレットをポイントするようなリスト シャードマップを作成しないでください。</span><span class="sxs-lookup"><span data-stu-id="5c841-434">For example, don't create a list shard map that points to some shardlets containing tenant data and other shardlets containing product information.</span></span> <span data-ttu-id="5c841-435">このルールは Elastic Database によって強制されませんが、各シャードレットに異なるスキーマが存在すると、データ管理とクエリが非常に複雑になります。</span><span class="sxs-lookup"><span data-stu-id="5c841-435">This rule is not enforced by Elastic Database, but data management and querying becomes very complex if each shardlet has a different schema.</span></span> <span data-ttu-id="5c841-436">前の例では、2 つのリスト シャード マップを作成する必要があります。1 つはテナント データを参照し、他の 1 つは製品情報を指します。</span><span class="sxs-lookup"><span data-stu-id="5c841-436">In the example just cited, a good solution is to create two list shard maps: one that references tenant data and another that points to product information.</span></span> <span data-ttu-id="5c841-437">異なるシャードレットに属するデータを、同じシャードに格納できることに注意してください。</span><span class="sxs-lookup"><span data-stu-id="5c841-437">Remember that the data belonging to different shardlets can be stored in the same shard.</span></span>

  > [!NOTE]
  > <span data-ttu-id="5c841-438">Elastic Database API のシャード間クエリ機能は、同じスキーマを含むシャード マップ内の各シャードレットに依存します。</span><span class="sxs-lookup"><span data-stu-id="5c841-438">The cross-shard query functionality of the Elastic Database API depends on each shardlet in the shard map containing the same schema.</span></span>
  >
  >
* <span data-ttu-id="5c841-439">トランザクション操作は、同一のシャード内で保持されているデータを対象にする場合にのみサポートされます。シャード間ではサポートされません。</span><span class="sxs-lookup"><span data-stu-id="5c841-439">Transactional operations are only supported for data that's held within the same shard, and not across shards.</span></span> <span data-ttu-id="5c841-440">トランザクションは、シャードレットをまたがってデータにアクセスできますが、シャードレットが同一のシャードに属する場合に限られます。</span><span class="sxs-lookup"><span data-stu-id="5c841-440">Transactions can span shardlets as long as they are part of the same shard.</span></span> <span data-ttu-id="5c841-441">このため、ビジネス ロジックがトランザクションを実行する必要がある場合、影響を受けるデータを同一のシャードに格納するか、または結果整合性を実装します。</span><span class="sxs-lookup"><span data-stu-id="5c841-441">Therefore, if your business logic needs to perform transactions, either store the affected data in the same shard or implement eventual consistency.</span></span> <span data-ttu-id="5c841-442">詳細については、「 [Data consistency primer (データ整合性入門)]。</span><span class="sxs-lookup"><span data-stu-id="5c841-442">For more information, see the [Data consistency primer].</span></span>
* <span data-ttu-id="5c841-443">シャードを、シャードのデータにアクセスするユーザーの近くに配置します (geo 配置シャード)。</span><span class="sxs-lookup"><span data-stu-id="5c841-443">Place shards close to the users that access the data in those shards (in other words, geo-locate the shards).</span></span> <span data-ttu-id="5c841-444">この戦略は、遅延を小さくするのに役立ちます。</span><span class="sxs-lookup"><span data-stu-id="5c841-444">This strategy helps reduce latency.</span></span>
* <span data-ttu-id="5c841-445">アクセス頻度の非常に高いシャード (ホットスポット) と低いシャードが混在しないようにします。</span><span class="sxs-lookup"><span data-stu-id="5c841-445">Avoid having a mixture of highly active (hotspots) and relatively inactive shards.</span></span> <span data-ttu-id="5c841-446">シャード間で負荷が均等に分散されるようにします。</span><span class="sxs-lookup"><span data-stu-id="5c841-446">Try to spread the load evenly across shards.</span></span> <span data-ttu-id="5c841-447">これを行うには、シャードレット キーをハッシュ処理することが必要になることがあります。</span><span class="sxs-lookup"><span data-stu-id="5c841-447">This might require hashing the shardlet keys.</span></span>
* <span data-ttu-id="5c841-448">geo 配置シャードを実装する場合、ハッシュ処理されたキーが、データにアクセスするユーザーの近くに格納されているシャードに保持されているシャードレットにマッピングすることを確認する必要があります。</span><span class="sxs-lookup"><span data-stu-id="5c841-448">If you are geo-locating shards, make sure that the hashed keys map to shardlets held in shards stored close to the users that access that data.</span></span>
* <span data-ttu-id="5c841-449">現在、限定された SQL データ型 (*int、bigint、varbinary*、および *uniqueidentifier*) のみがシャードレット キーとしてサポートされます。</span><span class="sxs-lookup"><span data-stu-id="5c841-449">Currently, only a limited set of SQL data types are supported as shardlet keys; *int, bigint, varbinary,* and *uniqueidentifier*.</span></span> <span data-ttu-id="5c841-450">SQL の *int* 型と *bigint* 型は C# の *int* データ型と *long* データ型に対応し、数値の範囲も同じです。</span><span class="sxs-lookup"><span data-stu-id="5c841-450">The SQL *int* and *bigint* types correspond to the *int* and *long* data types in C#, and have the same ranges.</span></span> <span data-ttu-id="5c841-451">SQL の *varbinary* 型は C# で *Byte* 配列を使用して処理することができ、SQL の *uniqueidentier* 型は、.NET Framework の *Guid* クラスに対応します。</span><span class="sxs-lookup"><span data-stu-id="5c841-451">The SQL *varbinary* type can be handled by using a *Byte* array in C#, and the SQL *uniqueidentier* type corresponds to the *Guid* class in the .NET Framework.</span></span>

<span data-ttu-id="5c841-452">名前が示すように、Elastic Database を使用すると、データ量が増加または減少するに従って、シャードを追加または削除することができます。</span><span class="sxs-lookup"><span data-stu-id="5c841-452">As the name implies, Elastic Database makes it possible for a system to add and remove shards as the volume of data shrinks and grows.</span></span> <span data-ttu-id="5c841-453">Azure SQL Database Elastic Database クライアント ライブラリの API を使用すると、アプリケーションからシャードを動的に作成および削除 (さらにはシャード マップ マネージャーを透過的に更新) できます。</span><span class="sxs-lookup"><span data-stu-id="5c841-453">The APIs in the Azure SQL Database Elastic Database client library enable an application to create and delete shards dynamically (and transparently update the shard map manager).</span></span> <span data-ttu-id="5c841-454">ただし、シャードを削除する操作は、そのシャード内のすべてのデータの削除を要求する破壊的な操作です。</span><span class="sxs-lookup"><span data-stu-id="5c841-454">However, removing a shard is a destructive operation that also requires deleting all the data in that shard.</span></span>

<span data-ttu-id="5c841-455">アプリケーションで、1 つのシャードを 2 つのシャードに分割する、または複数のシャードを 1 つのシャードにマージする必要がある場合、Elastic Database には、個別の分割マージ サービスが用意されています。</span><span class="sxs-lookup"><span data-stu-id="5c841-455">If an application needs to split a shard into two separate shards or combine shards, Elastic Database provides a separate split-merge service.</span></span> <span data-ttu-id="5c841-456">このサービスはクラウドでホストされたサービス内で動作し (開発者が作成する必要があります)、シャード間でデータを安全に移動します。</span><span class="sxs-lookup"><span data-stu-id="5c841-456">This service runs in a cloud-hosted service (which must be created by the developer) and migrates data safely between shards.</span></span> <span data-ttu-id="5c841-457">詳細については、Microsoft Web サイトで「 [Elastic Database 分割/マージ ツールを使用したスケーリング] 」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="5c841-457">For more information, see the topic [Scaling using the Elastic Database split-merge tool] on the Microsoft website.</span></span>

## <a name="partitioning-strategies-for-azure-storage"></a><span data-ttu-id="5c841-458">Azure Storage 用のパーティション分割戦略</span><span class="sxs-lookup"><span data-stu-id="5c841-458">Partitioning strategies for Azure Storage</span></span>
<span data-ttu-id="5c841-459">Azure Storage は、データを管理するための 4 つの抽象化概念を提供します。</span><span class="sxs-lookup"><span data-stu-id="5c841-459">Azure storage provides four abstractions for managing data:</span></span>

* <span data-ttu-id="5c841-460">Blob Storage は、非構造化オブジェクト データを格納します。</span><span class="sxs-lookup"><span data-stu-id="5c841-460">Blob Storage stores unstructured object data.</span></span> <span data-ttu-id="5c841-461">ドキュメント、メディア ファイル、アプリケーション インストーラーなど、任意の種類のテキスト データやバイナリ データを BLOB として保存できます。</span><span class="sxs-lookup"><span data-stu-id="5c841-461">A blob can be any type of text or binary data, such as a document, media file, or application installer.</span></span> <span data-ttu-id="5c841-462">Blob Storage は、オブジェクト ストレージとも呼ばれます。</span><span class="sxs-lookup"><span data-stu-id="5c841-462">Blob storage is also referred to as Object storage.</span></span>
* <span data-ttu-id="5c841-463">Table Storage には、構造型データセットが格納されます。</span><span class="sxs-lookup"><span data-stu-id="5c841-463">Table Storage stores structured datasets.</span></span> <span data-ttu-id="5c841-464">Table Storage は、NoSQL キー属性データ ストアであるため、開発が迅速化され、大量のデータにすばやくアクセスできます。</span><span class="sxs-lookup"><span data-stu-id="5c841-464">Table storage is a NoSQL key-attribute data store, which allows for rapid development and fast access to large quantities of data.</span></span>
* <span data-ttu-id="5c841-465">Queue Storage は、ワークフロー処理およびクラウド サービスのコンポーネント間通信のための、信頼性の高いメッセージング機能を提供します。</span><span class="sxs-lookup"><span data-stu-id="5c841-465">Queue Storage provides reliable messaging for workflow processing and for communication between components of cloud services.</span></span>
* <span data-ttu-id="5c841-466">File Storage は、標準的な SMB プロトコルを使用して、レガシ アプリケーション用の共有ストレージを提供します。</span><span class="sxs-lookup"><span data-stu-id="5c841-466">File Storage offers shared storage for legacy applications using the standard SMB protocol.</span></span> <span data-ttu-id="5c841-467">Azure の仮想マシンおよびクラウド サービスでは、マウントされている共有を介して、アプリケーション コンポーネント間でファイル データを共有できます。オンプレミスのアプリケーションでは、ファイル サービス REST API を介して、共有内のファイル データにアクセスできます。</span><span class="sxs-lookup"><span data-stu-id="5c841-467">Azure virtual machines and cloud services can share file data across application components via mounted shares, and on-premises applications can access file data in a share via the File service REST API.</span></span>

<span data-ttu-id="5c841-468">Table Storage と Blob Storage は、本質的にキー値ストアで、それぞれ構造化データおよび非構造化データを保持するように最適化されています。</span><span class="sxs-lookup"><span data-stu-id="5c841-468">Table storage and blob storage are essentially key-value stores that are optimized to hold structured and unstructured data respectively.</span></span> <span data-ttu-id="5c841-469">ストレージ キューは、疎結合で拡張性のあるアプリケーションを構築するメカニズムを提供します。</span><span class="sxs-lookup"><span data-stu-id="5c841-469">Storage queues provide a mechanism for building loosely coupled, scalable applications.</span></span> <span data-ttu-id="5c841-470">Table Storage、File Storage、Blob Storage、およびストレージ キューは、Azure ストレージ アカウントのコンテキスト内で作成されます。</span><span class="sxs-lookup"><span data-stu-id="5c841-470">Table storage, file storage, blob storage, and storage queues are created within the context of an Azure storage account.</span></span> <span data-ttu-id="5c841-471">ストレージ アカウントは、冗長性に関して 3 つの形態をサポートします。</span><span class="sxs-lookup"><span data-stu-id="5c841-471">Storage accounts support three forms of redundancy:</span></span>

* <span data-ttu-id="5c841-472">**ローカル冗長ストレージ**: 単一のデータセンター内に 3 つのデータ コピーを維持します。</span><span class="sxs-lookup"><span data-stu-id="5c841-472">**Locally redundant storage**, which maintains three copies of data within a single datacenter.</span></span> <span data-ttu-id="5c841-473">この形態の冗長性は、ハードウェア障害に対して保護を提供しますが、データセンター全体を使用不能にする災害に対しては保護を提供しません。</span><span class="sxs-lookup"><span data-stu-id="5c841-473">This form of redundancy protects against hardware failure but not against a disaster that encompasses the entire datacenter.</span></span>
* <span data-ttu-id="5c841-474">**ゾーン冗長ストレージ**: 同じリージョン内 (または地理的に近い 2 つのリージョン間) の異なるデータセンター間で 3 つのデータ コピーを維持します。</span><span class="sxs-lookup"><span data-stu-id="5c841-474">**Zone-redundant storage**, which maintains three copies of data spread across different datacenters within the same region (or across two geographically close regions).</span></span> <span data-ttu-id="5c841-475">この形態の冗長性は、単一のデータセンター内で発生する災害に対して保護を提供できますが、リージョン全体に影響する大規模なネットワーク切断に対しては保護を提供できません。</span><span class="sxs-lookup"><span data-stu-id="5c841-475">This form of redundancy can protect against disasters that occur within a single datacenter, but cannot protect against large-scale network disconnects that affect an entire region.</span></span> <span data-ttu-id="5c841-476">ゾーン冗長ストレージは、現在、ブロック BLOB に対してのみ利用できることに注意してください。</span><span class="sxs-lookup"><span data-stu-id="5c841-476">Note that zone-redundant storage is currently only available for block blobs.</span></span>
* <span data-ttu-id="5c841-477">**geo 冗長ストレージ**: 6 つのデータ コピーを維持します。3 つのコピーを 1 つのリージョン (ローカル リージョン) に、別の 3 つのコピーをリモート リージョンに維持します。</span><span class="sxs-lookup"><span data-stu-id="5c841-477">**Geo-redundant storage**, which maintains six copies of data: three copies in one region (your local region), and another three copies in a remote region.</span></span> <span data-ttu-id="5c841-478">この形態の冗長性は、災害に対する最高レベルの保護を提供します。</span><span class="sxs-lookup"><span data-stu-id="5c841-478">This form of redundancy provides the highest level of disaster protection.</span></span>

<span data-ttu-id="5c841-479">Microsoft は、Azure Storage の拡張性ターゲットを公表しています。</span><span class="sxs-lookup"><span data-stu-id="5c841-479">Microsoft has published scalability targets for Azure Storage.</span></span> <span data-ttu-id="5c841-480">詳細については、Microsoft Web サイトの「 [Azure Storage scalability and performance targets] 」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="5c841-480">For more information, see the page [Azure Storage scalability and performance targets] on the Microsoft website.</span></span> <span data-ttu-id="5c841-481">現在、ストレージ アカウントの総容量は、500 TB を超えることはできません</span><span class="sxs-lookup"><span data-stu-id="5c841-481">Currently, the total storage account capacity cannot exceed 500 TB.</span></span> <span data-ttu-id="5c841-482">(これには、Table Storage、File Storage、および Blob Storage に保持されているデータのサイズと、ストレージ キューに保持されている未処理のメッセージのサイズが含まれます)。</span><span class="sxs-lookup"><span data-stu-id="5c841-482">(This includes the size of data that's held in table storage, file storage and blob storage, as well as outstanding messages that are held in storage queue).</span></span>

<span data-ttu-id="5c841-483">ストレージ アカウント (1 KB エンティティ、BLOB、またはメッセージのサイズを想定) に対する要求の最大レートは、1 秒あたり 20,000 要求です。</span><span class="sxs-lookup"><span data-stu-id="5c841-483">The maximum request rate for a storage account (assuming a 1-KB entity, blob, or message size) is 20,000 requests per second.</span></span> <span data-ttu-id="5c841-484">ストレージ アカウントの最大値は、ファイル共有あたり 1000 IOPS (8 KB のサイズ) です。</span><span class="sxs-lookup"><span data-stu-id="5c841-484">A storage account has a maximum of 1000 IOPS (8 KB in size) per file share.</span></span> <span data-ttu-id="5c841-485">システムでこれらの制限を超えることが想定される場合は、負荷を複数のストレージ アカウント間でパーティション分割することを検討します。</span><span class="sxs-lookup"><span data-stu-id="5c841-485">If your system is likely to exceed these limits, consider partitioning the load across multiple storage accounts.</span></span> <span data-ttu-id="5c841-486">Azure サブスクリプションあたり、最大 200 ストレージ アカウントを作成できます。</span><span class="sxs-lookup"><span data-stu-id="5c841-486">A single Azure subscription can create up to 200 storage accounts.</span></span> <span data-ttu-id="5c841-487">ただし、これらの制限は将来変更される可能性があることに注意してください。</span><span class="sxs-lookup"><span data-stu-id="5c841-487">However, note that these limits might change over time.</span></span>

## <a name="partitioning-azure-table-storage"></a><span data-ttu-id="5c841-488">Azure Table Storage のパーティション分割</span><span class="sxs-lookup"><span data-stu-id="5c841-488">Partitioning Azure table storage</span></span>
<span data-ttu-id="5c841-489">Azure Table Storage は、パーティション分割に対応するように設計されたキーと値のストアです。</span><span class="sxs-lookup"><span data-stu-id="5c841-489">Azure table storage is a key-value store that's designed around partitioning.</span></span> <span data-ttu-id="5c841-490">すべてのエンティティは、パーティションに格納され、パーティションは Azure Table Storage によって内部的に管理されます。</span><span class="sxs-lookup"><span data-stu-id="5c841-490">All entities are stored in a partition, and partitions are managed internally by Azure table storage.</span></span> <span data-ttu-id="5c841-491">テーブルに格納される各エンティティは、次のものを含む 2 つの部分で構成されるキーを提供する必要があります。</span><span class="sxs-lookup"><span data-stu-id="5c841-491">Each entity that's stored in a table must provide a two-part key that includes:</span></span>

* <span data-ttu-id="5c841-492">**パーティション キー**。</span><span class="sxs-lookup"><span data-stu-id="5c841-492">**The partition key**.</span></span> <span data-ttu-id="5c841-493">これは文字列値で、Azure Table Storage がこのエンティティを配置するパーティションを決定するために使用されます。</span><span class="sxs-lookup"><span data-stu-id="5c841-493">This is a string value that determines in which partition Azure table storage will place the entity.</span></span> <span data-ttu-id="5c841-494">同じパーティション キーを持つすべてのエンティティは、同じパーティションに格納されます。</span><span class="sxs-lookup"><span data-stu-id="5c841-494">All entities with the same partition key will be stored in the same partition.</span></span>
* <span data-ttu-id="5c841-495">**行キー**。</span><span class="sxs-lookup"><span data-stu-id="5c841-495">**The row key**.</span></span> <span data-ttu-id="5c841-496">これは別の文字列値で、パーティション内のエンティティを識別します。</span><span class="sxs-lookup"><span data-stu-id="5c841-496">This is another string value that identifies the entity within the partition.</span></span> <span data-ttu-id="5c841-497">パーティション内のすべてのエンティティは、このキーの昇順で辞書的に並び替えられます。</span><span class="sxs-lookup"><span data-stu-id="5c841-497">All entities within a partition are sorted lexically, in ascending order, by this key.</span></span> <span data-ttu-id="5c841-498">パーティション キーと行キーの組み合わせは、各エンティティで一意になる必要があり、1 KB の長さを超えることはできません。</span><span class="sxs-lookup"><span data-stu-id="5c841-498">The partition key/row key combination must be unique for each entity and cannot exceed 1 KB in length.</span></span>

<span data-ttu-id="5c841-499">エンティティのデータの残りの部分は、アプリケーションで定義されたフィールドで構成されます。</span><span class="sxs-lookup"><span data-stu-id="5c841-499">The remainder of the data for an entity consists of application-defined fields.</span></span> <span data-ttu-id="5c841-500">特定のスキーマが強制されることはありません。各行は、異なるセットのアプリケーションで定義されたフィールドを持つことができます。</span><span class="sxs-lookup"><span data-stu-id="5c841-500">No particular schemas are enforced, and each row can contain a different set of application-defined fields.</span></span> <span data-ttu-id="5c841-501">唯一の制限は、エンティティのパーティション キーと行キーを含む最大サイズで、現在は 1 MB です。</span><span class="sxs-lookup"><span data-stu-id="5c841-501">The only limitation is that the maximum size of an entity (including the partition and row keys) is currently 1 MB.</span></span> <span data-ttu-id="5c841-502">テーブルの最大サイズは 200 TB です。ただし、これらの値は、将来変更される可能性があります。</span><span class="sxs-lookup"><span data-stu-id="5c841-502">The maximum size of a table is 200 TB, although these figures might change in the future.</span></span> <span data-ttu-id="5c841-503">これらの制限に関する最新の情報については、Microsoft Web サイトの「[Azure Storage のスケーラビリティおよびパフォーマンスのターゲット]」のページを参照してください。</span><span class="sxs-lookup"><span data-stu-id="5c841-503">(Check the page [Azure Storage scalability and performance targets] on the Microsoft website for the most recent information about these limits.)</span></span>

<span data-ttu-id="5c841-504">この容量を超えるエンティティを格納する必要がある場合、複数のテーブルに分割することを検討します。</span><span class="sxs-lookup"><span data-stu-id="5c841-504">If you are attempting to store entities that exceed this capacity, then consider splitting them into multiple tables.</span></span> <span data-ttu-id="5c841-505">垂直的パーティション分割を使用し、フィールドを最も一緒にアクセスされる頻度の高いグループに分割します。</span><span class="sxs-lookup"><span data-stu-id="5c841-505">Use vertical partitioning to divide the fields into the groups that are most likely to be accessed together.</span></span>

<span data-ttu-id="5c841-506">図 7 に、架空の e コマース アプリケーションのサンプル ストレージ アカウント (Contoso Data) の論理構造を示します。</span><span class="sxs-lookup"><span data-stu-id="5c841-506">Figure 7 shows the logical structure of an example storage account (Contoso Data) for a fictitious e-commerce application.</span></span> <span data-ttu-id="5c841-507">このストレージ アカウントは、3 つのテーブル (Customer Info、Product Info、および Order Info) を含みます</span><span class="sxs-lookup"><span data-stu-id="5c841-507">The storage account contains three tables: Customer Info, Product Info, and Order Info.</span></span> <span data-ttu-id="5c841-508">各テーブルには複数のパーティションがあります。</span><span class="sxs-lookup"><span data-stu-id="5c841-508">Each table has multiple partitions.</span></span>

<span data-ttu-id="5c841-509">Customer Info テーブルでは、データは顧客の所在地の市に従ってパーティション分割され、行キーには顧客 ID が含まれます。</span><span class="sxs-lookup"><span data-stu-id="5c841-509">In the Customer Info table, the data is partitioned according to the city in which the customer is located, and the row key contains the customer ID.</span></span> <span data-ttu-id="5c841-510">Product Info テーブルでは、製品が製品カテゴリによってパーティション分割され、行キーには製品番号が含まれます。</span><span class="sxs-lookup"><span data-stu-id="5c841-510">In the Product Info table, the products are partitioned by product category, and the row key contains the product number.</span></span> <span data-ttu-id="5c841-511">Order Info テーブルでは、注文が注文日によってパーティション分割され、行キーには、注文が受信された時刻が指定されます。</span><span class="sxs-lookup"><span data-stu-id="5c841-511">In the Order Info table, the orders are partitioned by the date on which they were placed, and the row key specifies the time the order was received.</span></span> <span data-ttu-id="5c841-512">すべてのデータは、各パーティションで行キーの順に並べられることに注意してください。</span><span class="sxs-lookup"><span data-stu-id="5c841-512">Note that all data is ordered by the row key in each partition.</span></span>

![サンプル ストレージ アカウントのテーブルとパーティション](./images/data-partitioning/TableStorage.png)

<span data-ttu-id="5c841-514">*図 7: サンプル ストレージ アカウントのテーブルとパーティション*</span><span class="sxs-lookup"><span data-stu-id="5c841-514">*Figure 7. The tables and partitions in an example storage account*</span></span>

> [!NOTE]
> <span data-ttu-id="5c841-515">Azure Table Storage は、各エンティティにタイムスタンプ フィールドも追加します。</span><span class="sxs-lookup"><span data-stu-id="5c841-515">Azure table storage also adds a timestamp field to each entity.</span></span> <span data-ttu-id="5c841-516">タイムスタンプ フィールドは Table Storage により維持され、エンティティが変更されるごとに更新されて、パーティションに書き戻されます。</span><span class="sxs-lookup"><span data-stu-id="5c841-516">The timestamp field is maintained by table storage and is updated each time the entity is modified and written back to a partition.</span></span> <span data-ttu-id="5c841-517">Table Storage サービスはこのフィールドを使用して、緩やかな同時アクセス制御を実装します(アプリケーションがエンティティを Table Storage に書き戻すごとに、Table Storage サービスは、書き込まれるエンティティのタイムスタンプの値と Table Storage に保持されている値を比較します。</span><span class="sxs-lookup"><span data-stu-id="5c841-517">The table storage service uses this field to implement optimistic concurrency.</span></span> <span data-ttu-id="5c841-518">異なる場合は、エンティティの取得後に別のアプリケーションがエンティティを変更していると判断され、書き込み操作は失敗します)。</span><span class="sxs-lookup"><span data-stu-id="5c841-518">(Each time an application writes an entity back to table storage, the table storage service compares the value of the timestamp in the entity that's being written with the value that's held in table storage.</span></span> <span data-ttu-id="5c841-519">アプリケーションのコードでこのフィールドを変更しないでください。</span><span class="sxs-lookup"><span data-stu-id="5c841-519">If the values are different, it means that another application must have modified the entity since it was last retrieved, and the write operation fails.</span></span> <span data-ttu-id="5c841-520">また、新しいエンティティを作成するときに、このフィールド用の値を指定しないでください。</span><span class="sxs-lookup"><span data-stu-id="5c841-520">Don't modify this field in your own code, and don't specify a value for this field when you create a new entity.</span></span>
>
>

<span data-ttu-id="5c841-521">Azure Table Storage は、パーティション キーを使用して、データを格納する方法を決定します。</span><span class="sxs-lookup"><span data-stu-id="5c841-521">Azure table storage uses the partition key to determine how to store the data.</span></span> <span data-ttu-id="5c841-522">以前に使用されていないパーティション キーを使用してエンティティがテーブルに追加される場合、Azure Table Storage はこのエンティティ用に新しいパーティションを作成します。</span><span class="sxs-lookup"><span data-stu-id="5c841-522">If an entity is added to a table with a previously unused partition key, Azure table storage creates a new partition for this entity.</span></span> <span data-ttu-id="5c841-523">同じパーティション キーを持つ別のエンティティは、同じパーティションに格納されます。</span><span class="sxs-lookup"><span data-stu-id="5c841-523">Other entities with the same partition key will be stored in the same partition.</span></span>

<span data-ttu-id="5c841-524">このメカニズムは、自動スケールアウト戦略を効果的に実装します。</span><span class="sxs-lookup"><span data-stu-id="5c841-524">This mechanism effectively implements an automatic scale-out strategy.</span></span> <span data-ttu-id="5c841-525">各パーティションは、単一パーティションからデータを取得するクエリが高速に実行できるようにするために、Azure データセンターの単一サーバーに格納されます。</span><span class="sxs-lookup"><span data-stu-id="5c841-525">Each partition is stored on a single server in an Azure datacenter to help ensure that queries that retrieve data from a single partition run quickly.</span></span> <span data-ttu-id="5c841-526">ただし、それぞれのパーティションは、複数のサーバー間で分散して格納することができます。</span><span class="sxs-lookup"><span data-stu-id="5c841-526">However, different partitions can be distributed across multiple servers.</span></span> <span data-ttu-id="5c841-527">また、単一のサーバーが複数のパーティションをホストすることもできます (これらのパーティションにサイズの制限がある場合)。</span><span class="sxs-lookup"><span data-stu-id="5c841-527">Additionally, a single server can host multiple partitions if these partitions are limited in size.</span></span>

<span data-ttu-id="5c841-528">Azure Table Storage 用にエンティティを設計する際には、次の点を考慮する必要があります。</span><span class="sxs-lookup"><span data-stu-id="5c841-528">Consider the following points when you design your entities for Azure table storage:</span></span>

* <span data-ttu-id="5c841-529">パーティション キーと行キーの値を選択する際には、データがアクセスされる方法に主眼を置く必要があります。</span><span class="sxs-lookup"><span data-stu-id="5c841-529">The selection of partition key and row key values should be driven by the way in which the data is accessed.</span></span> <span data-ttu-id="5c841-530">パーティション キーと行キーの組み合わせは、クエリの大半をサポートするように選択する必要があります。</span><span class="sxs-lookup"><span data-stu-id="5c841-530">Choose a partition key/row key combination that supports the majority of your queries.</span></span> <span data-ttu-id="5c841-531">最も効率的にクエリを実行するには、パーティション キーと行キーを指定してデータを取得します。</span><span class="sxs-lookup"><span data-stu-id="5c841-531">The most efficient queries retrieve data by specifying the partition key and the row key.</span></span> <span data-ttu-id="5c841-532">パーティション キーと行キーの範囲を指定するクエリは、単一のパーティションをスキャンすることによって完了できます。</span><span class="sxs-lookup"><span data-stu-id="5c841-532">Queries that specify a partition key and a range of row keys can be completed by scanning a single partition.</span></span> <span data-ttu-id="5c841-533">データは行キーの順序で並んでいるため、このクエリは比較的高速に実行されます。</span><span class="sxs-lookup"><span data-stu-id="5c841-533">This is relatively fast because the data is held in row key order.</span></span> <span data-ttu-id="5c841-534">クエリでスキャンするパーティションが指定されていない場合、パーティション キーは Azure Table Storage にすべてのパーティションでデータをスキャンするよう要求する可能性があります。</span><span class="sxs-lookup"><span data-stu-id="5c841-534">If queries don't specify which partition to scan, the partition key might require Azure table storage to scan every partition for your data.</span></span>

  > [!TIP]
  > <span data-ttu-id="5c841-535">エンティティにナチュラル キーが含まれている場合、それをパーティション キーとして使用し、空の文字列を行キーとして指定します。</span><span class="sxs-lookup"><span data-stu-id="5c841-535">If an entity has one natural key, then use it as the partition key and specify an empty string as the row key.</span></span> <span data-ttu-id="5c841-536">エンティティに 2 つのプロパティで構成される複合キーがある場合、変化の少ない方のプロパティをパーティション キーとして選択し、別のプロパティを行キーとして指定します。</span><span class="sxs-lookup"><span data-stu-id="5c841-536">If an entity has a composite key comprising two properties, select the slowest changing property as the partition key and the other as the row key.</span></span> <span data-ttu-id="5c841-537">エンティティに 3 つ以上のキー プロパティがある場合、プロパティの連結を使用して、パーティション キーと行キーを指定します。</span><span class="sxs-lookup"><span data-stu-id="5c841-537">If an entity has more than two key properties, use a concatenation of properties to provide the partition and row keys.</span></span>
  >
  >
* <span data-ttu-id="5c841-538">パーティション キーおよび行キー以外のフィールドを使用してデータを検索するクエリを定期的に実行する場合、 [インデックス テーブル パターン]を使用することを検討します。</span><span class="sxs-lookup"><span data-stu-id="5c841-538">If you regularly perform queries that look up data by using fields other than the partition and row keys, consider implementing the [index table pattern].</span></span>
* <span data-ttu-id="5c841-539">単純に増加または減少する数列 ("0001"、"0002"、"0003"、など) を使用してパーティション キーを生成する場合で、各パーティションには少量のデータしか含まれない場合、Azure Table Storage は、これらのパーティションを物理的にグループ化して、同一のサーバーに配置することがあります。</span><span class="sxs-lookup"><span data-stu-id="5c841-539">If you generate partition keys by using a monotonic increasing or decreasing sequence (such as "0001", "0002", "0003", and so on) and each partition only contains a limited amount of data, then Azure table storage can physically group these partitions together on the same server.</span></span> <span data-ttu-id="5c841-540">このメカニズムでは、アプリケーションはパーティションの連続した範囲を対象にするクエリ (範囲クエリ) を実行する可能性が最も高く、このようにすることで最適化されると想定します。</span><span class="sxs-lookup"><span data-stu-id="5c841-540">This mechanism assumes that the application is most likely to perform queries across a contiguous range of partitions (range queries) and is optimized for this case.</span></span> <span data-ttu-id="5c841-541">ただし、この手法は、新しいエンティティのすべての挿入操作が連続する範囲の 1 つの末尾または別の末尾に集中する可能性があるので、単一サーバー上にホットスポットを発生させる可能性があります。</span><span class="sxs-lookup"><span data-stu-id="5c841-541">However, this approach can lead to hotspots focused on a single server because all insertions of new entities are likely to be concentrated at one end or the other of the contiguous ranges.</span></span> <span data-ttu-id="5c841-542">また、拡張性が損なわれる可能性もあります。</span><span class="sxs-lookup"><span data-stu-id="5c841-542">It can also reduce scalability.</span></span> <span data-ttu-id="5c841-543">サーバー間で負荷をさらに均等に分散するために、パーティション キーをハッシュ処理して、数列をさらにランダム化することを検討します。</span><span class="sxs-lookup"><span data-stu-id="5c841-543">To spread the load more evenly across servers, consider hashing the partition key to make the sequence more random.</span></span>
* <span data-ttu-id="5c841-544">Azure Table Storage は、同一パーティションに属するエンティティに対するトランザクション操作をサポートします。</span><span class="sxs-lookup"><span data-stu-id="5c841-544">Azure table storage supports transactional operations for entities that belong to the same partition.</span></span> <span data-ttu-id="5c841-545">これは、アプリケーションが、複数の挿入、更新、削除、置換、またはマージの操作を 1 つのアトミック単位として実行できることを意味します (トランザクションに含まれるエントリが 100 個以下で、要求のペイロードが 4 MB を超えない場合)。</span><span class="sxs-lookup"><span data-stu-id="5c841-545">This means that an application can perform multiple insert, update, delete, replace, or merge operations as an atomic unit (as long as the transaction doesn't include more than 100 entities and the payload of the request doesn't exceed 4 MB).</span></span> <span data-ttu-id="5c841-546">複数のパーティションにまたがる操作はトランザクションとしてはサポートされません。また、「[Data consistency primer (データ整合性入門)]」で説明されている最終的整合性を実装することが必要になることがあります。</span><span class="sxs-lookup"><span data-stu-id="5c841-546">Operations that span multiple partitions are not transactional, and might require you to implement eventual consistency as described by the [Data consistency primer].</span></span> <span data-ttu-id="5c841-547">Table Storage とトランザクションの詳細については、Microsoft Web サイトの「[Performing Entity Group Transactions (エンティティ グループ トランザクションの実行)]」のページを参照してください。</span><span class="sxs-lookup"><span data-stu-id="5c841-547">For more information about table storage and transactions, go to the page [Performing entity group transactions] on the Microsoft website.</span></span>
* <span data-ttu-id="5c841-548">パーティション キーの粒度については、入念に注意を払ってください。以下はその理由です。</span><span class="sxs-lookup"><span data-stu-id="5c841-548">Give careful attention to the granularity of the partition key because of the following reasons:</span></span>
  * <span data-ttu-id="5c841-549">すべてのエンティティで同じパーティション キーを使用すると、Table Storage サービスにより、1 つのサーバー上に保持される単一の大きなパーティションが作成されます。</span><span class="sxs-lookup"><span data-stu-id="5c841-549">Using the same partition key for every entity causes the table storage service to create a single large partition that's held on one server.</span></span> <span data-ttu-id="5c841-550">これにより、スケールアウトが機能しなくなり、負荷が単一のサーバーに集中します。</span><span class="sxs-lookup"><span data-stu-id="5c841-550">This prevents it from scaling out and instead focuses the load on a single server.</span></span> <span data-ttu-id="5c841-551">結論として、この手法が適しているのは、少量のエンティティを管理するシステムだけです。</span><span class="sxs-lookup"><span data-stu-id="5c841-551">As a result, this approach is only suitable for systems that manage a small number of entities.</span></span> <span data-ttu-id="5c841-552">ただし、この手法では、すべてのエンティティをエンティティ グループ トランザクションの対象にすることができます。</span><span class="sxs-lookup"><span data-stu-id="5c841-552">However, this approach does ensure that all entities can participate in entity group transactions.</span></span>
  * <span data-ttu-id="5c841-553">各エンティティに対して一意のパーティション キーを使用すると、Table Storage サービスにより、エンティティごとに異なるパーティションが作成され、結果として、エンティティのサイズに依存して小さなパーティションが大量に作成される可能性があります。</span><span class="sxs-lookup"><span data-stu-id="5c841-553">Using a unique partition key for every entity causes the table storage service to create a separate partition for each entity, possibly resulting in a large number of small partitions (depending on the size of the entities).</span></span> <span data-ttu-id="5c841-554">この手法は、単一パーティション キーの手法よりも拡張性に優れていますが、エンティティ グループ トランザクションは使用できません。</span><span class="sxs-lookup"><span data-stu-id="5c841-554">This approach is more scalable than using a single partition key, but entity group transactions are not possible.</span></span> <span data-ttu-id="5c841-555">また、複数のエンティティをフェッチするクエリが複数のサーバーからの読み込みを実行する可能性があります。</span><span class="sxs-lookup"><span data-stu-id="5c841-555">Also, queries that fetch more than one entity might involve reading from more than one server.</span></span> <span data-ttu-id="5c841-556">ただし、アプリケーションが範囲クエリを実行し、単純数列を使用してパーティション キーを生成すると、これらのクエリが最適化される可能性があります。</span><span class="sxs-lookup"><span data-stu-id="5c841-556">However, if the application performs range queries, then using a monotonic sequence to generate the partition keys might help to optimize these queries.</span></span>
  * <span data-ttu-id="5c841-557">エンティティのサブセット間でパーティション キーを共有すると、関連するエンティティをグループ化して同一のパーティションに格納できます。</span><span class="sxs-lookup"><span data-stu-id="5c841-557">Sharing the partition key across a subset of entities makes it possible for you to group related entities in the same partition.</span></span> <span data-ttu-id="5c841-558">関連するエンティティにアクセスする操作は、エンティティ グループ トランザクションを使用して実行でき、一連の関連するエンティティをフェッチするクエリは単一サーバーにアクセスするだけで結果が返される可能性があります。</span><span class="sxs-lookup"><span data-stu-id="5c841-558">Operations that involve related entities can be performed by using entity group transactions, and queries that fetch a set of related entities can be satisfied by accessing a single server.</span></span>

<span data-ttu-id="5c841-559">Azure Table Storage でデータをパーティション分割する方法の詳細については、Microsoft Web サイトの記事「 [Azure Storage テーブルの設計ガイド] 」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="5c841-559">For additional information about partitioning data in Azure table storage, see the article [Azure storage table design guide] on the Microsoft website.</span></span>

## <a name="partitioning-azure-blob-storage"></a><span data-ttu-id="5c841-560">Azure Blob Storage のパーティション分割</span><span class="sxs-lookup"><span data-stu-id="5c841-560">Partitioning Azure blob storage</span></span>
<span data-ttu-id="5c841-561">Azure Blob Storage を使用すると、大きなバイナリ オブジェクトを保持できます。現時点でのオブジェクトの最大サイズは、ブロック BLOB で 5 TB、ページ BLOB で 1 TB です。</span><span class="sxs-lookup"><span data-stu-id="5c841-561">Azure blob storage makes it possible to hold large binary objects--currently up to 5 TB in size for block blobs or 1 TB for page blobs.</span></span> <span data-ttu-id="5c841-562">最新の情報については、Microsoft Web サイトの「[Azure Storage のスケーラビリティおよびパフォーマンスのターゲット]」のページを参照してください。大量のデータを高速にアップロードまたはダウンロードする必要があるストリーミングのようなシナリオでは、ブロック BLOB を使用します。</span><span class="sxs-lookup"><span data-stu-id="5c841-562">(For the most recent information, go to the page [Azure Storage scalability and performance targets] on the Microsoft website.) Use block blobs in scenarios such as streaming where you need to upload or download large volumes of data quickly.</span></span> <span data-ttu-id="5c841-563">データの一部への順次アクセスではなくランダム アクセスを必要とするアプリケーションでは、ページ BLOB を使用します。</span><span class="sxs-lookup"><span data-stu-id="5c841-563">Use page blobs for applications that require random rather than serial access to parts of the data.</span></span>

<span data-ttu-id="5c841-564">ブロック BLOB とページ BLOB のいずれも、Azure ストレージ アカウントのコンテナーに保持されます。</span><span class="sxs-lookup"><span data-stu-id="5c841-564">Each blob (either block or page) is held in a container in an Azure storage account.</span></span> <span data-ttu-id="5c841-565">コンテナーを使用することにより、同じセキュリティ要件を持つ関連する BLOB をグループ化することができます。</span><span class="sxs-lookup"><span data-stu-id="5c841-565">You can use containers to group related blobs that have the same security requirements.</span></span> <span data-ttu-id="5c841-566">このグループ化は、物理的ではなく、論理的です。</span><span class="sxs-lookup"><span data-stu-id="5c841-566">This grouping is logical rather than physical.</span></span> <span data-ttu-id="5c841-567">コンテナー内では、各 BLOB は一意の名前を持ちます。</span><span class="sxs-lookup"><span data-stu-id="5c841-567">Inside a container, each blob has a unique name.</span></span>

<span data-ttu-id="5c841-568">BLOB のパーティション キーは、アカウント名とコンテナー名と BLOB 名を組み合わせたものです。</span><span class="sxs-lookup"><span data-stu-id="5c841-568">The partition key for a blob is account name + container name + blob name.</span></span> <span data-ttu-id="5c841-569">つまり、BLOB への負荷からの要求に応じて、各 BLOB は独自のパーティションを持つことができます。</span><span class="sxs-lookup"><span data-stu-id="5c841-569">This means each blob can have its own partition if load on the blob demands it.</span></span> <span data-ttu-id="5c841-570">BLOB は、アクセスをスケールアウトするために多数のサーバーに分散させることができますが、1 つの BLOB を処理できるのは 1 台のサーバーのみです。</span><span class="sxs-lookup"><span data-stu-id="5c841-570">Blobs can be distributed across many servers in order to scale out access to them, but a single blob can only be served by a single server.</span></span> 

<span data-ttu-id="5c841-571">単一のブロック (ブロック BLOB) またはページ (ページ BLOB) を書き込む操作はアトミックですが、複数のブロック、ページ、または BLOB にまたがる操作はアトミックではありません。</span><span class="sxs-lookup"><span data-stu-id="5c841-571">The actions of writing a single block (block blob) or page (page blob) are atomic, but operations that span blocks, pages, or blobs are not.</span></span> <span data-ttu-id="5c841-572">複数のブロック、ページ、または BLOB にまたがる書き込み操作の実行中に一貫性を確保するには、BLOB リースを使用して書き込みロックを取得する必要があります。</span><span class="sxs-lookup"><span data-stu-id="5c841-572">If you need to ensure consistency when performing write operations across blocks, pages, and blobs, take out a write lock by using a blob lease.</span></span>

<span data-ttu-id="5c841-573">Azure Blob Storage は、最大 60 MB/秒の転送速度、または各 BLOB に対して最大 500/秒の要求をサポートします。</span><span class="sxs-lookup"><span data-stu-id="5c841-573">Azure blob storage targets transfer rates of up to 60 MB per second or 500 requests per second for each blob.</span></span> <span data-ttu-id="5c841-574">これらの制限を超えることが予想され、BLOB データが比較的静的である場合、Azure Content Delivery Network を使用して BLOB をレプリケートすることを検討します。</span><span class="sxs-lookup"><span data-stu-id="5c841-574">If you anticipate surpassing these limits, and the blob data is relatively static, then consider replicating blobs by using the Azure Content Delivery Network.</span></span> <span data-ttu-id="5c841-575">詳細については、Microsoft Web サイトの [Azure Content Delivery Network] に関するページを参照してください。</span><span class="sxs-lookup"><span data-stu-id="5c841-575">For more information, see the page [Azure Content Delivery Network] on the Microsoft website.</span></span> <span data-ttu-id="5c841-576">その他のガイダンスと考慮事項については、[Azure Content Delivery Network の使用]に関する記事を参照してください。</span><span class="sxs-lookup"><span data-stu-id="5c841-576">For additional guidance and considerations, see [Using Azure Content Delivery Network].</span></span>

## <a name="partitioning-azure-storage-queues"></a><span data-ttu-id="5c841-577">Azure ストレージ キューのパーティション分割</span><span class="sxs-lookup"><span data-stu-id="5c841-577">Partitioning Azure storage queues</span></span>
<span data-ttu-id="5c841-578">Azure ストレージ キューを使用すると、プロセス間の非同期メッセージ処理を実装できます。</span><span class="sxs-lookup"><span data-stu-id="5c841-578">Azure storage queues enable you to implement asynchronous messaging between processes.</span></span> <span data-ttu-id="5c841-579">Azure ストレージ アカウントは任意の数のキューを含むことができ、各キューは任意の数のメッセージを含むことができます。</span><span class="sxs-lookup"><span data-stu-id="5c841-579">An Azure storage account can contain any number of queues, and each queue can contain any number of messages.</span></span> <span data-ttu-id="5c841-580">唯一の制限は、ストレージ アカウントで利用できる領域です。</span><span class="sxs-lookup"><span data-stu-id="5c841-580">The only limitation is the space that's available in the storage account.</span></span> <span data-ttu-id="5c841-581">個々のメッセージの最大サイズは、64 KB です。</span><span class="sxs-lookup"><span data-stu-id="5c841-581">The maximum size of an individual message is 64 KB.</span></span> <span data-ttu-id="5c841-582">このサイズよりも大きいメッセージを必要とする場合は、代わりに Azure Service Bus キューの使用を検討します。</span><span class="sxs-lookup"><span data-stu-id="5c841-582">If you require messages bigger than this, then consider using Azure Service Bus queues instead.</span></span>

<span data-ttu-id="5c841-583">各ストレージ キューは、それを含むストレージ アカウント内で一意の名前を持ちます。</span><span class="sxs-lookup"><span data-stu-id="5c841-583">Each storage queue has a unique name within the storage account that contains it.</span></span> <span data-ttu-id="5c841-584">Azure はこの名前に基づいてキューをパーティション分割します。</span><span class="sxs-lookup"><span data-stu-id="5c841-584">Azure partitions queues based on the name.</span></span> <span data-ttu-id="5c841-585">同じキューのすべてのメッセージは同一のパーティションに格納され、単一のサーバーにより制御されます。</span><span class="sxs-lookup"><span data-stu-id="5c841-585">All messages for the same queue are stored in the same partition, which is controlled by a single server.</span></span> <span data-ttu-id="5c841-586">負荷を均等化するために、キューごとに異なるサーバーで管理することができます。</span><span class="sxs-lookup"><span data-stu-id="5c841-586">Different queues can be managed by different servers to help balance the load.</span></span> <span data-ttu-id="5c841-587">サーバーへのキューの割り当ては、アプリケーションおよびユーザーにとって透過的です。</span><span class="sxs-lookup"><span data-stu-id="5c841-587">The allocation of queues to servers is transparent to applications and users.</span></span>

 <span data-ttu-id="5c841-588">大規模なアプリケーションでは、アプリケーションのすべてのインスタンスに対して同一のストレージ キューを使用しないでください。この手法では、キューをホストするサーバーがホットスポットになる可能性があるためです。</span><span class="sxs-lookup"><span data-stu-id="5c841-588">In a large-scale application, don't use the same storage queue for all instances of the application because this approach might cause the server that's hosting the queue to become a hotspot.</span></span> <span data-ttu-id="5c841-589">代わりに、アプリケーションの機能分野ごとに異なるキューを使用してください。</span><span class="sxs-lookup"><span data-stu-id="5c841-589">Instead, use different queues for different functional areas of the application.</span></span> <span data-ttu-id="5c841-590">Azure ストレージ キューはトランザクションをサポートしません。このため、メッセージを別のキューに転送することは、メッセージ処理の一貫性にほとんど影響を与えません。</span><span class="sxs-lookup"><span data-stu-id="5c841-590">Azure storage queues do not support transactions, so directing messages to different queues should have little impact on messaging consistency.</span></span>

<span data-ttu-id="5c841-591">Azure ストレージ キューは、最大 2,000 メッセージ/秒を処理できます。</span><span class="sxs-lookup"><span data-stu-id="5c841-591">An Azure storage queue can handle up to 2,000 messages per second.</span></span>  <span data-ttu-id="5c841-592">これよりも多いメッセージを処理する必要がある場合、複数のキューを作成することを検討します。</span><span class="sxs-lookup"><span data-stu-id="5c841-592">If you need to process messages at a greater rate than this, consider creating multiple queues.</span></span> <span data-ttu-id="5c841-593">たとえば、グローバル アプリケーションで、複数のストレージ アカウントのそれぞれにストレージ キューを作成し、各リージョンで動作するアプリケーション インスタンスを処理します。</span><span class="sxs-lookup"><span data-stu-id="5c841-593">For example, in a global application, create separate storage queues in separate storage accounts to handle application instances that are running in each region.</span></span>

## <a name="partitioning-strategies-for-azure-service-bus"></a><span data-ttu-id="5c841-594">Azure Service Bus 用のパーティション分割戦略</span><span class="sxs-lookup"><span data-stu-id="5c841-594">Partitioning strategies for Azure Service Bus</span></span>
<span data-ttu-id="5c841-595">Azure Service Bus はメッセージ ブローカーを使用して、Service Bus のキューまたはトピックに送信されるメッセージを処理します。</span><span class="sxs-lookup"><span data-stu-id="5c841-595">Azure Service Bus uses a message broker to handle messages that are sent to a Service Bus queue or topic.</span></span> <span data-ttu-id="5c841-596">既定では、キューまたはトピックに送信されるすべてのメッセージは、同一のメッセージ ブローカー プロセスによって処理されます。</span><span class="sxs-lookup"><span data-stu-id="5c841-596">By default, all messages that are sent to a queue or topic are handled by the same message broker process.</span></span> <span data-ttu-id="5c841-597">このアーキテクチャにより、メッセージ キューの全体的なスループットに制限が生じる可能性があります。</span><span class="sxs-lookup"><span data-stu-id="5c841-597">This architecture can place a limitation on the overall throughput of the message queue.</span></span> <span data-ttu-id="5c841-598">ただし、キューまたはトピックの作成時にそれらをパーティション分割することもできます。</span><span class="sxs-lookup"><span data-stu-id="5c841-598">However, you can also partition a queue or topic when it is created.</span></span> <span data-ttu-id="5c841-599">そのためには、キューまたはトピックの *EnablePartitioning* プロパティを *true* に設定します。</span><span class="sxs-lookup"><span data-stu-id="5c841-599">You do this by setting the *EnablePartitioning* property of the queue or topic description to *true*.</span></span>

<span data-ttu-id="5c841-600">パーティション分割されたキューまたはトピックは複数のフラグメントに分割され、それぞれのフラグメントは個別のメッセージ ストアおよびメッセージ ブローカーにより返されます。</span><span class="sxs-lookup"><span data-stu-id="5c841-600">A partitioned queue or topic is divided into multiple fragments, each of which is backed by a separate message store and message broker.</span></span> <span data-ttu-id="5c841-601">これらのフラグメントの作成および管理は、Service Bus によって行われます。</span><span class="sxs-lookup"><span data-stu-id="5c841-601">Service Bus takes responsibility for creating and managing these fragments.</span></span> <span data-ttu-id="5c841-602">アプリケーションがメッセージをパーティション分割されたキューまたはトピックに送信すると、Service Bus はメッセージをそのキューまたはトピックのフラグメントに割り当てます。</span><span class="sxs-lookup"><span data-stu-id="5c841-602">When an application posts a message to a partitioned queue or topic, Service Bus assigns the message to a fragment for that queue or topic.</span></span> <span data-ttu-id="5c841-603">アプリケーションがメッセージをキューまたはサブスクリプションから受信すると、Service Bus は各フラグメントで次に利用可能なメッセージが存在するかどうかを確認し、存在する場合はそのメッセージを処理するために、アプリケーションに渡します。</span><span class="sxs-lookup"><span data-stu-id="5c841-603">When an application receives a message from a queue or subscription, Service Bus checks each fragment for the next available message and then passes it to the application for processing.</span></span>

<span data-ttu-id="5c841-604">この構造は、メッセージ ブローカー間およびメッセージ ストア間で負荷を分散するのに役立ち、拡張性と可用性を向上させます。</span><span class="sxs-lookup"><span data-stu-id="5c841-604">This structure helps distribute the load across message brokers and message stores, increasing scalability and improving availability.</span></span> <span data-ttu-id="5c841-605">1 つのフラグメントのメッセージ ブローカーまたはメッセージ ストアが一時的に利用できなくなると、Service Bus は利用可能な残りのフラグメントの 1 つからメッセージを取得できます。</span><span class="sxs-lookup"><span data-stu-id="5c841-605">If the message broker or message store for one fragment is temporarily unavailable, Service Bus can retrieve messages from one of the remaining available fragments.</span></span>

<span data-ttu-id="5c841-606">Service Bus は、次の手順に従って、メッセージをフラグメントに割り当てます。</span><span class="sxs-lookup"><span data-stu-id="5c841-606">Service Bus assigns a message to a fragment as follows:</span></span>

* <span data-ttu-id="5c841-607">メッセージがセッションに属する場合、SessionId プロパティと同じ値を持つすべてのメッセージは、同一のフラグメントに送信されます。</span><span class="sxs-lookup"><span data-stu-id="5c841-607">If the message belongs to a session, all messages with the same value for the * SessionId*  property are sent to the same fragment.</span></span>
* <span data-ttu-id="5c841-608">メッセージはセッションに属していないが、送信者が *PartitionKey* プロパティの値を指定している場合、同じ *PartitionKey* 値を持つすべてのメッセージは、同一のフラグメントに送信されます。</span><span class="sxs-lookup"><span data-stu-id="5c841-608">If the message does not belong to a session, but the sender has specified a value for the *PartitionKey* property, then all messages with the same *PartitionKey* value are sent to the same fragment.</span></span>

  > [!NOTE]
  > <span data-ttu-id="5c841-609">*SessionId* および *PartitionKey* プロパティの両方を指定している場合、これらを同じ値に設定する必要があります。そうしないと、メッセージは拒否されます。</span><span class="sxs-lookup"><span data-stu-id="5c841-609">If the *SessionId* and *PartitionKey* properties are both specified, then they must be set to the same value or the message will be rejected.</span></span>
  >
  >
* <span data-ttu-id="5c841-610">メッセージの *SessionId* プロパティと *PartitionKey* プロパティは指定されていないが、重複検出が有効な場合、*MessageId* プロパティが使用されます。</span><span class="sxs-lookup"><span data-stu-id="5c841-610">If the *SessionId* and *PartitionKey* properties for a message are not specified, but duplicate detection is enabled, the *MessageId* property will be used.</span></span> <span data-ttu-id="5c841-611">同じ *MessageId* を持つすべてのメッセージは、同一のフラグメントに転送されます。</span><span class="sxs-lookup"><span data-stu-id="5c841-611">All messages with the same *MessageId* will be directed to the same fragment.</span></span>
* <span data-ttu-id="5c841-612">メッセージに *SessionId、PartitionKey*、または *MessageId* のいずれのプロパティも含まれていない場合、Service Bus は順番にメッセージをフラグメントに割り当てます。</span><span class="sxs-lookup"><span data-stu-id="5c841-612">If messages do not include a *SessionId, PartitionKey,* or *MessageId* property, then Service Bus assigns messages to fragments sequentially.</span></span> <span data-ttu-id="5c841-613">あるフラグメントが利用できない場合、Service Bus は次のフラグメントに移動します。</span><span class="sxs-lookup"><span data-stu-id="5c841-613">If a fragment is unavailable, Service Bus will move on to the next.</span></span> <span data-ttu-id="5c841-614">つまり、メッセージ インフラストラクチャで一時的な障害が発生しても、メッセージ送信操作が失敗することはありません。</span><span class="sxs-lookup"><span data-stu-id="5c841-614">This means that a temporary fault in the messaging infrastructure does not cause the message-send operation to fail.</span></span>

<span data-ttu-id="5c841-615">Service Bus のメッセージのキューまたはトピックをパーティション分割するかどうか、また、パーティション分割する方法を決定するときは、次の点を考慮する必要があります。</span><span class="sxs-lookup"><span data-stu-id="5c841-615">Consider the following points when deciding if or how to partition a Service Bus message queue or topic:</span></span>

* <span data-ttu-id="5c841-616">Service Bus のキューとトピックは、Service Bus 名前空間のスコープ内で作成されます。</span><span class="sxs-lookup"><span data-stu-id="5c841-616">Service Bus queues and topics are created within the scope of a Service Bus namespace.</span></span> <span data-ttu-id="5c841-617">Service Bus は、現在、名前空間あたり最大 100 のパーティション分割されたキューまたはトピックをサポートします。</span><span class="sxs-lookup"><span data-stu-id="5c841-617">Service Bus currently allows up to 100 partitioned queues or topics per namespace.</span></span>
* <span data-ttu-id="5c841-618">各 Service Bus 名前空間は利用可能なリソースについてクォータが適用されます。これらのリソースには、トピックあたりのサブスクリプションの数、秒あたりの同時送受信要求の数、確立可能な同時接続の最大数などがあります。</span><span class="sxs-lookup"><span data-stu-id="5c841-618">Each Service Bus namespace imposes quotas on the available resources, such as the number of subscriptions per topic, the number of concurrent send and receive requests per second, and the maximum number of concurrent connections that can be established.</span></span> <span data-ttu-id="5c841-619">これらのクォータの詳細については、Microsoft Web サイトの [Service Bus のクォータ]に関するページを参照してください。</span><span class="sxs-lookup"><span data-stu-id="5c841-619">These quotas are documented on the Microsoft website on the page [Service Bus quotas].</span></span> <span data-ttu-id="5c841-620">これらの値を超えることが予想される場合、独自のキューとトピックを持つ追加の名前空間を作成し、負荷をこれらの名前空間間で分散します。</span><span class="sxs-lookup"><span data-stu-id="5c841-620">If you expect to exceed these values, then create additional namespaces with their own queues and topics, and spread the work across these namespaces.</span></span> <span data-ttu-id="5c841-621">たとえば、グローバル アプリケーションで、リージョンごとに個別の名前空間を作成し、最も近い名前空間のキューとトピックを使用するように、アプリケーション インスタンスを構成します。</span><span class="sxs-lookup"><span data-stu-id="5c841-621">For example, in a global application, create separate namespaces in each region and configure application instances to use the queues and topics in the nearest namespace.</span></span>
* <span data-ttu-id="5c841-622">トランザクションの一部として送信されるメッセージでは、パーティション キーを指定する必要があります。</span><span class="sxs-lookup"><span data-stu-id="5c841-622">Messages that are sent as part of a transaction must specify a partition key.</span></span> <span data-ttu-id="5c841-623">これは、*SessionId*、*PartitionKey*、または *MessageId* プロパティで指定できます。</span><span class="sxs-lookup"><span data-stu-id="5c841-623">This can be a *SessionId*, *PartitionKey*, or *MessageId* property.</span></span> <span data-ttu-id="5c841-624">同一トランザクションの一部として送信されるすべてのメッセージは、同じパーティション キーを指定する必要があります。これは、これらのメッセージが同一のメッセージ ブローカー プロセスによって処理される必要があるためです。</span><span class="sxs-lookup"><span data-stu-id="5c841-624">All messages that are sent as part of the same transaction must specify the same partition key because they must be handled by the same message broker process.</span></span> <span data-ttu-id="5c841-625">同一トランザクション内のメッセージを異なるキューまたはトピックに送信することはできません。</span><span class="sxs-lookup"><span data-stu-id="5c841-625">You cannot send messages to different queues or topics within the same transaction.</span></span>
* <span data-ttu-id="5c841-626">パーティション分割されたキューおよびトピックは、アイドル状態になったときに自動的に削除されるように構成することはできません。</span><span class="sxs-lookup"><span data-stu-id="5c841-626">Partitioned queues and topics can't be configured to be automatically deleted when they become idle.</span></span>
* <span data-ttu-id="5c841-627">クロスプラットフォームまたはハイブリッドのソリューションを構築している場合、現在、パーティション分割されたキューおよびトピックを Advanced Message Queuing Protocol (AMQP) で使用することはできません。</span><span class="sxs-lookup"><span data-stu-id="5c841-627">Partitioned queues and topics can't currently be used with the Advanced Message Queuing Protocol (AMQP) if you are building cross-platform or hybrid solutions.</span></span>

## <a name="partitioning-strategies-for-cosmos-db"></a><span data-ttu-id="5c841-628">Cosmos DB 用のパーティション分割戦略</span><span class="sxs-lookup"><span data-stu-id="5c841-628">Partitioning strategies for Cosmos DB</span></span>

<span data-ttu-id="5c841-629">Azure Cosmos DB は [Azure Cosmos DB SQL API][cosmosdb-sql-api] を使用して JSON ドキュメントを格納できる NoSQL データベースです。</span><span class="sxs-lookup"><span data-stu-id="5c841-629">Azure Cosmos DB is a NoSQL database that can store JSON documents using the [Azure Cosmos DB SQL API][cosmosdb-sql-api].</span></span> <span data-ttu-id="5c841-630">Cosmos DB データベースのドキュメントは、オブジェクトまたは他の種類のデータの JSON シリアル化された表現です。</span><span class="sxs-lookup"><span data-stu-id="5c841-630">A document in a Cosmos DB database is a JSON-serialized representation of an object or other piece of data.</span></span> <span data-ttu-id="5c841-631">すべてのドキュメントは一意な ID を含む必要があることを除いて、いずれの固定されたスキーマも強制されません。</span><span class="sxs-lookup"><span data-stu-id="5c841-631">No fixed schemas are enforced except that every document must contain a unique ID.</span></span>

<span data-ttu-id="5c841-632">ドキュメントはコレクションに編成されます。</span><span class="sxs-lookup"><span data-stu-id="5c841-632">Documents are organized into collections.</span></span> <span data-ttu-id="5c841-633">コレクションでは、関連するドキュメントをグループ化できます。</span><span class="sxs-lookup"><span data-stu-id="5c841-633">You can group related documents together in a collection.</span></span> <span data-ttu-id="5c841-634">たとえば、ブログ投稿を維持するシステムでは、各ブログ投稿のコンテンツをドキュメントとしてコレクションに格納できます。</span><span class="sxs-lookup"><span data-stu-id="5c841-634">For example, in a system that maintains blog postings, you can store the contents of each blog post as a document in a collection.</span></span> <span data-ttu-id="5c841-635">また、各サブジェクト タイプのコレクションも作成できます。</span><span class="sxs-lookup"><span data-stu-id="5c841-635">You can also create collections for each subject type.</span></span> <span data-ttu-id="5c841-636">また、さまざまな著者が自身のブログ投稿を制御および管理するシステムなどのマルチテナント アプリケーションでは、ブログを著者別にパーティション分割して、著者ごとに個別のコレクションを作成できることがあります。</span><span class="sxs-lookup"><span data-stu-id="5c841-636">Alternatively, in a multitenant application, such as a system where different authors control and manage their own blog posts, you can partition blogs by author and create separate collections for each author.</span></span> <span data-ttu-id="5c841-637">コレクションに割り当てられるストレージ領域は、弾力性があり、必要に応じて縮小または拡大できます。</span><span class="sxs-lookup"><span data-stu-id="5c841-637">The storage space that's allocated to collections is elastic and can shrink or grow as needed.</span></span>

<span data-ttu-id="5c841-638">Cosmos DB では、アプリケーションで定義されたパーティション キーに基づくデータの自動パーティション分割をサポートします。</span><span class="sxs-lookup"><span data-stu-id="5c841-638">Cosmos DB supports automatic partitioning of data based on an application-defined partition key.</span></span> <span data-ttu-id="5c841-639">"*論理パーティション*" は、1 つのパーティション キー値に対応するすべてのデータを格納するパーティションです。</span><span class="sxs-lookup"><span data-stu-id="5c841-639">A *logical partition* is a partition that stores all the data for a single partition key value.</span></span> <span data-ttu-id="5c841-640">同じパーティション キー値を共有するすべてのドキュメントは、同じ論理パーティション内に配置されます。</span><span class="sxs-lookup"><span data-stu-id="5c841-640">All documents that share the same value for the partition key are placed within the same logical partition.</span></span> <span data-ttu-id="5c841-641">Cosmos DB では、パーティション キーのハッシュに従って値を分散配置します。</span><span class="sxs-lookup"><span data-stu-id="5c841-641">Cosmos DB distributes values according to hash of the partition key.</span></span> <span data-ttu-id="5c841-642">論理パーティションの最大サイズは 10 GB です。</span><span class="sxs-lookup"><span data-stu-id="5c841-642">A logical partition has a maximum size of 10 GB.</span></span> <span data-ttu-id="5c841-643">したがって、パーティション キーの選択は、設計時の重要な決定事項の 1 つです。</span><span class="sxs-lookup"><span data-stu-id="5c841-643">Therefore, the choice of the partition key is an important decision at design time.</span></span> <span data-ttu-id="5c841-644">値が多岐にわたっていて、なおかつ均等なアクセス パターンを持つプロパティを選択します。</span><span class="sxs-lookup"><span data-stu-id="5c841-644">Choose a property with a wide range of values and even access patterns.</span></span> <span data-ttu-id="5c841-645">詳細については、「[Azure Cosmos DB でのパーティション分割とスケーリング](/azure/cosmos-db/partition-data)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="5c841-645">For more information, see [Partition and scale in Azure Cosmos DB](/azure/cosmos-db/partition-data).</span></span>

> [!NOTE]
> <span data-ttu-id="5c841-646">各 Cosmos DB データベースには、取得するリソースの量を決定する "*パフォーマンス レベル*" があります。</span><span class="sxs-lookup"><span data-stu-id="5c841-646">Each Cosmos DB database has a *performance level* that determines the amount of resources it gets.</span></span> <span data-ttu-id="5c841-647">パフォーマンス レベルには、関連する "*要求ユニット*" (RU) レートの制限があります。</span><span class="sxs-lookup"><span data-stu-id="5c841-647">A performance level is associated with a *request unit* (RU) rate limit.</span></span> <span data-ttu-id="5c841-648">RU レートの制限は、そのコレクションに予約されており、そのコレクションによって排他使用できるリソースの量を指定します。</span><span class="sxs-lookup"><span data-stu-id="5c841-648">The RU rate limit specifies the volume of resources that's reserved and available for exclusive use by that collection.</span></span> <span data-ttu-id="5c841-649">コレクションのコストは、そのコレクションによって選択されたパフォーマンス レベルに依存します。</span><span class="sxs-lookup"><span data-stu-id="5c841-649">The cost of a collection depends on the performance level that's selected for that collection.</span></span> <span data-ttu-id="5c841-650">パフォーマンス レベル (および RU レートの制限) が高くなるほど、料金も高くなります。</span><span class="sxs-lookup"><span data-stu-id="5c841-650">The higher the performance level (and RU rate limit) the higher the charge.</span></span> <span data-ttu-id="5c841-651">コレクションのパフォーマンス レベルは、Azure Portal を使用することにより調整できます。</span><span class="sxs-lookup"><span data-stu-id="5c841-651">You can adjust the performance level of a collection by using the Azure portal.</span></span> <span data-ttu-id="5c841-652">詳細については、「[Azure Cosmos DB の要求ユニット][cosmos-db-ru]」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="5c841-652">For more information, see [Request Units in Azure Cosmos DB][cosmos-db-ru].</span></span>
>
>

<span data-ttu-id="5c841-653">Cosmos DB が提供するパーティション分割メカニズムでは十分でない場合、アプリケーション レベルでデータをシャード化する必要がある場合があります。</span><span class="sxs-lookup"><span data-stu-id="5c841-653">If the paritioning mechanism that Cosmos DB provides is not sufficient, you may need to shard the data at the application level.</span></span> <span data-ttu-id="5c841-654">ドキュメント コレクションは、単一データベース内でデータをパーティション分割するための自然なメカニズムを提供します。</span><span class="sxs-lookup"><span data-stu-id="5c841-654">Document collections provide a natural mechanism for partitioning data within a single database.</span></span> <span data-ttu-id="5c841-655">シャーディングを実装するための最も簡単な方法は、各シャード用にコレクションを作成することです。</span><span class="sxs-lookup"><span data-stu-id="5c841-655">The simplest way to implement sharding is to create a collection for each shard.</span></span> <span data-ttu-id="5c841-656">コンテナーは論理リソースであり、1 つ以上のサーバーにまたがることができます。</span><span class="sxs-lookup"><span data-stu-id="5c841-656">Containers are logical resources and can span one or more servers.</span></span> <span data-ttu-id="5c841-657">固定サイズのコンテナーの上限は、容量が 10 GB で、スループットが毎秒 10,000 RU となります。</span><span class="sxs-lookup"><span data-stu-id="5c841-657">Fixed-size containers have a maximum limit of 10 GB and 10,000 RU/s throughput.</span></span> <span data-ttu-id="5c841-658">無制限のコンテナーには最大ストレージ サイズはありませんが、パーティション キーを指定する必要があります。</span><span class="sxs-lookup"><span data-stu-id="5c841-658">Unlimited containers do not have a maximum sotrage size, but must specify a partition key.</span></span> <span data-ttu-id="5c841-659">クライアント アプリケーションは、アプリケーション シャーディングを使用して要求を適切なシャードに転送する必要があります。このためには、通常、シャード キーを定義するデータのいくつかの属性に基づいて、独自のマッピング メカニズムを実装します。</span><span class="sxs-lookup"><span data-stu-id="5c841-659">With application sharding, the client application must direct requests to the appropriate shard, usually by implementing its own mapping mechanism based on some attributes of the data that define the shard key.</span></span> 

<span data-ttu-id="5c841-660">すべてのデータベースは、Cosmos DB アカウントのコンテキストで作成されます。</span><span class="sxs-lookup"><span data-stu-id="5c841-660">All databases are created in the context of a Cosmos DB database account.</span></span> <span data-ttu-id="5c841-661">1 つのアカウントに複数のデータベースを含めることができ、アカウントによりデータベースの作成先となるリージョンが指定されます。</span><span class="sxs-lookup"><span data-stu-id="5c841-661">A single account can contain several databases, and it specifies in which regions the databases are created.</span></span> <span data-ttu-id="5c841-662">また、各アカウントは、独自のアクセス制御を実行します。</span><span class="sxs-lookup"><span data-stu-id="5c841-662">Each account also enforces its own access control.</span></span> <span data-ttu-id="5c841-663">Cosmos DB アカウントを使用して、シャード (データベース内のコレクション) をそれらにアクセスする必要のあるユーザーの近くに geo 配置し、それらのユーザーだけがそれらのシャードに接続できるように制限を強制することができます。</span><span class="sxs-lookup"><span data-stu-id="5c841-663">You can use Cosmos DB accounts to geo-locate shards (collections within databases) close to the users who need to access them, and enforce restrictions so that only those users can connect to them.</span></span>

<span data-ttu-id="5c841-664">Cosmos DB SQL API でデータをパーティション分割する方法を決定する際には、次の点を考慮する必要があります。</span><span class="sxs-lookup"><span data-stu-id="5c841-664">Consider the following points when deciding how to partition data with the Cosmos DB SQL API:</span></span>

* <span data-ttu-id="5c841-665">**Cosmos DB データベースで利用できるリソースは、アカウントのクォータ制限の対象になります**。</span><span class="sxs-lookup"><span data-stu-id="5c841-665">**The resources available to a Cosmos DB database are subject to the quota limitations of the account**.</span></span> <span data-ttu-id="5c841-666">各データベースは複数のコレクションを保持できます。各コレクションには、そのコレクションの RU レートの制限 (予約されているスループット) を管理するパフォーマンス レベルが関連付けられています。</span><span class="sxs-lookup"><span data-stu-id="5c841-666">Each database can hold a number of collections, and each collection is associated with a performance level that governs the RU rate limit (reserved throughput) for that collection.</span></span> <span data-ttu-id="5c841-667">詳細については、「[Azure サブスクリプションとサービスの制限、クォータ、制約][azure-limits]」をご覧ください。</span><span class="sxs-lookup"><span data-stu-id="5c841-667">For more information, see [Azure subscription and service limits, quotas, and constraints][azure-limits].</span></span>
* <span data-ttu-id="5c841-668">**各ドキュメントには、それが保持されるコレクション内でそれを一意に識別するために使用できる属性が存在する必要があります**。</span><span class="sxs-lookup"><span data-stu-id="5c841-668">**Each document must have an attribute that can be used to uniquely identify that document within the collection in which it is held**.</span></span> <span data-ttu-id="5c841-669">この属性は、ドキュメントの保持先となるコレクションを定義するシャード キーとは異なります。</span><span class="sxs-lookup"><span data-stu-id="5c841-669">This attribute is different from the shard key, which defines which collection holds the document.</span></span> <span data-ttu-id="5c841-670">コレクションは大量のドキュメントを含むことができます。</span><span class="sxs-lookup"><span data-stu-id="5c841-670">A collection can contain a large number of documents.</span></span> <span data-ttu-id="5c841-671">理論的には、ドキュメント ID の最大長によってのみ制限されます。</span><span class="sxs-lookup"><span data-stu-id="5c841-671">In theory, it's limited only by the maximum length of the document ID.</span></span> <span data-ttu-id="5c841-672">ドキュメント ID の最大長は、255 文字です。</span><span class="sxs-lookup"><span data-stu-id="5c841-672">The document ID can be up to 255 characters.</span></span>
* <span data-ttu-id="5c841-673">**ドキュメントに対するすべての操作は、トランザクションのコンテキスト内で実行されます。トランザクションは、ドキュメントが含まれているコレクションに対象が制限されます。**</span><span class="sxs-lookup"><span data-stu-id="5c841-673">**All operations against a document are performed within the context of a transaction. Transactions are scoped to the collection in which the document is contained.**</span></span> <span data-ttu-id="5c841-674">操作が失敗すると、それまでに実行された作業はロールバックされます。</span><span class="sxs-lookup"><span data-stu-id="5c841-674">If an operation fails, the work that it has performed is rolled back.</span></span> <span data-ttu-id="5c841-675">ドキュメントは操作の対象ですが、実行されるすべての変更は、スナップショット レベルで分離されます。</span><span class="sxs-lookup"><span data-stu-id="5c841-675">While a document is subject to an operation, any changes that are made are subject to snapshot-level isolation.</span></span> <span data-ttu-id="5c841-676">このメカニズムは、たとえば、新しいドキュメントを作成する要求が失敗すると、同時にデータベースをクエリしている別のユーザーが、その時点で削除された不完全なドキュメントを見ることはないことを保証します。</span><span class="sxs-lookup"><span data-stu-id="5c841-676">This mechanism guarantees that if, for example, a request to create a new document fails, another user who's querying the database simultaneously will not see a partial document that is then removed.</span></span>
* <span data-ttu-id="5c841-677">**データベース クエリもまた、コレクション レベルの範囲に制限されます**。</span><span class="sxs-lookup"><span data-stu-id="5c841-677">**Database queries are also scoped to the collection level**.</span></span> <span data-ttu-id="5c841-678">単一のクエリは、1 つのコレクションのみからのデータを取得できます。</span><span class="sxs-lookup"><span data-stu-id="5c841-678">A single query can retrieve data from only one collection.</span></span> <span data-ttu-id="5c841-679">複数のコレクションからデータを取得する必要がある場合、各コレクションを個別にクエリし、結果をアプリケーション コードでマージする必要があります。</span><span class="sxs-lookup"><span data-stu-id="5c841-679">If you need to retrieve data from multiple collections, you must query each collection individually and merge the results in your application code.</span></span>
* <span data-ttu-id="5c841-680">**Cosmos DB はプログラム可能な項目をサポートします。これらはすべて、ドキュメントと一緒にコレクションに格納できます**。</span><span class="sxs-lookup"><span data-stu-id="5c841-680">**Cosmos DB supports programmable items that can all be stored in a collection alongside documents**.</span></span> <span data-ttu-id="5c841-681">このような項目としては、ストアド プロシージャ、ユーザー定義の関数、および JavaScript で記述されたトリガーがあります。</span><span class="sxs-lookup"><span data-stu-id="5c841-681">These include stored procedures, user-defined functions, and triggers (written in JavaScript).</span></span> <span data-ttu-id="5c841-682">これらの項目は、同一コレクション内の任意のドキュメントにアクセスできます。</span><span class="sxs-lookup"><span data-stu-id="5c841-682">These items can access any document within the same collection.</span></span> <span data-ttu-id="5c841-683">さらに、これらの項目は、ドキュメントに対して実行された作成、削除、または置換の操作の結果として起動されるトリガーの場合には、アンビエント トランザクションのスコープ内で実行します。また、明示的なクライアント要求の結果として実行されるストアド プロシージャの場合には、新しいトランザクションを開始することによって実行されます。</span><span class="sxs-lookup"><span data-stu-id="5c841-683">Furthermore, these items run either inside the scope of the ambient transaction (in the case of a trigger that fires as the result of a create, delete, or replace operation performed against a document), or by starting a new transaction (in the case of a stored procedure that is run as the result of an explicit client request).</span></span> <span data-ttu-id="5c841-684">プログラム可能な項目内のコードが例外をスローすると、トランザクションはロールバックされます。</span><span class="sxs-lookup"><span data-stu-id="5c841-684">If the code in a programmable item throws an exception, the transaction is rolled back.</span></span> <span data-ttu-id="5c841-685">ストアド プロシージャとトリガーを使用してドキュメント間の整合性と一貫性を維持できますが、これらのドキュメントはすべて、同一のコレクション内に含まれている必要があります。</span><span class="sxs-lookup"><span data-stu-id="5c841-685">You can use stored procedures and triggers to maintain integrity and consistency between documents, but these documents must all be part of the same collection.</span></span>
* <span data-ttu-id="5c841-686">**データベースに保持することが想定されているコレクションが、コレクションのパフォーマンス レベルによって定義されているスループット制限を超えないことを確認する必要があります**。</span><span class="sxs-lookup"><span data-stu-id="5c841-686">**The collections that you intend to hold in the databases should be unlikely to exceed the throughput limits defined by the performance levels of the collections**.</span></span> <span data-ttu-id="5c841-687">詳細については、「[Azure Cosmos DB の要求ユニット][cosmos-db-ru]」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="5c841-687">For more information, see [Request Units in Azure Cosmos DB][cosmos-db-ru].</span></span> <span data-ttu-id="5c841-688">これらの制限に到達することが予想される場合は、異なるアカウントのデータベースにまたがってコレクションを分割して、コレクションあたりの負荷を軽減します。</span><span class="sxs-lookup"><span data-stu-id="5c841-688">If you anticipate reaching these limits, consider splitting collections across databases in different accounts to reduce the load per collection.</span></span>

## <a name="partitioning-strategies-for-azure-search"></a><span data-ttu-id="5c841-689">Azure Search 用のパーティション分割戦略</span><span class="sxs-lookup"><span data-stu-id="5c841-689">Partitioning strategies for Azure Search</span></span>
<span data-ttu-id="5c841-690">データを検索する機能は、多くの Web アプリケーションによって提供されるナビゲーションと探索の主要な方法です。</span><span class="sxs-lookup"><span data-stu-id="5c841-690">The ability to search for data is often the primary method of navigation and exploration that's provided by many web applications.</span></span> <span data-ttu-id="5c841-691">ユーザーは、検索条件の組み合わせに基づいて、リソース (たとえば、e コマース アプリケーションでの製品) をすばやく見つけることができます。</span><span class="sxs-lookup"><span data-stu-id="5c841-691">It helps users find resources quickly (for example, products in an e-commerce application) based on combinations of search criteria.</span></span> <span data-ttu-id="5c841-692">Azure Search サービスは、Web コンテンツに対するフルテキスト検索機能に加えて、先行入力、近似一致に基づくクエリ候補表示、ファセット ナビゲーションなどの機能を提供しています。</span><span class="sxs-lookup"><span data-stu-id="5c841-692">The Azure Search service provides full-text search capabilities over web content, and includes features such as type-ahead, suggested queries based on near matches, and faceted navigation.</span></span> <span data-ttu-id="5c841-693">これらの機能の詳細については、Microsoft Web サイトの「[Azure Search とは]」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="5c841-693">A full description of these capabilities is available on the page [What is Azure Search?] on the Microsoft website.</span></span>

<span data-ttu-id="5c841-694">Azure Search は、検索可能なコンテンツを JSON ドキュメントとしてデータベースに格納します。</span><span class="sxs-lookup"><span data-stu-id="5c841-694">Azure Search stores searchable content as JSON documents in a database.</span></span> <span data-ttu-id="5c841-695">これらのドキュメントの検索可能なフィールドを指定するインデックスを定義し、これらの定義を Azure Search に提供します。</span><span class="sxs-lookup"><span data-stu-id="5c841-695">You define indexes that specify the searchable fields in these documents and provide these definitions to Azure Search.</span></span> <span data-ttu-id="5c841-696">ユーザーが検索要求を発行すると、Azure Search は適切なインデックスを使用して一致する項目を検索します。</span><span class="sxs-lookup"><span data-stu-id="5c841-696">When a user submits a search request, Azure Search uses the appropriate indexes to find matching items.</span></span>

<span data-ttu-id="5c841-697">競合を少なくするために、Azure Search によって使用されるストレージは、最大 1、2、3、4、6、または 12 のパーティションに分割でき、各パーティションは最大 6 回レプリケートできます。</span><span class="sxs-lookup"><span data-stu-id="5c841-697">To reduce contention, the storage that's used by Azure Search can be divided into 1, 2, 3, 4, 6, or 12 partitions, and each partition can be replicated up to 6 times.</span></span> <span data-ttu-id="5c841-698">パーティションの数とレプリカの数の積は、"*検索単位*" (SU) と呼ばれます。</span><span class="sxs-lookup"><span data-stu-id="5c841-698">The product of the number of partitions multiplied by the number of replicas is called the *search unit* (SU).</span></span> <span data-ttu-id="5c841-699">Azure Search の単一インスタンスは、最大 36 SU を含むことができます (12 のパーティションを持つデータベースは、最大 3 つのレプリカをサポートします)。</span><span class="sxs-lookup"><span data-stu-id="5c841-699">A single instance of Azure Search can contain a maximum of 36 SUs (a database with 12 partitions only supports a maximum of 3 replicas).</span></span>

<span data-ttu-id="5c841-700">課金は、サービスに割り当てられている各 SU に対して行われます。</span><span class="sxs-lookup"><span data-stu-id="5c841-700">You are billed for each SU that is allocated to your service.</span></span> <span data-ttu-id="5c841-701">検索可能なコンテンツの量、または検索要求の割合が増加した場合、Azure Search の既存のインスタンスに SU を追加して、増加した負荷を処理できます。</span><span class="sxs-lookup"><span data-stu-id="5c841-701">As the volume of searchable content increases or the rate of search requests grows, you can add SUs to an existing instance of Azure Search to handle the extra load.</span></span> <span data-ttu-id="5c841-702">Azure Search 自体が、パーティション間にドキュメントを均等に分散します。</span><span class="sxs-lookup"><span data-stu-id="5c841-702">Azure Search itself distributes the documents evenly across the partitions.</span></span> <span data-ttu-id="5c841-703">手動によるパーティション分割戦略は、現時点でサポートされていません。</span><span class="sxs-lookup"><span data-stu-id="5c841-703">No manual partitioning strategies are currently supported.</span></span>

<span data-ttu-id="5c841-704">各パーティションは、最大 1,500 万のドキュメント、または 300 GB のストレージ領域のいずれか少ない方を収容できます。</span><span class="sxs-lookup"><span data-stu-id="5c841-704">Each partition can contain a maximum of 15 million documents or occupy 300 GB of storage space (whichever is smaller).</span></span> <span data-ttu-id="5c841-705">最大 50 のインデックスを作成できます。</span><span class="sxs-lookup"><span data-stu-id="5c841-705">You can create up to 50 indexes.</span></span> <span data-ttu-id="5c841-706">サービスのパフォーマンスは、ドキュメントの複雑さ、利用可能なインデックス、およびネットワーク遅延の影響によって異なります。</span><span class="sxs-lookup"><span data-stu-id="5c841-706">The performance of the service varies and depends on the complexity of the documents, the available indexes, and the effects of network latency.</span></span> <span data-ttu-id="5c841-707">平均すると、単一レプリカ (1 SU) は 15 クエリ/秒 (QPS) を処理できます。ただし、スループットをより正確に測定するために、自身のデータを使用してベンチマークを実行することをお勧めします。</span><span class="sxs-lookup"><span data-stu-id="5c841-707">On average, a single replica (1 SU) should be able to handle 15 queries per second (QPS), although we recommend performing benchmarking with your own data to obtain a more precise measure of throughput.</span></span> <span data-ttu-id="5c841-708">詳細については、Microsoft Web サイトの「[Azure Search サービスの制限]」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="5c841-708">For more information, see the page [Service limits in Azure Search] on the Microsoft website.</span></span>

> [!NOTE]
> <span data-ttu-id="5c841-709">検索可能ドキュメントには、限定されたセットのデータ型を格納できます。これらのデータには、文字列、ブール値、数値データ、日付時刻データ、および一部の地理的データが含まれます。</span><span class="sxs-lookup"><span data-stu-id="5c841-709">You can store a limited set of data types in searchable documents, including strings, Booleans, numeric data, datetime data, and some geographical data.</span></span> <span data-ttu-id="5c841-710">詳細については、Microsoft Web サイトの「[Supported data types (Azure Search) (サポートされるデータ型 (Azure Search))]」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="5c841-710">For more details, see the page [Supported data types (Azure Search)] on the Microsoft website.</span></span>
>
>

<span data-ttu-id="5c841-711">Azure Search がサービスの各インスタンス用にデータをパーティション分割する方法については、限定された制御しかできません。</span><span class="sxs-lookup"><span data-stu-id="5c841-711">You have limited control over how Azure Search partitions data for each instance of the service.</span></span> <span data-ttu-id="5c841-712">ただし、グローバル環境では、次のいずれかの戦略を使用してサービス自体をパーティション分割することにより、パフォーマンスを向上させ、遅延を小さくし、競合を少なくすることができる場合があります。</span><span class="sxs-lookup"><span data-stu-id="5c841-712">However, in a global environment you might be able to improve performance and reduce latency and contention further by partitioning the service itself using either of the following strategies:</span></span>

* <span data-ttu-id="5c841-713">各リージョンで Azure Search のインスタンスを作成し、クライアント アプリケーションの要求が最も近い利用可能なインスタンスに転送されることを確認します。</span><span class="sxs-lookup"><span data-stu-id="5c841-713">Create an instance of Azure Search in each geographic region, and ensure that client applications are directed towards the nearest available instance.</span></span> <span data-ttu-id="5c841-714">この戦略では、検索可能なコンテンツに対するすべての更新がサービスのすべてのインスタンスに対して、遅れることなくレプリケートされる必要があります。</span><span class="sxs-lookup"><span data-stu-id="5c841-714">This strategy requires that any updates to searchable content are replicated in a timely manner across all instances of the service.</span></span>
* <span data-ttu-id="5c841-715">Azure Search の 2 つの階層を作成します。</span><span class="sxs-lookup"><span data-stu-id="5c841-715">Create two tiers of Azure Search:</span></span>

  * <span data-ttu-id="5c841-716">各リージョンに、そのリージョンで最も頻繁にアクセスされるデータを含むローカル サービス。</span><span class="sxs-lookup"><span data-stu-id="5c841-716">A local service in each region that contains the data that's most frequently accessed by users in that region.</span></span> <span data-ttu-id="5c841-717">限定的な結果でも早くほしい場合は、ここに要求できます。</span><span class="sxs-lookup"><span data-stu-id="5c841-717">Users can direct requests here for fast but limited results.</span></span>
  * <span data-ttu-id="5c841-718">すべてのデータを収容するグローバル サービス。</span><span class="sxs-lookup"><span data-stu-id="5c841-718">A global service that encompasses all the data.</span></span> <span data-ttu-id="5c841-719">時間がかかっても完全な結果が必要な場合は、ここに要求できます。</span><span class="sxs-lookup"><span data-stu-id="5c841-719">Users can direct requests here for slower but more complete results.</span></span>

<span data-ttu-id="5c841-720">この手法は、検索対象のデータに大きな地域的な相違がある場合に最も適しています。</span><span class="sxs-lookup"><span data-stu-id="5c841-720">This approach is most suitable when there is a significant regional variation in the data that's being searched.</span></span>

## <a name="partitioning-strategies-for-azure-redis-cache"></a><span data-ttu-id="5c841-721">Azure Redis Cache 用のパーティション分割戦略</span><span class="sxs-lookup"><span data-stu-id="5c841-721">Partitioning strategies for Azure Redis Cache</span></span>
<span data-ttu-id="5c841-722">Azure Redis Cache は、Redis キー/値データ ストアに基づく、クラウド内の共有キャッシュ サービスを提供します。</span><span class="sxs-lookup"><span data-stu-id="5c841-722">Azure Redis Cache provides a shared caching service in the cloud that's based on the Redis key-value data store.</span></span> <span data-ttu-id="5c841-723">名前が示すように、Azure Redis Cache はキャッシュ ソリューションを意図しています。</span><span class="sxs-lookup"><span data-stu-id="5c841-723">As its name implies, Azure Redis Cache is intended as a caching solution.</span></span> <span data-ttu-id="5c841-724">恒久的なデータ ストアとしてではなく、一時的なデータを保持するためにのみ使用する必要があります。</span><span class="sxs-lookup"><span data-stu-id="5c841-724">Use it only for holding transient data and not as a permanent data store.</span></span> <span data-ttu-id="5c841-725">Azure Redis Cache を利用するアプリケーションは、キャッシュが利用できない場合でも、継続して動作できる必要があります。</span><span class="sxs-lookup"><span data-stu-id="5c841-725">Applications that utilize Azure Redis Cache should be able to continue functioning if the cache is unavailable.</span></span> <span data-ttu-id="5c841-726">Azure Redis Cache はプライマリ/セカンダリ レプリケーションをサポートし、高可用性を提供しますが、現在、最大キャッシュ サイズは 53 GB に制限されています。</span><span class="sxs-lookup"><span data-stu-id="5c841-726">Azure Redis Cache supports primary/secondary replication to provide high availability, but currently limits the maximum cache size to 53 GB.</span></span> <span data-ttu-id="5c841-727">このサイズを超える領域を必要とする場合は、追加のキャッシュを作成する必要があります。</span><span class="sxs-lookup"><span data-stu-id="5c841-727">If you need more space than this, you must create additional caches.</span></span> <span data-ttu-id="5c841-728">詳細については、Microsoft Web サイトの「 [Azure Redis Cache] 」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="5c841-728">For more information, go to the page [Azure Redis Cache] on the Microsoft website.</span></span>

<span data-ttu-id="5c841-729">Redis データ ストアをパーティション分割する場合、Redis サービスのインスタンス全体でデータを分割します。</span><span class="sxs-lookup"><span data-stu-id="5c841-729">Partitioning a Redis data store involves splitting the data across instances of the Redis service.</span></span> <span data-ttu-id="5c841-730">各インスタンスは、単一パーティションを構成します。</span><span class="sxs-lookup"><span data-stu-id="5c841-730">Each instance constitutes a single partition.</span></span> <span data-ttu-id="5c841-731">Azure Redis Cache はファサードの背後に Redis サービスを抽象化し、それらが直接アクセスされないようにします。</span><span class="sxs-lookup"><span data-stu-id="5c841-731">Azure Redis Cache abstracts the Redis services behind a façade and does not expose them directly.</span></span> <span data-ttu-id="5c841-732">パーティション分割を実装する最も簡単な方法は、複数の Azure Redis Cache インスタンスを作成し、データをそれら全体に分散することです。</span><span class="sxs-lookup"><span data-stu-id="5c841-732">The simplest way to implement partitioning is to create multiple Azure Redis Cache instances and spread the data across them.</span></span>

<span data-ttu-id="5c841-733">データ項目の格納先となるキャッシュを指定する識別子 (パーティション キー) と各データ項目を関連付けることができます。</span><span class="sxs-lookup"><span data-stu-id="5c841-733">You can associate each data item with an identifier (a partition key) that specifies which cache stores the data item.</span></span> <span data-ttu-id="5c841-734">クライアント アプリケーション ロジックはこの識別子を使用して、要求を適切なパーティションにルーティングできます。</span><span class="sxs-lookup"><span data-stu-id="5c841-734">The client application logic can then use this identifier to route requests to the appropriate partition.</span></span> <span data-ttu-id="5c841-735">この構成は非常に単純ですが、パーティション分割構成が変更されると (たとえば、追加の Azure Redis Cache インスタンスが作成されると)、クライアント アプリケーションの再構成が必要になる場合があります。</span><span class="sxs-lookup"><span data-stu-id="5c841-735">This scheme is very simple, but if the partitioning scheme changes (for example, if additional Azure Redis Cache instances are created), client applications might need to be reconfigured.</span></span>

<span data-ttu-id="5c841-736">Azure Redis Cache ではないネイティブ Redis は、Redis クラスタリングに基づくサーバー側のパーティション分割をサポートします。</span><span class="sxs-lookup"><span data-stu-id="5c841-736">Native Redis (not Azure Redis Cache) supports server-side partitioning based on Redis clustering.</span></span> <span data-ttu-id="5c841-737">この手法では、ハッシュ メカニズムを使用することにより、データをサーバー間で均等に分散できます。</span><span class="sxs-lookup"><span data-stu-id="5c841-737">In this approach, you can divide the data evenly across servers by using a hashing mechanism.</span></span> <span data-ttu-id="5c841-738">各 Redis サーバーは、パーティションが保持するハッシュ キーの範囲を定義するメタデータを格納します。また、他のサーバーのパーティションに配置されているハッシュ キーに関する情報も含みます。</span><span class="sxs-lookup"><span data-stu-id="5c841-738">Each Redis server stores metadata that describes the range of hash keys that the partition holds, and also contains information about which hash keys are located in the partitions on other servers.</span></span>

<span data-ttu-id="5c841-739">クライアント アプリケーションは単純に要求を、パーティション分割された任意の Redis サーバー (最も近いサーバーの可能性大) に送信します。</span><span class="sxs-lookup"><span data-stu-id="5c841-739">Client applications simply send requests to any of the participating Redis servers (probably the closest one).</span></span> <span data-ttu-id="5c841-740">Redis サーバーは、クライアント要求を調べます。</span><span class="sxs-lookup"><span data-stu-id="5c841-740">The Redis server examines the client request.</span></span> <span data-ttu-id="5c841-741">ローカルで解決できる場合、要求された操作が実行されます。</span><span class="sxs-lookup"><span data-stu-id="5c841-741">If it can be resolved locally, it performs the requested operation.</span></span> <span data-ttu-id="5c841-742">ローカルで解決できない場合、適切なサーバーに要求が転送されます。</span><span class="sxs-lookup"><span data-stu-id="5c841-742">Otherwise it forwards the request on to the appropriate server.</span></span>

<span data-ttu-id="5c841-743">このモデルは Redis クラスタリングを使用することによって実装されます。詳細については、Redis Web サイトの「[Redis cluster tutorial (Redis クラスターのチュートリアル)]」ページを参照してください。</span><span class="sxs-lookup"><span data-stu-id="5c841-743">This model is implemented by using Redis clustering, and is described in more detail on the [Redis cluster tutorial] page on the Redis website.</span></span> <span data-ttu-id="5c841-744">Redis クラスタリングはクライアント アプリケーションにとって透過的なものです。</span><span class="sxs-lookup"><span data-stu-id="5c841-744">Redis clustering is transparent to client applications.</span></span> <span data-ttu-id="5c841-745">クライアントを再構成しなくても追加の Redis サーバーをクラスターに追加できます (およびデータを再パーティション分割できます)。</span><span class="sxs-lookup"><span data-stu-id="5c841-745">Additional Redis servers can be added to the cluster (and the data can be re-partitioned) without requiring that you reconfigure the clients.</span></span>

> [!IMPORTANT]
> <span data-ttu-id="5c841-746">現在、Azure Redis Cache と Redis クラスタリングは併用できません。</span><span class="sxs-lookup"><span data-stu-id="5c841-746">Azure Redis Cache does not currently support Redis clustering.</span></span> <span data-ttu-id="5c841-747">Azure でこの手法を実装したい場合は、一連の Azure Virtual Machines に Redis をインストールし、手動で構成することにより、独自の Redis サーバーを実装する必要があります。</span><span class="sxs-lookup"><span data-stu-id="5c841-747">If you want to implement this approach with Azure, then you must implement your own Redis servers by installing Redis on a set of Azure virtual machines and configuring them manually.</span></span> <span data-ttu-id="5c841-748">Microsoft Web サイトの「 [Running Redis on a CentOS Linux VM in Microsoft Azure (Microsoft Azure の CentOS Linux VM 上での Redis の実行)] 」のページでは、Azure VM として実行される Redis ノードの構築および設定方法を示す例について説明しています。</span><span class="sxs-lookup"><span data-stu-id="5c841-748">The page [Running Redis on a CentOS Linux VM in Azure] on the Microsoft website walks through an example that shows you how to build and configure a Redis node running as an Azure VM.</span></span>
>
>

<span data-ttu-id="5c841-749">Redis Web サイトの「 [Partitioning: how to split data among multiple Redis instances (パーティション分割: 複数の Redis インスタンス間でデータを分割する方法)] 」には、Redis へのパーティション分割の実装に関する詳細情報が記載されています。</span><span class="sxs-lookup"><span data-stu-id="5c841-749">The page [Partitioning: how to split data among multiple Redis instances] on the Redis website provides more information about implementing partitioning with Redis.</span></span> <span data-ttu-id="5c841-750">このセクションの以降の説明では、クライアント側またはプロキシに支援されたパーティション分割を実装していると想定します。</span><span class="sxs-lookup"><span data-stu-id="5c841-750">The remainder of this section assumes that you are implementing client-side or proxy-assisted partitioning.</span></span>

<span data-ttu-id="5c841-751">Azure Redis Cache でデータをパーティション分割する方法を決定する際には、次の点を検討する必要があります。</span><span class="sxs-lookup"><span data-stu-id="5c841-751">Consider the following points when deciding how to partition data with Azure Redis Cache:</span></span>

* <span data-ttu-id="5c841-752">Azure Redis Cache は恒久的なデータ ストアとして動作するようには意図されていません。このため、実装するパーティション分割構成に関係なく、アプリケーション コードはキャッシュではない場所からデータを取得できる必要があります。</span><span class="sxs-lookup"><span data-stu-id="5c841-752">Azure Redis Cache is not intended to act as a permanent data store, so whatever partitioning scheme you implement, your application code must be able to retrieve data from a location that's not the cache.</span></span>
* <span data-ttu-id="5c841-753">頻繁に一緒にアクセスされるデータは、同一パーティションに維持する必要があります。</span><span class="sxs-lookup"><span data-stu-id="5c841-753">Data that is frequently accessed together should be kept in the same partition.</span></span> <span data-ttu-id="5c841-754">Redis は強力なキー値ストアで、データを構造化するための高度に最適化された一連のメカニズムを提供します。</span><span class="sxs-lookup"><span data-stu-id="5c841-754">Redis is a powerful key-value store that provides several highly optimized mechanisms for structuring data.</span></span> <span data-ttu-id="5c841-755">次のようなメカニズムがあります。</span><span class="sxs-lookup"><span data-stu-id="5c841-755">These mechanisms can be one of the following:</span></span>

  * <span data-ttu-id="5c841-756">単純な文字列 (最大 512 MB の長さバイナリ データ)</span><span class="sxs-lookup"><span data-stu-id="5c841-756">Simple strings (binary data up to 512 MB in length)</span></span>
  * <span data-ttu-id="5c841-757">リストなどの集約型 (キューおよびスタックとして動作可能)</span><span class="sxs-lookup"><span data-stu-id="5c841-757">Aggregate types such as lists (which can act as queues and stacks)</span></span>
  * <span data-ttu-id="5c841-758">セット (順序ありおよび順序なし)</span><span class="sxs-lookup"><span data-stu-id="5c841-758">Sets (ordered and unordered)</span></span>
  * <span data-ttu-id="5c841-759">ハッシュ (オブジェクト内のフィールドを表す項目などの関連するフィールドをグループ化することが可能)</span><span class="sxs-lookup"><span data-stu-id="5c841-759">Hashes (which can group related fields together, such as the items that represent the fields in an object)</span></span>
* <span data-ttu-id="5c841-760">集約型を使用すると、多くの関連する値を同じキーに関連付けることができます。</span><span class="sxs-lookup"><span data-stu-id="5c841-760">The aggregate types enable you to associate many related values with the same key.</span></span> <span data-ttu-id="5c841-761">Redis キーは、それが含むデータ項目ではなく、リスト、セット、またはハッシュを識別します。</span><span class="sxs-lookup"><span data-stu-id="5c841-761">A Redis key identifies a list, set, or hash rather than the data items that it contains.</span></span> <span data-ttu-id="5c841-762">これらの型は、Azure Redis Cache ですべて利用できます。詳細については、Redis Web サイトの「[Data Types (データ型)]」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="5c841-762">These types are all available with Azure Redis Cache and are described by the [Data types] page on the Redis website.</span></span> <span data-ttu-id="5c841-763">たとえば、顧客により登録された注文を追跡する e コマース システムの一部として、各顧客の詳細情報を、顧客 ID をキーとして使用して Redis ハッシュに格納できる場合があります。</span><span class="sxs-lookup"><span data-stu-id="5c841-763">For example, in part of an e-commerce system that tracks the orders that are placed by customers, the details of each customer can be stored in a Redis hash that is keyed by using the customer ID.</span></span> <span data-ttu-id="5c841-764">各ハッシュは、その顧客の注文 ID のコレクションを保持することができます。</span><span class="sxs-lookup"><span data-stu-id="5c841-764">Each hash can hold a collection of order IDs for the customer.</span></span> <span data-ttu-id="5c841-765">別の Redis セットで注文を保持することもできます。この場合も、ハッシュとして構造化され、注文 ID をキーとして使用します。</span><span class="sxs-lookup"><span data-stu-id="5c841-765">A separate Redis set can hold the orders, again structured as hashes, and keyed by using the order ID.</span></span> <span data-ttu-id="5c841-766">図 8 に、この構造を示します。</span><span class="sxs-lookup"><span data-stu-id="5c841-766">Figure 8 shows this structure.</span></span> <span data-ttu-id="5c841-767">Redis では、いずれの形態の参照整合性も実装しないので、開発者は、顧客と注文の間の関係を維持するロジックを組み込む必要があります。</span><span class="sxs-lookup"><span data-stu-id="5c841-767">Note that Redis does not implement any form of referential integrity, so it is the developer's responsibility to maintain the relationships between customers and orders.</span></span>

![顧客の注文とそれらの詳細情報を記録するために Redis ストレージで想定される構造](./images/data-partitioning/RedisCustomersandOrders.png)

<span data-ttu-id="5c841-769">*図 8: 顧客の注文とそれらの詳細情報を記録するために Redis ストレージで想定される構造*</span><span class="sxs-lookup"><span data-stu-id="5c841-769">*Figure 8. Suggested structure in Redis storage for recording customer orders and their details*</span></span>

> [!NOTE]
> <span data-ttu-id="5c841-770">Redis では、すべてのキーは、Redis 文字列と同じようなバイナリ データ値で、最大で 512 MB のデータを含むことができます。</span><span class="sxs-lookup"><span data-stu-id="5c841-770">In Redis, all keys are binary data values (like Redis strings) and can contain up to 512 MB of data.</span></span> <span data-ttu-id="5c841-771">理論的には、キーはあらゆる情報を含むことができます。</span><span class="sxs-lookup"><span data-stu-id="5c841-771">In theory, a key can contain almost any information.</span></span> <span data-ttu-id="5c841-772">ただし、キーに対して一貫した名前付け規則を適用し、データの型をわかりやすく表し、エンティティを識別し、しかも過度に長すぎないような名前を割り当てることをお勧めします。</span><span class="sxs-lookup"><span data-stu-id="5c841-772">However, we recommend adopting a consistent naming convention for keys that is descriptive of the type of data and that identifies the entity, but is not excessively long.</span></span> <span data-ttu-id="5c841-773">一般的な方法では、"entity_type:ID" の形のキーを使用します。</span><span class="sxs-lookup"><span data-stu-id="5c841-773">A common approach is to use keys of the form "entity_type:ID".</span></span> <span data-ttu-id="5c841-774">たとえば、"customer:99" は ID 99 の顧客のキーを示します。</span><span class="sxs-lookup"><span data-stu-id="5c841-774">For example, you can use "customer:99" to indicate the key for a customer with the ID 99.</span></span>
>
>

* <span data-ttu-id="5c841-775">関連する情報を同一データベースの異なる集約型に格納することによって、垂直的パーティション分割を実装できます。</span><span class="sxs-lookup"><span data-stu-id="5c841-775">You can implement vertical partitioning by storing related information in different aggregations in the same database.</span></span> <span data-ttu-id="5c841-776">たとえば、e コマース アプリケーションで、製品について共通してアクセスされる情報を 1 つの Redis ハッシュに格納し、アクセス頻度の低い詳細情報を別の Redis ハッシュに格納できることがあります。</span><span class="sxs-lookup"><span data-stu-id="5c841-776">For example, in an e-commerce application, you can store commonly accessed information about products in one Redis hash and less frequently used detailed information in another.</span></span>
  <span data-ttu-id="5c841-777">両方のハッシュはキーの一部として同じ製品 ID を使用できます。</span><span class="sxs-lookup"><span data-stu-id="5c841-777">Both hashes can use the same product ID as part of the key.</span></span> <span data-ttu-id="5c841-778">たとえば、製品情報用の "product: *nn*" (*nn* は製品 ID) や詳細データ用の "product_details: *nn*" を使用できます。</span><span class="sxs-lookup"><span data-stu-id="5c841-778">For example, you can use "product: *nn*" (where *nn* is the product ID) for the product information and "product_details: *nn*" for the detailed data.</span></span> <span data-ttu-id="5c841-779">この戦略は、ほとんどのクエリが取得する可能性が高いデータの量を少なくするのに役立てることができます。</span><span class="sxs-lookup"><span data-stu-id="5c841-779">This strategy can help reduce the volume of data that most queries are likely to retrieve.</span></span>
* <span data-ttu-id="5c841-780">Redis データ ストアを再パーティションできますが、複雑で時間のかかる作業であることに留意してください。</span><span class="sxs-lookup"><span data-stu-id="5c841-780">You can repartition a Redis data store, but keep in mind that it's a complex and time-consuming task.</span></span> <span data-ttu-id="5c841-781">Redis クラスタリングではデータの再パーティション分割を自動的に実行できますが、この機能は、Azure Redis Cache とは併用できません。</span><span class="sxs-lookup"><span data-stu-id="5c841-781">Redis clustering can repartition data automatically, but this capability is not available with Azure Redis Cache.</span></span> <span data-ttu-id="5c841-782">このため、パーティション分割構成を設計する際には、各パーティションに十分な空き領域を確保して、予想される将来のデータ増加に最初から備える必要があります。</span><span class="sxs-lookup"><span data-stu-id="5c841-782">Therefore, when you design your partitioning scheme, try to leave sufficient free space in each partition to allow for expected data growth over time.</span></span> <span data-ttu-id="5c841-783">ただし、Azure Redis Cache はデータを一時的にキャッシュすることを意図しており、キャッシュに保持されるデータは有効期間 (TTL) 値として指定される期間だけ有効であることに注意する必要があります。</span><span class="sxs-lookup"><span data-stu-id="5c841-783">However, remember that Azure Redis Cache is intended to cache data temporarily, and that data held in the cache can have a limited lifetime specified as a time-to-live (TTL) value.</span></span> <span data-ttu-id="5c841-784">揮発性が比較的高いデータでは TTL を短くできますが、静的なデータでは、TTL を非常に長くすることができます。</span><span class="sxs-lookup"><span data-stu-id="5c841-784">For relatively volatile data, the TTL can be short, but for static data the TTL can be a lot longer.</span></span> <span data-ttu-id="5c841-785">有効期間の長いデータをキャッシュに大量に格納しないでください。そのデータにより、キャッシュがいっぱいになる可能性があります。</span><span class="sxs-lookup"><span data-stu-id="5c841-785">Avoid storing large amounts of long-lived data in the cache if the volume of this data is likely to fill the cache.</span></span> <span data-ttu-id="5c841-786">強制退去ポリシーを指定して、利用できる領域が少ない場合に Azure Redis Cache がデータを削除できるようにすることができます。</span><span class="sxs-lookup"><span data-stu-id="5c841-786">You can specify an eviction policy that causes Azure Redis Cache to remove data if space is at a premium.</span></span>

  > [!NOTE]
  > <span data-ttu-id="5c841-787">Azure Redis Cache を使用する場合は、適切な価格レベルを選択することにより、キャッシュの最大サイズを 250 MB から 53 GB の範囲で指定します。</span><span class="sxs-lookup"><span data-stu-id="5c841-787">When you use Azure Redis cache, you specify the maximum size of the cache (from 250 MB to 53 GB) by selecting the appropriate pricing tier.</span></span> <span data-ttu-id="5c841-788">ただし、いったん Azure Redis Cache を作成したら、その後にはサイズを大きくしたり小さくしたりすることはできません。</span><span class="sxs-lookup"><span data-stu-id="5c841-788">However, after an Azure Redis Cache has been created, you cannot increase (or decrease) its size.</span></span>
  >
  >
* <span data-ttu-id="5c841-789">Redis のバッチおよびトランザクションは、複数の接続を利用できないので、バッチまたはトランザクションによりアクセスされるすべてのデータは同一のデータベース (シャード) で保持する必要があります。</span><span class="sxs-lookup"><span data-stu-id="5c841-789">Redis batches and transactions cannot span multiple connections, so all data that is affected by a batch or transaction should be held in the same database (shard).</span></span>

  > [!NOTE]
  > <span data-ttu-id="5c841-790">Redis トランザクションの一連の操作は、必ずしもアトミックである必要はありません。</span><span class="sxs-lookup"><span data-stu-id="5c841-790">A sequence of operations in a Redis transaction is not necessarily atomic.</span></span> <span data-ttu-id="5c841-791">トランザクションを構成するコマンドは、実行前に検証されてキューに登録されます。</span><span class="sxs-lookup"><span data-stu-id="5c841-791">The commands that compose a transaction are verified and queued before they run.</span></span> <span data-ttu-id="5c841-792">この段階でエラーが発生すると、キュー全体が破棄されます。</span><span class="sxs-lookup"><span data-stu-id="5c841-792">If an error occurs during this phase, the entire queue is discarded.</span></span> <span data-ttu-id="5c841-793">ただし、トランザクションが正常に発行されると、キューに登録されていた一連のコマンドが正しい順序で実行されます。</span><span class="sxs-lookup"><span data-stu-id="5c841-793">However, after the transaction has been successfully submitted, the queued commands run in sequence.</span></span> <span data-ttu-id="5c841-794">いずれかのコマンドで障害が発生すると、そのコマンドの実行だけが中止されます。</span><span class="sxs-lookup"><span data-stu-id="5c841-794">If any command fails, only that command stops running.</span></span> <span data-ttu-id="5c841-795">キュー内の前後にあるコマンドはすべて実行されます。</span><span class="sxs-lookup"><span data-stu-id="5c841-795">All previous and subsequent commands in the queue are performed.</span></span> <span data-ttu-id="5c841-796">詳細については、Redis Web サイトの「 [Transactions (トランザクション)] 」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="5c841-796">For more information, go to the [Transactions] page on the Redis website.</span></span>
  >
  >
* <span data-ttu-id="5c841-797">Redis は、限定された数のアトミック操作をサポートします。</span><span class="sxs-lookup"><span data-stu-id="5c841-797">Redis supports a limited number of atomic operations.</span></span> <span data-ttu-id="5c841-798">複数のキーと値をサポートするこの種の操作は、MGET 操作と MSET 操作だけです。</span><span class="sxs-lookup"><span data-stu-id="5c841-798">The only operations of this type that support multiple keys and values are MGET and MSET operations.</span></span> <span data-ttu-id="5c841-799">MGET 操作は指定したキー リストの値のコレクションを返し、MSET 操作は指定したキー リストの値のコレクションを格納します。</span><span class="sxs-lookup"><span data-stu-id="5c841-799">MGET operations return a collection of values for a specified list of keys, and MSET operations store a collection of values for a specified list of keys.</span></span> <span data-ttu-id="5c841-800">これらの操作を使用する必要がある場合、MSET コマンドと MGET コマンドによって参照されるキー値ペアは、同一のデータベースに格納される必要があります。</span><span class="sxs-lookup"><span data-stu-id="5c841-800">If you need to use these operations, the key-value pairs that are referenced by the MSET and MGET commands must be stored within the same database.</span></span>

## <a name="partitioning-strategies-for-azure-service-fabric"></a><span data-ttu-id="5c841-801">Azure Service Fabric のためのパーティション分割戦略</span><span class="sxs-lookup"><span data-stu-id="5c841-801">Partitioning Strategies for Azure Service Fabric</span></span>
<span data-ttu-id="5c841-802">Azure Service Fabric は、クラウドの分散アプリケーションにランタイムを提供する microservices プラットフォームです。</span><span class="sxs-lookup"><span data-stu-id="5c841-802">Azure Service Fabric is a microservices platform that provides a runtime for distributed applications in the cloud.</span></span> <span data-ttu-id="5c841-803">Service Fabric は、.Net ゲストの実行可能ファイル、ステートフルおよびステートレスなサービス、およびコンテナーをサポートしています。</span><span class="sxs-lookup"><span data-stu-id="5c841-803">Service Fabric supports .Net guest executables, stateful and stateless services, and containers.</span></span> <span data-ttu-id="5c841-804">ステートフルなサービスは、Service Fabric クラスター内のキー値コレクションにデータを永続的に格納する[信頼性の高いコレクション][service-fabric-reliable-collections]を提供します。</span><span class="sxs-lookup"><span data-stu-id="5c841-804">Stateful services provide a [reliable collection][service-fabric-reliable-collections] to persistently store data in a key-value collection within the Service Fabric cluster.</span></span> <span data-ttu-id="5c841-805">信頼性の高いコレクション内のパーティション分割キー戦略の詳細については、[信頼性の高い Azure Service Fabric コレクションのためのガイドラインと推奨事項]を参照してください。</span><span class="sxs-lookup"><span data-stu-id="5c841-805">For more information about strategies for partioning keys in a reliable collection, see [guidelines and recommendations for reliable collections in Azure Service Fabric].</span></span>

### <a name="more-information"></a><span data-ttu-id="5c841-806">詳細情報</span><span class="sxs-lookup"><span data-stu-id="5c841-806">More information</span></span>
* <span data-ttu-id="5c841-807">[Azure Service Fabric の概要]は、Azure Service Fabric の導入です。</span><span class="sxs-lookup"><span data-stu-id="5c841-807">[Overview of Azure Service Fabric] is an introduction to Azure Service Fabric.</span></span>
* <span data-ttu-id="5c841-808">[Partition Service Fabric 信頼性の高いサービス]では、Azure Service Fabric で信頼性の高いサービスについて詳しく説明しています。</span><span class="sxs-lookup"><span data-stu-id="5c841-808">[Partition Service Fabric reliable services] provides more information about reliable services in Azure Service Fabric.</span></span>

## <a name="partitioning-strategies-for-azure-event-hubs"></a><span data-ttu-id="5c841-809">Azure Event Hubs のためのパーティション分割戦略</span><span class="sxs-lookup"><span data-stu-id="5c841-809">Partitioning strategies for Azure Event Hubs</span></span>

<span data-ttu-id="5c841-810">[Azure Event Hubs][event-hubs] は、大規模なデータ ストリーミングのために設計されており、パーティション分割は、水平方向のスケーリングを可能にするためにサービスに組み込まれています。</span><span class="sxs-lookup"><span data-stu-id="5c841-810">[Azure Event Hubs][event-hubs] is designed for data streaming at massive scale, and partitioning is built into the service to enable horizontal scaling.</span></span> <span data-ttu-id="5c841-811">各コンシューマーは、メッセージ ストリームの特定のパーティションのみを読み取ります。</span><span class="sxs-lookup"><span data-stu-id="5c841-811">Each consumer only reads a specific partition of the message stream.</span></span> 

<span data-ttu-id="5c841-812">イベント発行元は、そのパーティション キーのみを認識し、イベントの発行先となるパーティションは認識しません。</span><span class="sxs-lookup"><span data-stu-id="5c841-812">The event publisher is only aware of its partition key, not the partition to which the events are published.</span></span> <span data-ttu-id="5c841-813">このようにキーとパーティションを分離することにより、送信者はダウンストリーム処理について余分な情報を把握しなくてもよくなります。</span><span class="sxs-lookup"><span data-stu-id="5c841-813">This decoupling of key and partition insulates the sender from needing to know too much about the downstream processing.</span></span> <span data-ttu-id="5c841-814">(特定のパーティションにイベントを直接送信することも可能ですが、通常は推奨されません)。</span><span class="sxs-lookup"><span data-stu-id="5c841-814">(It's also possible send events directly to a given partition, but generally that's not recommended.)</span></span>  

<span data-ttu-id="5c841-815">パーティション数を選択する場合は、長期間にわたる拡張を考慮してください。</span><span class="sxs-lookup"><span data-stu-id="5c841-815">Consider long-term scale when you select the partition count.</span></span> <span data-ttu-id="5c841-816">Event hub を作成した後は、パーティションの数を変更できません。</span><span class="sxs-lookup"><span data-stu-id="5c841-816">After an event hub is created, you can't change the number of partitions.</span></span> 

<span data-ttu-id="5c841-817">Event Hubs でのパーティションの使用の詳細については、「[Event Hubs とは]」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="5c841-817">For more information about using partitions in Event Hubs, see [What is Event Hubs?].</span></span>

<span data-ttu-id="5c841-818">可用性と一貫性の間のトレードオフに関する詳細については、「[Event Hubs における可用性と一貫性]」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="5c841-818">For considerations about trade-offs between availability and consistency, see [Availability and consistency in Event Hubs].</span></span>

## <a name="rebalancing-partitions"></a><span data-ttu-id="5c841-819">パーティションの再調整</span><span class="sxs-lookup"><span data-stu-id="5c841-819">Rebalancing partitions</span></span>
<span data-ttu-id="5c841-820">システムが安定し、使用パターンについての理解が深まると、パーティション分割構成の調整が必要になることがあります。</span><span class="sxs-lookup"><span data-stu-id="5c841-820">As a system matures and you understand the usage patterns better, you might have to adjust the partitioning scheme.</span></span> <span data-ttu-id="5c841-821">たとえば、パーティション間でトラフィック量に不均衡が生じ、特定のパーティションがホットスポットになり、過度な競合が発生しているために起きることがあります。</span><span class="sxs-lookup"><span data-stu-id="5c841-821">For example, individual partitions might start attracting a disproportionate volume of traffic and become hot, leading to excessive contention.</span></span> <span data-ttu-id="5c841-822">また、一部のパーティションでデータ量が過少に見積もられており、これらのパーティションでストレージ容量の制限に近づいていることもあります。</span><span class="sxs-lookup"><span data-stu-id="5c841-822">Additionally, you might have underestimated the volume of data in some partitions, causing you to approach the limits of the storage capacity in these partitions.</span></span> <span data-ttu-id="5c841-823">原因が何であるかに関係なく、パーティションを再調整して、負荷をより均等に分散することが必要になることがあります。</span><span class="sxs-lookup"><span data-stu-id="5c841-823">Whatever the cause, it is sometimes necessary to rebalance partitions to spread the load more evenly.</span></span>

<span data-ttu-id="5c841-824">状況によっては、データをサーバーに透過的に割り当てているデータ ストレージ システムは、利用可能なリソースの制限内でパーティションを自動的に再調整できます。</span><span class="sxs-lookup"><span data-stu-id="5c841-824">In some cases, data storage systems that don't publicly expose how data is allocated to servers can automatically rebalance partitions within the limits of the resources available.</span></span> <span data-ttu-id="5c841-825">その他の状況では、再調整は、次の 2 段階で構成される管理タスクとなります。</span><span class="sxs-lookup"><span data-stu-id="5c841-825">In other situations, rebalancing is an administrative task that consists of two stages:</span></span>

1. <span data-ttu-id="5c841-826">新しいパーティション分割戦略を決定します。</span><span class="sxs-lookup"><span data-stu-id="5c841-826">Determining the new partitioning strategy to ascertain:</span></span>
   * <span data-ttu-id="5c841-827">分割またはマージすることが必要なパーティション。</span><span class="sxs-lookup"><span data-stu-id="5c841-827">Which partitions might need to be split (or possibly combined).</span></span>
   * <span data-ttu-id="5c841-828">新しいパーティション キーを設計してこれらの新しいパーティションにデータを割り当てる方法。</span><span class="sxs-lookup"><span data-stu-id="5c841-828">How to allocate data to these new partitions by designing new partition keys.</span></span>
2. <span data-ttu-id="5c841-829">影響を受けるデータを古いパーティション分割構成から一連の新しいパーティションに移行します。</span><span class="sxs-lookup"><span data-stu-id="5c841-829">Migrating the affected data from the old partitioning scheme to the new set of partitions.</span></span>

> [!NOTE]
> <span data-ttu-id="5c841-830">Cosmos DB データベース コレクションからサーバーへのマッピングは透過的に行われますが、それでも、Cosmos DB アカウントのストレージ容量とスループットの上限に達する可能性があります。</span><span class="sxs-lookup"><span data-stu-id="5c841-830">The mapping of database collections to servers is transparent, but you can still reach the storage capacity and throughput limits of a Cosmos DB account.</span></span> <span data-ttu-id="5c841-831">その場合、パーティション分割構成を再設計し、データを移行することが必要になることがあります。</span><span class="sxs-lookup"><span data-stu-id="5c841-831">If this happens, you might need to redesign your partitioning scheme and migrate the data.</span></span>
>
>

<span data-ttu-id="5c841-832">データ ストレージのテクノロジとデータ ストレージ システムの設計によっては、パーティションが使用されている間に、データをパーティション間で移行できることがあります (オンライン移行)。</span><span class="sxs-lookup"><span data-stu-id="5c841-832">Depending on the data storage technology and the design of your data storage system, you might be able to migrate data between partitions while they are in use (online migration).</span></span> <span data-ttu-id="5c841-833">これが不可能な場合、データを再配置する間、影響を受けるパーティションを一時的に利用できないようにすることが必要になることがあります (オフライン移行)。</span><span class="sxs-lookup"><span data-stu-id="5c841-833">If this isn't possible, you might need to make the affected partitions temporarily unavailable while the data is relocated (offline migration).</span></span>

## <a name="offline-migration"></a><span data-ttu-id="5c841-834">オフライン移行</span><span class="sxs-lookup"><span data-stu-id="5c841-834">Offline migration</span></span>
<span data-ttu-id="5c841-835">オフライン移行は、競合が発生する機会を少なくするので、ほぼ間違いなく、最も簡単な手法です。</span><span class="sxs-lookup"><span data-stu-id="5c841-835">Offline migration is arguably the simplest approach because it reduces the chances of contention occurring.</span></span> <span data-ttu-id="5c841-836">データは、移動および再構成時に変更されることはありません。</span><span class="sxs-lookup"><span data-stu-id="5c841-836">Don't make any changes to the data while it is being moved and restructured.</span></span>

<span data-ttu-id="5c841-837">概念的に、このプロセスには次の手順が含まれます。</span><span class="sxs-lookup"><span data-stu-id="5c841-837">Conceptually, this process includes the following steps:</span></span>

1. <span data-ttu-id="5c841-838">シャードをオフラインにします。</span><span class="sxs-lookup"><span data-stu-id="5c841-838">Mark the shard offline.</span></span>
2. <span data-ttu-id="5c841-839">データを分割マージして、新しいシャードに移動します。</span><span class="sxs-lookup"><span data-stu-id="5c841-839">Split-merge and move the data to the new shards.</span></span>
3. <span data-ttu-id="5c841-840">データを検証します。</span><span class="sxs-lookup"><span data-stu-id="5c841-840">Verify the data.</span></span>
4. <span data-ttu-id="5c841-841">新しいシャードをオンラインにします。</span><span class="sxs-lookup"><span data-stu-id="5c841-841">Bring the new shards online.</span></span>
5. <span data-ttu-id="5c841-842">古いシャードを削除します。</span><span class="sxs-lookup"><span data-stu-id="5c841-842">Remove the old shard.</span></span>

<span data-ttu-id="5c841-843">データを部分的に利用できるようにするために、手順 1 で元のシャードを利用不能にする代わりに、読み取り専用にすることもできます。</span><span class="sxs-lookup"><span data-stu-id="5c841-843">To retain some availability, you can mark the original shard as read-only in step 1 rather than making it unavailable.</span></span> <span data-ttu-id="5c841-844">これにより、データが移動されている間、アプリケーションはデータを読み込むことができます。ただし、変更することはできません。</span><span class="sxs-lookup"><span data-stu-id="5c841-844">This allows applications to read the data while it is being moved but not to change it.</span></span>

## <a name="online-migration"></a><span data-ttu-id="5c841-845">オンライン移行</span><span class="sxs-lookup"><span data-stu-id="5c841-845">Online migration</span></span>
<span data-ttu-id="5c841-846">オンライン移行は、実行するのにより複雑な操作を必要としますが、手順全体を通してデータが利用できるので、ユーザーにとってはサービスの中断がより少なくなります。</span><span class="sxs-lookup"><span data-stu-id="5c841-846">Online migration is more complex to perform but less disruptive to users because data remains available during the entire procedure.</span></span> <span data-ttu-id="5c841-847">プロセスは、オフライン移行で使用されるものと類似していますが、元のシャードがオフラインになることはありません (手順 1.)。</span><span class="sxs-lookup"><span data-stu-id="5c841-847">The process is similar to that used by offline migration, except that the original shard is not marked offline (step 1).</span></span> <span data-ttu-id="5c841-848">移行プロセスの粒度 (たとえば、項目単位に行われるか、またはシャード単位か) に応じて、クライアント アプリケーションのデータ アクセス コードは、2 つの場所 (元のシャードと新しいシャード) に対してデータの読み書きを処理することが必要になる場合があります。</span><span class="sxs-lookup"><span data-stu-id="5c841-848">Depending on the granularity of the migration process (for example, whether it's done item by item or shard by shard), the data access code in the client applications might have to handle reading and writing data that's held in two locations (the original shard and the new shard).</span></span>

<span data-ttu-id="5c841-849">オンライン移行をサポートするソリューションの例については、Microsoft Web サイトの「 [Elastic Database 分割/マージ ツールを使用したスケーリング] 」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="5c841-849">For an example of a solution that supports online migration, see the article [Scaling using the Elastic Database split-merge tool] on the Microsoft website.</span></span>

## <a name="related-patterns-and-guidance"></a><span data-ttu-id="5c841-850">関連のあるパターンとガイダンス</span><span class="sxs-lookup"><span data-stu-id="5c841-850">Related patterns and guidance</span></span>
<span data-ttu-id="5c841-851">データの一貫性を実装するための戦略を検討するときは、次のパターンもシナリオに関連する可能性があります。</span><span class="sxs-lookup"><span data-stu-id="5c841-851">When considering strategies for implementing data consistency, the following patterns might also be relevant to your scenario:</span></span>

* <span data-ttu-id="5c841-852">Microsoft Web サイトの「[Data consistency primer (データ整合性入門)]」のページでは、クラウドなどの分散環境で一貫性を維持するための戦略が説明されています。</span><span class="sxs-lookup"><span data-stu-id="5c841-852">The [Data consistency primer] page on the Microsoft website describes strategies for maintaining consistency in a distributed environment such as the cloud.</span></span>
* <span data-ttu-id="5c841-853">Microsoft Web サイトの「[Data Partitioning Guidance (データ パーティション分割ガイダンス)]」のページでは、分散ソリューションのさまざまな条件を満たすためにパーティションを設計する作業の全般的な概要が説明されています。</span><span class="sxs-lookup"><span data-stu-id="5c841-853">The [Data partitioning guidance] page on the Microsoft website provides a general overview of how to design partitions to meet various criteria in a distributed solution.</span></span>
* <span data-ttu-id="5c841-854">Microsoft Web サイトの「[Sharding Pattern (シャーディング パターン)]」では、データをシャーディングするための一般的な戦略の概要が説明されています。</span><span class="sxs-lookup"><span data-stu-id="5c841-854">The [sharding pattern] as described on the Microsoft website summarizes some common strategies for sharding data.</span></span>
* <span data-ttu-id="5c841-855">Microsoft Web サイトの「[Index Table Pattern (インデックス テーブル パターン)]」では、データに対してセカンダリ インデックスを作成する方法が説明されています。</span><span class="sxs-lookup"><span data-stu-id="5c841-855">The [index table pattern] as described on the Microsoft website illustrates how to create secondary indexes over data.</span></span> <span data-ttu-id="5c841-856">この手法を使用すると、アプリケーションは、コレクションのプライマリ キーを参照しないクエリで、データをすばやく取得できます。</span><span class="sxs-lookup"><span data-stu-id="5c841-856">An application can quickly retrieve data with this approach, by using queries that do not reference the primary key of a collection.</span></span>
* <span data-ttu-id="5c841-857">Microsoft Web サイトの「[Materialized View Pattern (具体化されたビュー パターン)]」では、高速なクエリ操作をサポートするために、データを要約し、かつデータが事前に取り込まれているビューを生成する方法が説明されています。</span><span class="sxs-lookup"><span data-stu-id="5c841-857">The [materialized view pattern] as described on the Microsoft website describes how to generate pre-populated views that summarize data to support fast query operations.</span></span> <span data-ttu-id="5c841-858">この手法は、要約対象のデータを含むパーティションが複数のサイトにまたがって分散されている場合に、パーティション分割されたデータ ストアで役立つ可能性があります。</span><span class="sxs-lookup"><span data-stu-id="5c841-858">This approach can be useful in a partitioned data store if the partitions that contain the data being summarized are distributed across multiple sites.</span></span>
* <span data-ttu-id="5c841-859">Microsoft Web サイトの [Azure Content Delivery Network の使用] に関する記事では、Azure で Content Delivery Network を構成および使用するための詳細なガイダンスが提供されています。</span><span class="sxs-lookup"><span data-stu-id="5c841-859">The [Using Azure Content Delivery Network] article on the Microsoft website provides additional guidance on configuring and using Content Delivery Network with Azure.</span></span>

## <a name="more-information"></a><span data-ttu-id="5c841-860">詳細情報</span><span class="sxs-lookup"><span data-stu-id="5c841-860">More information</span></span>
* <span data-ttu-id="5c841-861">Microsoft Web サイトの「[SQL Database とは]」のページでは、SQL データベースを作成および使用する方法が詳細に説明されています。</span><span class="sxs-lookup"><span data-stu-id="5c841-861">The page [What is Azure SQL Database?] on the Microsoft website provides detailed documentation that describes how to create and use SQL databases.</span></span>
* <span data-ttu-id="5c841-862">Microsoft Web サイトの「[Elastic Database の機能の概要]」ページでは、Elastic Database が包括的に説明されています。</span><span class="sxs-lookup"><span data-stu-id="5c841-862">The page [Elastic Database features overview] on the Microsoft website provides a comprehensive introduction to Elastic Database.</span></span>
* <span data-ttu-id="5c841-863">Microsoft Web サイトの「[Elastic Database 分割/マージ ツールを使用したスケーリング]」のページでは、Split/Merge サービスを使用して Elastic Database シャードを管理する方法が説明されています。</span><span class="sxs-lookup"><span data-stu-id="5c841-863">The page [Scaling using the Elastic Database split-merge tool] on the Microsoft website contains information about using the split-merge service to manage Elastic Database shards.</span></span>
* <span data-ttu-id="5c841-864">Microsoft Web サイトの「[Azure Storage のスケーラビリティおよびパフォーマンスのターゲット](https://msdn.microsoft.com/library/azure/dn249410.aspx)」ページでは、Azure Storage のサイズとスループットに関する現在の制限が説明されています。</span><span class="sxs-lookup"><span data-stu-id="5c841-864">The page [Azure storage scalability and performance targets](https://msdn.microsoft.com/library/azure/dn249410.aspx) on the Microsoft website documents the current sizing and throughput limits of Azure Storage.</span></span>
* <span data-ttu-id="5c841-865">Microsoft Web サイトの「[エンティティ グループ トランザクションの実行]」ページでは、Azure Table Storage に格納されているエンティティを対象にするトランザクション操作を実装する方法が、詳細に説明されています。</span><span class="sxs-lookup"><span data-stu-id="5c841-865">The page [Performing entity group transactions] on the Microsoft website provides detailed information about implementing transactional operations over entities that are stored in Azure table storage.</span></span>
* <span data-ttu-id="5c841-866">Microsoft Web サイトの「[Azure Table Storage の設計ガイド]」の記事では、Azure Table Storage でデータをパーティション分割する方法が詳細に説明されています。</span><span class="sxs-lookup"><span data-stu-id="5c841-866">The article [Azure Storage table design guide] on the Microsoft website contains detailed information about partitioning data in Azure table storage.</span></span>
* <span data-ttu-id="5c841-867">Microsoft Web サイトの [Azure Content Delivery Network の使用] に関するページでは、Azure Content Delivery Network を使用して、Azure Blob Storage に保持されているデータをレプリケートする方法が説明されています。</span><span class="sxs-lookup"><span data-stu-id="5c841-867">The page [Using Azure Content Delivery Network] on the Microsoft website describes how to replicate data that's held in Azure blob storage by using the Azure Content Delivery Network.</span></span>
* <span data-ttu-id="5c841-868">Microsoft Web サイトの「[Azure Search とは]」ページでは、Azure Search で利用できる機能が詳細に説明されています。</span><span class="sxs-lookup"><span data-stu-id="5c841-868">The page [What is Azure Search?] on the Microsoft website provides a full description of the capabilities that are available in Azure Search.</span></span>
* <span data-ttu-id="5c841-869">Microsoft Web サイトの「[Azure Search サービスの制限]」のページでは、Azure Search の各インスタンスの容量が説明されています。</span><span class="sxs-lookup"><span data-stu-id="5c841-869">The page [Service limits in Azure Search] on the Microsoft website contains information about the capacity of each instance of Azure Search.</span></span>
* <span data-ttu-id="5c841-870">Microsoft Web サイトの「[サポートされるデータ型 (Azure Search)]」のページでは、検索可能ドキュメントおよびインデックスとして使用可能なデータ型の概要が説明されています。</span><span class="sxs-lookup"><span data-stu-id="5c841-870">The page [Supported data types (Azure Search)] on the Microsoft website summarizes the data types that you can use in searchable documents and indexes.</span></span>
* <span data-ttu-id="5c841-871">Microsoft Web サイトの「[Azure Redis Cache]」のページでは、Azure Redis Cache の概要が説明されています。</span><span class="sxs-lookup"><span data-stu-id="5c841-871">The page [Azure Redis Cache] on the Microsoft website provides an introduction to Azure Redis Cache.</span></span>
* <span data-ttu-id="5c841-872">Redis Web サイトの「[Partitioning: how to split data among multiple Redis instances (パーティション分割: 複数の Redis インスタンス間でデータを分割する方法)]」のページでは、Redis でパーティション分割を実装する方法が説明されています。</span><span class="sxs-lookup"><span data-stu-id="5c841-872">The [Partitioning: how to split data among multiple Redis instances] page on the Redis website provides information about how to implement partitioning with Redis.</span></span>
* <span data-ttu-id="5c841-873">Microsoft Web サイトの「[Running Redis on a CentOS Linux VM in Microsoft Azure (Microsoft Azure の CentOS Linux VM 上での Redis の実行)]」のページでは、Azure VM として実行される Redis ノードの構築および設定方法を示す例について説明しています。</span><span class="sxs-lookup"><span data-stu-id="5c841-873">The page [Running Redis on a CentOS Linux VM in Azure] on the Microsoft website walks through an example that shows you how to build and configure a Redis node running as an Azure VM.</span></span>
* <span data-ttu-id="5c841-874">Redis Web サイトの「[Data Types (データ型)]」のページでは、Redis および Azure Redis Cache で利用可能なデータ型が説明されています。</span><span class="sxs-lookup"><span data-stu-id="5c841-874">The [Data types] page on the Redis website describes the data types that are available with Redis and Azure Redis Cache.</span></span>

[Event Hubs における可用性と一貫性]: /azure/event-hubs/event-hubs-availability-and-consistency
[Availability and consistency in Event Hubs]: /azure/event-hubs/event-hubs-availability-and-consistency
[azure-limits]: /azure/azure-subscription-service-limits
[Azure Content Delivery Network]: /azure/cdn/cdn-overview
[Azure Redis Cache]: http://azure.microsoft.com/services/cache/
[Azure Storage Scalability and Performance Targets]: /azure/storage/storage-scalability-targets
[Azure Storage Table Design Guide]: /azure/storage/storage-table-design-guide
[Building a Polyglot Solution (多言語ソリューションの構築)]: https://msdn.microsoft.com/library/dn313279.aspx
[Building a Polyglot Solution]: https://msdn.microsoft.com/library/dn313279.aspx
[cosmos-db-ru]: /azure/cosmos-db/request-units
[Data Access for Highly-Scalable Solutions: Using SQL, NoSQL, and Polyglot Persistence (拡張性の高いソリューション用のデータ アクセス: SQL、NoSQL、および Polyglot の永続化機能の使用)]: https://msdn.microsoft.com/library/dn271399.aspx
[Data Access for Highly-Scalable Solutions: Using SQL, NoSQL, and Polyglot Persistence]: https://msdn.microsoft.com/library/dn271399.aspx
[Data consistency primer (データ整合性入門)]: http://aka.ms/Data-Consistency-Primer
[Data consistency primer]: http://aka.ms/Data-Consistency-Primer
[Data Partitioning Guidance]: https://msdn.microsoft.com/library/dn589795.aspx
[Data Types]: http://redis.io/topics/data-types
[cosmosdb-sql-api]: /azure/cosmos-db/sql-api-introduction
[Elastic Database の機能の概要]: /azure/sql-database/sql-database-elastic-scale-introduction
[Elastic Database features overview]: /azure/sql-database/sql-database-elastic-scale-introduction
[event-hubs]: /azure/event-hubs
[Federations Migration Utility]: https://code.msdn.microsoft.com/vstudio/Federations-Migration-ce61e9c1
[信頼性の高い Azure Service Fabric コレクションのためのガイドラインと推奨事項]: /azure/service-fabric/service-fabric-reliable-services-reliable-collections-guidelines
[guidelines and recommendations for reliable collections in Azure Service Fabric]: /azure/service-fabric/service-fabric-reliable-services-reliable-collections-guidelines
[Index Table Pattern]: http://aka.ms/Index-Table-Pattern
[Materialized View Pattern]: http://aka.ms/Materialized-View-Pattern
[マルチシャード クエリ実行]: /azure/sql-database/sql-database-elastic-scale-multishard-querying
[Multi-shard querying]: /azure/sql-database/sql-database-elastic-scale-multishard-querying
[Azure Service Fabric の概要]: /azure/service-fabric/service-fabric-overview
[Overview of Azure Service Fabric]: /azure/service-fabric/service-fabric-overview
[Partition Service Fabric 信頼性の高いサービス]: /azure/service-fabric/service-fabric-concepts-partitioning
[Partition Service Fabric reliable services]: /azure/service-fabric/service-fabric-concepts-partitioning
[Partitioning: how to split data among multiple Redis instances (パーティション分割: 複数の Redis インスタンス間でデータを分割する方法)]: http://redis.io/topics/partitioning
[Partitioning: how to split data among multiple Redis instances]: http://redis.io/topics/partitioning
[Performing Entity Group Transactions (エンティティ グループ トランザクションの実行)]: https://msdn.microsoft.com/library/azure/dd894038.aspx
[Performing Entity Group Transactions]: https://msdn.microsoft.com/library/azure/dd894038.aspx
[Redis cluster tutorial (Redis クラスターのチュートリアル)]: http://redis.io/topics/cluster-tutorial
[Redis cluster tutorial]: http://redis.io/topics/cluster-tutorial
[Running Redis on a CentOS Linux VM in Microsoft Azure (Microsoft Azure の CentOS Linux VM 上での Redis の実行)]: http://blogs.msdn.com/b/tconte/archive/2012/06/08/running-redis-on-a-centos-linux-vm-in-windows-azure.aspx
[Running Redis on a CentOS Linux VM in Azure]: http://blogs.msdn.com/b/tconte/archive/2012/06/08/running-redis-on-a-centos-linux-vm-in-windows-azure.aspx
[Elastic Database 分割/マージ ツールを使用したスケーリング]: /azure/sql-database/sql-database-elastic-scale-overview-split-and-merge
[Scaling using the Elastic Database split-merge tool]: /azure/sql-database/sql-database-elastic-scale-overview-split-and-merge
[Azure Content Delivery Network の使用]: /azure/cdn/cdn-create-new-endpoint
[Using Azure Content Delivery Network]: /azure/cdn/cdn-create-new-endpoint
[Service Bus のクォータ]: /azure/service-bus-messaging/service-bus-quotas
[Service Bus quotas]: /azure/service-bus-messaging/service-bus-quotas
[service-fabric-reliable-collections]: /azure/service-fabric/service-fabric-reliable-services-reliable-collections
[Azure Search サービスの制限]:  /azure/search/search-limits-quotas-capacity
[Service limits in Azure Search]:  /azure/search/search-limits-quotas-capacity
[Sharding Pattern (シャーディング パターン)]: http://aka.ms/Sharding-Pattern
[Sharding pattern]: http://aka.ms/Sharding-Pattern
[Supported data types (Azure Search) (サポートされるデータ型 (Azure Search))]:  https://msdn.microsoft.com/library/azure/dn798938.aspx
[Supported Data Types (Azure Search)]:  https://msdn.microsoft.com/library/azure/dn798938.aspx
[Transactions (トランザクション)]: http://redis.io/topics/transactions
[Transactions]: http://redis.io/topics/transactions
[Event Hubs とは]: /azure/event-hubs/event-hubs-what-is-event-hubs
[What is Event Hubs?]: /azure/event-hubs/event-hubs-what-is-event-hubs
[Azure Search とは]: /azure/search/search-what-is-azure-search
[What is Azure Search?]: /azure/search/search-what-is-azure-search
[SQL Database とは]: /azure/sql-database/sql-database-technical-overview
[What is Azure SQL Database?]: /azure/sql-database/sql-database-technical-overview
