---
title: 回復性に優れた Azure 用アプリケーションの設計
description: 高可用性とディザスター リカバリーのために Azure で回復性に優れたアプリケーションを構築する方法。
author: MikeWasson
ms.date: 05/26/2017
ms.custom: resiliency
ms.openlocfilehash: f5dfca30b3587e198c1c0f99ad4903ed7b0e33d4
ms.sourcegitcommit: 94d50043db63416c4d00cebe927a0c88f78c3219
ms.translationtype: HT
ms.contentlocale: ja-JP
ms.lasthandoff: 09/28/2018
ms.locfileid: "47429290"
---
# <a name="designing-resilient-applications-for-azure"></a><span data-ttu-id="f4753-103">回復性に優れた Azure 用アプリケーションの設計</span><span class="sxs-lookup"><span data-stu-id="f4753-103">Designing resilient applications for Azure</span></span>

<span data-ttu-id="f4753-104">分散システムでは、障害が発生します。</span><span class="sxs-lookup"><span data-stu-id="f4753-104">In a distributed system, failures will happen.</span></span> <span data-ttu-id="f4753-105">ハードウェアの障害が発生することがあります。</span><span class="sxs-lookup"><span data-stu-id="f4753-105">Hardware can fail.</span></span> <span data-ttu-id="f4753-106">ネットワークに一時的な障害が起きることがあります。</span><span class="sxs-lookup"><span data-stu-id="f4753-106">The network can have transient failures.</span></span> <span data-ttu-id="f4753-107">まれに、サービス全体またはリージョン全体で中断が発生する可能性がありますが、こうしたことについても計画しておく必要があります。</span><span class="sxs-lookup"><span data-stu-id="f4753-107">Rarely, an entire service or region may experience a disruption, but even those must be planned for.</span></span> 

<span data-ttu-id="f4753-108">クラウドで信頼性の高いアプリケーションの構築は、エンタープライズ設定で信頼性の高いアプリケーションの構築とは異なります。</span><span class="sxs-lookup"><span data-stu-id="f4753-108">Building a reliable application in the cloud is different than building a reliable application in an enterprise setting.</span></span> <span data-ttu-id="f4753-109">従来は、スケールアップのためにハイエンドなハードウェアを購入していましたが、クラウド環境では、スケールアップではなくスケールアウトする必要があります。</span><span class="sxs-lookup"><span data-stu-id="f4753-109">While historically you may have purchased higher-end hardware to scale up, in a cloud environment you must scale out instead of scaling up.</span></span> <span data-ttu-id="f4753-110">クラウド環境は、汎用的なハードウェアを使用することで低コストを維持できます。</span><span class="sxs-lookup"><span data-stu-id="f4753-110">Costs for cloud environments are kept low through the use of commodity hardware.</span></span> <span data-ttu-id="f4753-111">この新しい環境では、エラーを回避し、"平均故障間隔" を最適化することではなく、"復元までの平均時間" に集中できます。</span><span class="sxs-lookup"><span data-stu-id="f4753-111">Instead of focusing on preventing failures and optimizing "mean time between failures," in this new environment the focus shifts to "mean time to restore."</span></span> <span data-ttu-id="f4753-112">目標は、障害の影響を最小限に抑えることです。</span><span class="sxs-lookup"><span data-stu-id="f4753-112">The goal is to minimize the effect of a failure.</span></span>

<span data-ttu-id="f4753-113">この記事では、Microsoft Azure で回復性に優れたアプリケーションを構築する方法の概要について説明します。</span><span class="sxs-lookup"><span data-stu-id="f4753-113">This article provides an overview of how to build resilient applications in Microsoft Azure.</span></span> <span data-ttu-id="f4753-114">まず、*回復性*という用語の定義と関連する概念から説明します。</span><span class="sxs-lookup"><span data-stu-id="f4753-114">It starts with a definition of the term *resiliency* and related concepts.</span></span> <span data-ttu-id="f4753-115">次に、設計、実装からデプロイ、運用までというアプリケーションの有効期間全体に体系的な方法を使用することで、回復性を実現するプロセスについて説明します。</span><span class="sxs-lookup"><span data-stu-id="f4753-115">Then it describes a process for achieving resiliency, using a structured approach over the lifetime of an application, from design and implementation to deployment and operations.</span></span>

## <a name="what-is-resiliency"></a><span data-ttu-id="f4753-116">回復性とは</span><span class="sxs-lookup"><span data-stu-id="f4753-116">What is resiliency?</span></span>
<span data-ttu-id="f4753-117">**回復性**とは、障害から回復して動作を続行する、システムの能力です。</span><span class="sxs-lookup"><span data-stu-id="f4753-117">**Resiliency** is the ability of a system to recover from failures and continue to function.</span></span> <span data-ttu-id="f4753-118">障害を*回避*することではなく、ダウンタイムまたはデータの損失を回避するように障害に*対応*することです。</span><span class="sxs-lookup"><span data-stu-id="f4753-118">It's not about *avoiding* failures, but *responding* to failures in a way that avoids downtime or data loss.</span></span> <span data-ttu-id="f4753-119">回復性の目的は、障害後にアプリケーションを完全に機能している状態に戻すことです。</span><span class="sxs-lookup"><span data-stu-id="f4753-119">The goal of resiliency is to return the application to a fully functioning state following a failure.</span></span>

<span data-ttu-id="f4753-120">回復性には、高可用性とディザスター リカバリーという 2 つの重要な側面があります。</span><span class="sxs-lookup"><span data-stu-id="f4753-120">Two important aspects of resiliency are high availability and disaster recovery.</span></span>

* <span data-ttu-id="f4753-121">**高可用性** (HA) は、大幅なダウンタイムなしに、正常な状態で実行を継続するアプリケーションの能力です。</span><span class="sxs-lookup"><span data-stu-id="f4753-121">**High availability** (HA) is the ability of the application to continue running in a healthy state, without significant downtime.</span></span> <span data-ttu-id="f4753-122">"正常な状態" とは、アプリケーションが応答し、ユーザーがアプリケーションに接続して対話できるという意味です。</span><span class="sxs-lookup"><span data-stu-id="f4753-122">By "healthy state," we mean the application is responsive, and users can connect to the application and interact with it.</span></span>  
* <span data-ttu-id="f4753-123">**ディザスター リカバリー** (DR) は、まれに発生する大きなインシデント、すなわち地域全体に影響するサービス中断のように、一時的なものではない大規模な障害から回復する能力です。</span><span class="sxs-lookup"><span data-stu-id="f4753-123">**Disaster recovery** (DR) is the ability to recover from rare but major incidents: non-transient, wide-scale failures, such as service disruption that affects an entire region.</span></span> <span data-ttu-id="f4753-124">ディザスター リカバリーには、データ バックアップやアーカイブの他に、バックアップからのデータベースの復元などの手動操作も含まれる場合があります。</span><span class="sxs-lookup"><span data-stu-id="f4753-124">Disaster recovery includes data backup and archiving, and may include manual intervention, such as restoring a database from backup.</span></span>

<span data-ttu-id="f4753-125">HA と DR のとらえ方として、障害の影響が HA 設計で対応できる限度を超えたときに DR が始まると考えることができます。</span><span class="sxs-lookup"><span data-stu-id="f4753-125">One way to think about HA versus DR is that DR starts when the impact of a fault exceeds the ability of the HA design to handle it.</span></span>  

<span data-ttu-id="f4753-126">回復性を設計するときは、ご自分の可用性要件を理解する必要があります。</span><span class="sxs-lookup"><span data-stu-id="f4753-126">When you design resiliency, you must understand your availability requirements.</span></span> <span data-ttu-id="f4753-127">どの程度のダウンタイムを許容できるのでしょうか。</span><span class="sxs-lookup"><span data-stu-id="f4753-127">How much downtime is acceptable?</span></span> <span data-ttu-id="f4753-128">これは、ある程度はコストによって決まります。</span><span class="sxs-lookup"><span data-stu-id="f4753-128">This is partly a function of cost.</span></span> <span data-ttu-id="f4753-129">起こり得るダウンタイムによって貴社のビジネスが被るコストはいくらになるでしょうか。</span><span class="sxs-lookup"><span data-stu-id="f4753-129">How much will potential downtime cost your business?</span></span> <span data-ttu-id="f4753-130">アプリケーションの可用性を高めることにいくら投資したいですか。</span><span class="sxs-lookup"><span data-stu-id="f4753-130">How much should you invest in making the application highly available?</span></span> <span data-ttu-id="f4753-131">また、何をもってアプリケーションが使用可能であるとするかについても定義する必要があります。</span><span class="sxs-lookup"><span data-stu-id="f4753-131">You also have to define what it means for the application to be available.</span></span> <span data-ttu-id="f4753-132">たとえば、ユーザーが注文を送信しても、通常の時間枠内にシステムで処理できない場合、アプリケーションは "停止" 状態でしょうか。</span><span class="sxs-lookup"><span data-stu-id="f4753-132">For example, is the application "down" if a customer can submit an order but the system cannot process it within the normal timeframe?</span></span> <span data-ttu-id="f4753-133">また、特定の種類の障害が発生する可能性と、リスク軽減戦略のコスト効果が高いかどうかについても考慮します。</span><span class="sxs-lookup"><span data-stu-id="f4753-133">Also consider the probability of a particular type of outage occurring, and whether a mitigation strategy is cost-effective.</span></span>

<span data-ttu-id="f4753-134">もう 1 つの一般的な用語に**ビジネス継続性** (BC) があります。BC とは、自然災害やサービスの停止などの悪条件の発生時と発生後に、重要なビジネス機能を実行できることです。</span><span class="sxs-lookup"><span data-stu-id="f4753-134">Another common term is **business continuity** (BC), which is the ability to perform essential business functions during and after adverse conditions, such as a natural disaster or a downed service.</span></span> <span data-ttu-id="f4753-135">BC は、物理的な設備、人、コミュニティ、運輸、IT を含め、業務全体が対象です。</span><span class="sxs-lookup"><span data-stu-id="f4753-135">BC covers the entire operation of the business, including physical facilities, people, communications, transportation, and IT.</span></span> <span data-ttu-id="f4753-136">この記事ではクラウド アプリケーションを中心に扱いますが、回復性の計画は BC 要件全体のコンテキストで行う必要があります。</span><span class="sxs-lookup"><span data-stu-id="f4753-136">This article focuses on cloud applications, but resilience planning must be done in the context of overall BC requirements.</span></span> 

<span data-ttu-id="f4753-137">**データ バックアップ**は、DR の重要な部分です。</span><span class="sxs-lookup"><span data-stu-id="f4753-137">**Data backup** is a critical part of DR.</span></span> <span data-ttu-id="f4753-138">アプリケーションのステートレスなコンポーネントが失敗した場合、そのコンポーネントはいつでも再展開できます。</span><span class="sxs-lookup"><span data-stu-id="f4753-138">If the stateless components of an application fail, you can always redeploy them.</span></span> <span data-ttu-id="f4753-139">ただし、データが失われると、システムは安定した状態に戻ることはできません。</span><span class="sxs-lookup"><span data-stu-id="f4753-139">But if data is lost, the system can't return to a stable state.</span></span> <span data-ttu-id="f4753-140">リージョン全体の障害に備えて、理想的には異なるリージョンにデータをバックアップする必要があります。</span><span class="sxs-lookup"><span data-stu-id="f4753-140">Data must be backed up, ideally in a different region in case of a region-wide disaster.</span></span> 

<span data-ttu-id="f4753-141">バックアップは、**データ レプリケーション**とは異なります。</span><span class="sxs-lookup"><span data-stu-id="f4753-141">Backup is distinct from **data replication**.</span></span> <span data-ttu-id="f4753-142">データ レプリケーションでは、システムが迅速にレプリカにフェールオーバーできるように、ほぼリアルタイムでデータがコピーされます。</span><span class="sxs-lookup"><span data-stu-id="f4753-142">Data replication involves copying data in near-real-time, so that the system can fail over quickly to a replica.</span></span> <span data-ttu-id="f4753-143">多くのデータベース システムがレプリケーションをサポートしています。たとえば、SQL Server では、SQL Server Always On 可用性グループがサポートされます。</span><span class="sxs-lookup"><span data-stu-id="f4753-143">Many databases systems support replication; for example, SQL Server supports SQL Server Always On Availability Groups.</span></span> <span data-ttu-id="f4753-144">データ レプリケーションでは、データのレプリカを確実かつ常に待機させることで、障害からの復旧時間を短縮できます。</span><span class="sxs-lookup"><span data-stu-id="f4753-144">Data replication can reduce how long it takes to recover from an outage, by ensuring that a replica of the data is always standing by.</span></span> <span data-ttu-id="f4753-145">しかし、データ レプリケーションで人的ミスを防ぐことはできません。</span><span class="sxs-lookup"><span data-stu-id="f4753-145">However, data replication won't protect against human error.</span></span> <span data-ttu-id="f4753-146">人的ミスによりデータが破損すると、その破損したデータはレプリカにコピーされます。</span><span class="sxs-lookup"><span data-stu-id="f4753-146">If data gets corrupted because of human error, the corrupted data just gets copied to the replicas.</span></span> <span data-ttu-id="f4753-147">このため、DR 戦略には引き続き長期的なバックアップを含める必要があります。</span><span class="sxs-lookup"><span data-stu-id="f4753-147">Therefore, you still need to include long-term backup in your DR strategy.</span></span> 

## <a name="process-to-achieve-resiliency"></a><span data-ttu-id="f4753-148">回復性を実現するプロセス</span><span class="sxs-lookup"><span data-stu-id="f4753-148">Process to achieve resiliency</span></span>
<span data-ttu-id="f4753-149">回復性はアドオンではありません。</span><span class="sxs-lookup"><span data-stu-id="f4753-149">Resiliency is not an add-on.</span></span> <span data-ttu-id="f4753-150">システムの設計に追加し、運用方法に組み込む必要があります。</span><span class="sxs-lookup"><span data-stu-id="f4753-150">It must be designed into the system and put into operational practice.</span></span> <span data-ttu-id="f4753-151">一般的なモデルは次のとおりです。</span><span class="sxs-lookup"><span data-stu-id="f4753-151">Here is a general model to follow:</span></span>

1. <span data-ttu-id="f4753-152">**定義**: ビジネスのニーズに基づいて可用性の要件を定義します。</span><span class="sxs-lookup"><span data-stu-id="f4753-152">**Define** your availability requirements, based on business needs.</span></span>
2. <span data-ttu-id="f4753-153">**設計**: 回復性を考慮してアプリケーションを設計します。</span><span class="sxs-lookup"><span data-stu-id="f4753-153">**Design** the application for resiliency.</span></span> <span data-ttu-id="f4753-154">実証済みの手法に従ったアーキテクチャから始めて、そのアーキテクチャで考えられる障害点を特定します。</span><span class="sxs-lookup"><span data-stu-id="f4753-154">Start with an architecture that follows proven practices, and then identify the possible failure points in that architecture.</span></span>
3. <span data-ttu-id="f4753-155">**実装**: 障害を検出し、回復する戦略を実装します。</span><span class="sxs-lookup"><span data-stu-id="f4753-155">**Implement** strategies to detect and recover from failures.</span></span> 
4. <span data-ttu-id="f4753-156">**テスト**: 障害をシミュレートし、強制的なフェールオーバーをトリガーして実装をテストします。</span><span class="sxs-lookup"><span data-stu-id="f4753-156">**Test** the implementation by simulating faults and triggering forced failovers.</span></span> 
5. <span data-ttu-id="f4753-157">**デプロイ**: 信頼性が高い反復可能なプロセスを使用して、アプリケーションを運用環境にデプロイします。</span><span class="sxs-lookup"><span data-stu-id="f4753-157">**Deploy** the application into production using a reliable, repeatable process.</span></span> 
6. <span data-ttu-id="f4753-158">**監視**: アプリケーションを監視して障害を検出します。</span><span class="sxs-lookup"><span data-stu-id="f4753-158">**Monitor** the application to detect failures.</span></span> <span data-ttu-id="f4753-159">システムを監視することで、アプリケーションの正常性を評価し、必要に応じてインシデントに対応できます。</span><span class="sxs-lookup"><span data-stu-id="f4753-159">By monitoring the system, you can gauge the health of the application and respond to incidents if necessary.</span></span> 
7. <span data-ttu-id="f4753-160">**対応**: 手動の介入が必要な障害が発生した場合に対応します。</span><span class="sxs-lookup"><span data-stu-id="f4753-160">**Respond** if there are failure that require manual interventions.</span></span>

<span data-ttu-id="f4753-161">以降、これらの各手順について詳しく説明します。</span><span class="sxs-lookup"><span data-stu-id="f4753-161">In the remainder of this article, we discuss each of these steps in more detail.</span></span>

## <a name="define-your-availability-requirements"></a><span data-ttu-id="f4753-162">可用性の要件を定義する</span><span class="sxs-lookup"><span data-stu-id="f4753-162">Define your availability requirements</span></span>
<span data-ttu-id="f4753-163">回復性の計画は、ビジネス要件から始まります。</span><span class="sxs-lookup"><span data-stu-id="f4753-163">Resiliency planning starts with business requirements.</span></span> <span data-ttu-id="f4753-164">ビジネス要件という点で回復性について考える場合の方法をいくつか挙げます。</span><span class="sxs-lookup"><span data-stu-id="f4753-164">Here are some approaches for thinking about resiliency in those terms.</span></span>

### <a name="decompose-by-workload"></a><span data-ttu-id="f4753-165">ワークロードごとに分解する</span><span class="sxs-lookup"><span data-stu-id="f4753-165">Decompose by workload</span></span>
<span data-ttu-id="f4753-166">多くのクラウド ソリューションは、複数のアプリケーション ワークロードで構成されます。</span><span class="sxs-lookup"><span data-stu-id="f4753-166">Many cloud solutions consist of multiple application workloads.</span></span> <span data-ttu-id="f4753-167">このコンテキストで "ワークロード" という用語は、ビジネス ロジックとデータ ストレージ要件の点で、他のタスクとは論理的に区別できる個別の機能またはコンピューティング タスクを意味します。</span><span class="sxs-lookup"><span data-stu-id="f4753-167">The term "workload" in this context means a discrete capability or computing task, which can be logically separated from other tasks, in terms of business logic and data storage requirements.</span></span> <span data-ttu-id="f4753-168">たとえば、eコマース アプリには次のようなワークロードがあります。</span><span class="sxs-lookup"><span data-stu-id="f4753-168">For example, an e-commerce app might include the following workloads:</span></span>

* <span data-ttu-id="f4753-169">製品カタログの閲覧と検索。</span><span class="sxs-lookup"><span data-stu-id="f4753-169">Browse and search a product catalog.</span></span>
* <span data-ttu-id="f4753-170">注文の作成と追跡。</span><span class="sxs-lookup"><span data-stu-id="f4753-170">Create and track orders.</span></span>
* <span data-ttu-id="f4753-171">推奨事項の表示。</span><span class="sxs-lookup"><span data-stu-id="f4753-171">View recommendations.</span></span>

<span data-ttu-id="f4753-172">これらのワークロードは、可用性、スケーラビリティ、データの一貫性、ディザスター リカバリーなどの要件が異なる可能性があります。</span><span class="sxs-lookup"><span data-stu-id="f4753-172">These workloads might have different requirements for availability, scalability, data consistency, disaster recovery, and so forth.</span></span> <span data-ttu-id="f4753-173">これらもビジネス上の決定事項です。</span><span class="sxs-lookup"><span data-stu-id="f4753-173">Again, these are business decisions.</span></span>

<span data-ttu-id="f4753-174">また、使用パターンについても考慮します。</span><span class="sxs-lookup"><span data-stu-id="f4753-174">Also consider usage patterns.</span></span> <span data-ttu-id="f4753-175">システムが使用可能である必要がある特定の重要な期間はありますか。</span><span class="sxs-lookup"><span data-stu-id="f4753-175">Are there certain critical periods when the system must be available?</span></span> <span data-ttu-id="f4753-176">たとえば、税金申告書サービスが申告期限の直前に停止してはならない、大規模なスポーツ イベント中にビデオ ストリーミング サービスは稼働している必要がある、などです。</span><span class="sxs-lookup"><span data-stu-id="f4753-176">For example, a tax-filing service can't go down right before the filing deadline, a video streaming service must stay up during a big sports event, and so on.</span></span> <span data-ttu-id="f4753-177">重要な期間中は、複数のリージョンにまたがる冗長的なデプロイにして、1 つのリージョンで障害が発生してもアプリケーションがフェールオーバーできるようにすることができます。</span><span class="sxs-lookup"><span data-stu-id="f4753-177">During the critical periods, you might have redundant deployments across several regions, so the application could fail over if one region failed.</span></span> <span data-ttu-id="f4753-178">ただし、複数リージョンのデプロイはコストが高くなるため、重要な期間以外は、1 つのリージョンでアプリケーションを実行することができます。</span><span class="sxs-lookup"><span data-stu-id="f4753-178">However, a multi-region deployment is more expensive, so during less critical times, you might run the application in a single region.</span></span>

### <a name="rto-and-rpo"></a><span data-ttu-id="f4753-179">RTO と RPO</span><span class="sxs-lookup"><span data-stu-id="f4753-179">RTO and RPO</span></span>
<span data-ttu-id="f4753-180">考慮すべき 2 つの重要なメトリックとして、目標復旧時間と回復ポイントの目標があります。</span><span class="sxs-lookup"><span data-stu-id="f4753-180">Two important metrics to consider are the recovery time objective and recovery point objective.</span></span>

* <span data-ttu-id="f4753-181">**目標復旧時間** (RTO) は、インシデントが発生した後に、アプリケーションに許容する使用不能状態の最大時間です。</span><span class="sxs-lookup"><span data-stu-id="f4753-181">**Recovery time objective** (RTO) is the maximum acceptable time that an application can be unavailable after an incident.</span></span> <span data-ttu-id="f4753-182">RTO が 90 分の場合、災害発生から 90 分以内にアプリケーションを実行状態に復元できる必要があります。</span><span class="sxs-lookup"><span data-stu-id="f4753-182">If your RTO is 90 minutes, you must be able to restore the application to a running state within 90 minutes from the start of a disaster.</span></span> <span data-ttu-id="f4753-183">RTO を非常に低い値にする場合、リージョン全体の停止から保護するために、スタンバイ状態で継続的に動作する第 2 のデプロイを維持する必要があります。</span><span class="sxs-lookup"><span data-stu-id="f4753-183">If you have a very low RTO, you might keep a second deployment continually running on standby, to protect against a regional outage.</span></span>

* <span data-ttu-id="f4753-184">**回復ポイントの目標** (RPO) は、災害発生時に許容できるデータ損失の最大期間です。</span><span class="sxs-lookup"><span data-stu-id="f4753-184">**Recovery point objective** (RPO) is the maximum duration of data loss that is acceptable during a disaster.</span></span> <span data-ttu-id="f4753-185">たとえば、単一のデータベースにデータを格納し、他のデータベースへのレプリケーションなしで、毎時のバックアップを実行する場合、最大 1 時間のデータを失う可能性があります。</span><span class="sxs-lookup"><span data-stu-id="f4753-185">For example, if you store data in a single database, with no replication to other databases, and perform hourly backups, you could lose up to an hour of data.</span></span> 

<span data-ttu-id="f4753-186">RTO と RPO はビジネス要件です。</span><span class="sxs-lookup"><span data-stu-id="f4753-186">RTO and RPO are business requirements.</span></span> <span data-ttu-id="f4753-187">リスク評価の実施は、アプリケーションの RTO と RPO の定義に役立ちます。</span><span class="sxs-lookup"><span data-stu-id="f4753-187">Conducting a risk assessment can help you define the application's RTO and RPO.</span></span> <span data-ttu-id="f4753-188">もう 1 つの一般的なメトリックは、**平均復旧時間** (MTTR) です。MTTR は、障害発生後にアプリケーションの復元にかかる平均時間です。</span><span class="sxs-lookup"><span data-stu-id="f4753-188">Another common metric is **mean time to recover** (MTTR), which is the average time that it takes to restore the application after a failure.</span></span> <span data-ttu-id="f4753-189">MTTR は、システムに関する経験的事実です。</span><span class="sxs-lookup"><span data-stu-id="f4753-189">MTTR is an empirical fact about a system.</span></span> <span data-ttu-id="f4753-190">MTTR が RTO を超えると、システム障害の結果、定義されている RTO 以内にシステムを復元できなくなるため、許容できないビジネスの中断が発生します。</span><span class="sxs-lookup"><span data-stu-id="f4753-190">If MTTR exceeds the RTO, then a failure in the system will cause an unacceptable business disruption, because it won't be possible to restore the system within the defined RTO.</span></span> 

### <a name="slas"></a><span data-ttu-id="f4753-191">SLA</span><span class="sxs-lookup"><span data-stu-id="f4753-191">SLAs</span></span>
<span data-ttu-id="f4753-192">Azure の[サービス レベル アグリーメント][sla] (SLA) では、稼働時間と接続性に関する Microsoft のコミットメントが示されています。</span><span class="sxs-lookup"><span data-stu-id="f4753-192">In Azure, the [Service Level Agreement][sla] (SLA) describes Microsoft’s commitments for uptime and connectivity.</span></span> <span data-ttu-id="f4753-193">特定のサービスの SLA が 99.9% の場合は、そのサービスを 99.9% の確率で使用可能だと予想できることを意味します。</span><span class="sxs-lookup"><span data-stu-id="f4753-193">If the SLA for a particular service is 99.9%, it means you should expect the service to be available 99.9% of the time.</span></span>

> [!NOTE]
> <span data-ttu-id="f4753-194">また、Azure SLA には、SLA が満たされない場合にサービス クレジットを取得するための規定と、各サービスの "可用性" の詳細な定義も含まれています。</span><span class="sxs-lookup"><span data-stu-id="f4753-194">The Azure SLA also includes provisions for obtaining a service credit if the SLA is not met, along with specific definitions of "availability" for each service.</span></span> <span data-ttu-id="f4753-195">SLA のこの側面は、強制ポリシーとして機能します。</span><span class="sxs-lookup"><span data-stu-id="f4753-195">That aspect of the SLA acts as an enforcement policy.</span></span> 
> 
> 

<span data-ttu-id="f4753-196">お客様のソリューションの各ワークロードには、独自の目標 SLA を定義することをお勧めします。</span><span class="sxs-lookup"><span data-stu-id="f4753-196">You should define your own target SLAs for each workload in your solution.</span></span> <span data-ttu-id="f4753-197">SLA があると、アーキテクチャがビジネス要件を満たしているかどうかを評価できるようになります。</span><span class="sxs-lookup"><span data-stu-id="f4753-197">An SLA makes it possible to evaluate whether the architecture meets the business requirements.</span></span> <span data-ttu-id="f4753-198">たとえば、ワークロードのアップタイム要件が 99.99% で、SLA が 99.9% のサービスに依存している場合、そのサービスをシステムの単一障害点にしてはなりません。</span><span class="sxs-lookup"><span data-stu-id="f4753-198">For example, if a workload requires 99.99% uptime, but depends on a service with a 99.9% SLA, that service cannot be a single-point of failure in the system.</span></span> <span data-ttu-id="f4753-199">救済策として、サービスで障害が発生した場合に備えてフォールバック パスを用意するか、そのサービスの障害から復旧する他の措置を実行する方法があります。</span><span class="sxs-lookup"><span data-stu-id="f4753-199">One remedy is to have a fallback path in case the service fails, or take other measures to recover from a failure in that service.</span></span> 

<span data-ttu-id="f4753-200">次の表は、さまざまな SLA レベルで考えられる累積的なダウンタイムの一覧です。</span><span class="sxs-lookup"><span data-stu-id="f4753-200">The following table shows the potential cumulative downtime for various SLA levels.</span></span> 

| <span data-ttu-id="f4753-201">SLA</span><span class="sxs-lookup"><span data-stu-id="f4753-201">SLA</span></span> | <span data-ttu-id="f4753-202">週あたりのダウンタイム</span><span class="sxs-lookup"><span data-stu-id="f4753-202">Downtime per week</span></span> | <span data-ttu-id="f4753-203">月あたりのダウンタイム</span><span class="sxs-lookup"><span data-stu-id="f4753-203">Downtime per month</span></span> | <span data-ttu-id="f4753-204">年あたりのダウンタイム</span><span class="sxs-lookup"><span data-stu-id="f4753-204">Downtime per year</span></span> |
| --- | --- | --- | --- |
| <span data-ttu-id="f4753-205">99%</span><span class="sxs-lookup"><span data-stu-id="f4753-205">99%</span></span> |<span data-ttu-id="f4753-206">1.68 時間</span><span class="sxs-lookup"><span data-stu-id="f4753-206">1.68 hours</span></span> |<span data-ttu-id="f4753-207">7.2 時間</span><span class="sxs-lookup"><span data-stu-id="f4753-207">7.2 hours</span></span> |<span data-ttu-id="f4753-208">3.65 日</span><span class="sxs-lookup"><span data-stu-id="f4753-208">3.65 days</span></span> |
| <span data-ttu-id="f4753-209">99.9%</span><span class="sxs-lookup"><span data-stu-id="f4753-209">99.9%</span></span> |<span data-ttu-id="f4753-210">10.1 分</span><span class="sxs-lookup"><span data-stu-id="f4753-210">10.1 minutes</span></span> |<span data-ttu-id="f4753-211">43.2 分</span><span class="sxs-lookup"><span data-stu-id="f4753-211">43.2 minutes</span></span> |<span data-ttu-id="f4753-212">8.76 時間</span><span class="sxs-lookup"><span data-stu-id="f4753-212">8.76 hours</span></span> |
| <span data-ttu-id="f4753-213">99.95%</span><span class="sxs-lookup"><span data-stu-id="f4753-213">99.95%</span></span> |<span data-ttu-id="f4753-214">5 分</span><span class="sxs-lookup"><span data-stu-id="f4753-214">5 minutes</span></span> |<span data-ttu-id="f4753-215">21.6 分</span><span class="sxs-lookup"><span data-stu-id="f4753-215">21.6 minutes</span></span> |<span data-ttu-id="f4753-216">4.38 時間</span><span class="sxs-lookup"><span data-stu-id="f4753-216">4.38 hours</span></span> |
| <span data-ttu-id="f4753-217">99.99%</span><span class="sxs-lookup"><span data-stu-id="f4753-217">99.99%</span></span> |<span data-ttu-id="f4753-218">1.01 分</span><span class="sxs-lookup"><span data-stu-id="f4753-218">1.01 minutes</span></span> |<span data-ttu-id="f4753-219">4.32 分</span><span class="sxs-lookup"><span data-stu-id="f4753-219">4.32 minutes</span></span> |<span data-ttu-id="f4753-220">52.56 分</span><span class="sxs-lookup"><span data-stu-id="f4753-220">52.56 minutes</span></span> |
| <span data-ttu-id="f4753-221">99.999%</span><span class="sxs-lookup"><span data-stu-id="f4753-221">99.999%</span></span> |<span data-ttu-id="f4753-222">6 秒</span><span class="sxs-lookup"><span data-stu-id="f4753-222">6 seconds</span></span> |<span data-ttu-id="f4753-223">25.9 秒</span><span class="sxs-lookup"><span data-stu-id="f4753-223">25.9 seconds</span></span> |<span data-ttu-id="f4753-224">5.26 分</span><span class="sxs-lookup"><span data-stu-id="f4753-224">5.26 minutes</span></span> |

<span data-ttu-id="f4753-225">当然ながら高可用性が望ましく、他の項目は同じくらいです。</span><span class="sxs-lookup"><span data-stu-id="f4753-225">Of course, higher availability is better, everything else being equal.</span></span> <span data-ttu-id="f4753-226">ただし、99.99...% の 9 の桁数を増やすにつれて、そのレベルの可用性を実現するためのコストと複雑さは増大します。</span><span class="sxs-lookup"><span data-stu-id="f4753-226">But as you strive for more 9s, the cost and complexity to achieve that level of availability grows.</span></span> <span data-ttu-id="f4753-227">99.99% のアップタイムは、月あたりの合計ダウンタイムの約 5 分に換算されます。</span><span class="sxs-lookup"><span data-stu-id="f4753-227">An uptime of 99.99% translates to about 5 minutes of total downtime per month.</span></span> <span data-ttu-id="f4753-228">5 つの 9 (99.999%) を実現するために、複雑さとコストが増大する価値はありますか。</span><span class="sxs-lookup"><span data-stu-id="f4753-228">Is it worth the additional complexity and cost to reach five 9s?</span></span> <span data-ttu-id="f4753-229">その答えはビジネス要件によって変わります。</span><span class="sxs-lookup"><span data-stu-id="f4753-229">The answer depends on the business requirements.</span></span> 

<span data-ttu-id="f4753-230">SLA を定義する場合の他の考慮事項を次に示します。</span><span class="sxs-lookup"><span data-stu-id="f4753-230">Here are some other considerations when defining an SLA:</span></span>

* <span data-ttu-id="f4753-231">4 つの 9 (99.99%) を実現するには、手動操作による障害からの復旧には依存できません。</span><span class="sxs-lookup"><span data-stu-id="f4753-231">To achieve four 9's (99.99%), you probably can't rely on manual intervention to recover from failures.</span></span> <span data-ttu-id="f4753-232">アプリケーションには自己診断機能と自己復旧機能が必要です。</span><span class="sxs-lookup"><span data-stu-id="f4753-232">The application must be self-diagnosing and self-healing.</span></span> 
* <span data-ttu-id="f4753-233">4 つの 9 を超えると、SLA を満たすことができるほど迅速に障害を検出することは困難です。</span><span class="sxs-lookup"><span data-stu-id="f4753-233">Beyond four 9's, it is challenging to detect outages quickly enough to meet the SLA.</span></span>
* <span data-ttu-id="f4753-234">SLA を測定する時間枠について考慮します。</span><span class="sxs-lookup"><span data-stu-id="f4753-234">Think about the time window that your SLA is measured against.</span></span> <span data-ttu-id="f4753-235">この時間枠を短くするほど、許容度は厳格になります。</span><span class="sxs-lookup"><span data-stu-id="f4753-235">The smaller the window, the tighter the tolerances.</span></span> <span data-ttu-id="f4753-236">時間単位または日単位のアップタイムという観点で SLA を定義することはおそらく意味がありません。</span><span class="sxs-lookup"><span data-stu-id="f4753-236">It probably doesn't make sense to define your SLA in terms of hourly or daily uptime.</span></span> 

### <a name="composite-slas"></a><span data-ttu-id="f4753-237">複合 SLA</span><span class="sxs-lookup"><span data-stu-id="f4753-237">Composite SLAs</span></span>
<span data-ttu-id="f4753-238">Azure SQL Database に書き込む App Service Web アプリについて検討します。</span><span class="sxs-lookup"><span data-stu-id="f4753-238">Consider an App Service web app that writes to Azure SQL Database.</span></span> <span data-ttu-id="f4753-239">この記事の執筆時点で、このような Azure サービスには次の SLA があります。</span><span class="sxs-lookup"><span data-stu-id="f4753-239">At the time of this writing, these Azure services have the following SLAs:</span></span>

* <span data-ttu-id="f4753-240">App Service Web Apps = 99.95%</span><span class="sxs-lookup"><span data-stu-id="f4753-240">App Service Web Apps = 99.95%</span></span>
* <span data-ttu-id="f4753-241">SQL Database = 99.99%</span><span class="sxs-lookup"><span data-stu-id="f4753-241">SQL Database = 99.99%</span></span>

![複合 SLA](./images/sla1.png)

<span data-ttu-id="f4753-243">このアプリケーションで予想される最大ダウンタイムはどのくらいですか。</span><span class="sxs-lookup"><span data-stu-id="f4753-243">What is the maximum downtime you would expect for this application?</span></span> <span data-ttu-id="f4753-244">いずれかのサービスで障害が発生すると、アプリケーション全体で障害が発生します。</span><span class="sxs-lookup"><span data-stu-id="f4753-244">If either service fails, the whole application fails.</span></span> <span data-ttu-id="f4753-245">一般的に、各サービスで障害が発生する可能性は独立しているため、このアプリケーションの複合 SLA は 99.95% &times; 99.99% = 99.94% です。</span><span class="sxs-lookup"><span data-stu-id="f4753-245">In general, the probability of each service failing is independent, so the composite SLA for this application is 99.95% &times; 99.99% = 99.94%.</span></span> <span data-ttu-id="f4753-246">これは個々の SLA よりも低い値です。複数のサービスに依存するアプリケーションは潜在的な障害点が多くなるため、これは驚くことではありません。</span><span class="sxs-lookup"><span data-stu-id="f4753-246">That's lower than the individual SLAs, which isn't surprising, because an application that relies on multiple services has more potential failure points.</span></span> 

<span data-ttu-id="f4753-247">一方、複合 SLA を改善するには、独立したフォールバック パスを作成する方法があります。</span><span class="sxs-lookup"><span data-stu-id="f4753-247">On the other hand, you can improve the composite SLA by creating independent fallback paths.</span></span> <span data-ttu-id="f4753-248">たとえば、SQL Database が使用できない場合は、後で処理できるようにトランザクションをキューに格納します。</span><span class="sxs-lookup"><span data-stu-id="f4753-248">For example, if SQL Database is unavailable, put transactions into a queue, to be processed later.</span></span>

![複合 SLA](./images/sla2.png)

<span data-ttu-id="f4753-250">この設計の場合、データベースに接続できない場合でも、アプリケーションは使用可能な状態です。</span><span class="sxs-lookup"><span data-stu-id="f4753-250">With this design, the application is still available even if it can't connect to the database.</span></span> <span data-ttu-id="f4753-251">ただし、データベースとキューの両方で同時に障害が発生すると、アプリケーションは使用できなくなります。</span><span class="sxs-lookup"><span data-stu-id="f4753-251">However, it fails if the database and the queue both fail at the same time.</span></span> <span data-ttu-id="f4753-252">同時に障害が発生する時間の予測される割合は 0.0001 &times; 0.001 なので、この組み合わせのパスに関する複合 SLA は次のとおりです。</span><span class="sxs-lookup"><span data-stu-id="f4753-252">The expected percentage of time for a simultaneous failure is 0.0001 &times; 0.001, so the composite SLA for this combined path is:</span></span>  

* <span data-ttu-id="f4753-253">データベース OR キュー = 1.0 &minus; (0.0001 &times; 0.001) = 99.99999%</span><span class="sxs-lookup"><span data-stu-id="f4753-253">Database OR queue = 1.0 &minus; (0.0001 &times; 0.001) = 99.99999%</span></span>

<span data-ttu-id="f4753-254">合計複合 SLA は次のとおりです。</span><span class="sxs-lookup"><span data-stu-id="f4753-254">The total composite SLA is:</span></span>

* <span data-ttu-id="f4753-255">Web アプリ AND (データベース OR キュー) = 99.95% &times; 99.99999% = 99.95% 以下</span><span class="sxs-lookup"><span data-stu-id="f4753-255">Web app AND (database OR queue) = 99.95% &times; 99.99999% = ~99.95%</span></span>

<span data-ttu-id="f4753-256">ただし、この方法にはトレードオフがあります。</span><span class="sxs-lookup"><span data-stu-id="f4753-256">But there are tradeoffs to this approach.</span></span> <span data-ttu-id="f4753-257">アプリケーション ロジックは複雑になり、キューのコストがかかり、データの一貫性に関する問題も考慮が必要になる可能性があります。</span><span class="sxs-lookup"><span data-stu-id="f4753-257">The application logic is more complex, you are paying for the queue, and there may be data consistency issues to consider.</span></span>

<span data-ttu-id="f4753-258">**複数リージョン デプロイの SLA**。</span><span class="sxs-lookup"><span data-stu-id="f4753-258">**SLA for multi-region deployments**.</span></span> <span data-ttu-id="f4753-259">もう 1 つの HA 手法は、アプリケーションを複数のリージョンにデプロイし、1 つのリージョンのアプリケーションで障害が発生した場合にフェールオーバーするように Azure Traffic Manager を使用する方法です。</span><span class="sxs-lookup"><span data-stu-id="f4753-259">Another HA technique is to deploy the application in more than one region, and use Azure Traffic Manager to fail over if the application fails in one region.</span></span> <span data-ttu-id="f4753-260">2 リージョンのデプロイの場合、複合 SLA は次のように計算されます。</span><span class="sxs-lookup"><span data-stu-id="f4753-260">For a two-region deployment, the composite SLA is calculated as follows.</span></span> 

<span data-ttu-id="f4753-261">*N* は、1 つのリージョンにアプリケーションをデプロイした場合の複合 SLA であるとします。</span><span class="sxs-lookup"><span data-stu-id="f4753-261">Let *N* be the composite SLA for the application deployed in one region.</span></span> <span data-ttu-id="f4753-262">同時に両方のリージョンのアプリケーションで障害が発生する可能性は (1 &minus; N) &times; (1 &minus; N) と予測されます。</span><span class="sxs-lookup"><span data-stu-id="f4753-262">The expected chance that the application will fail in both regions at the same time is (1 &minus; N) &times; (1 &minus; N).</span></span> <span data-ttu-id="f4753-263">そのため、次のようになります。</span><span class="sxs-lookup"><span data-stu-id="f4753-263">Therefore,</span></span>

* <span data-ttu-id="f4753-264">両リージョンの複合 SLA = 1 &minus; (1 &minus; N)(1 &minus; N) = N + (1 &minus; N)N</span><span class="sxs-lookup"><span data-stu-id="f4753-264">Combined SLA for both regions = 1 &minus; (1 &minus; N)(1 &minus; N) = N + (1 &minus; N)N</span></span>

<span data-ttu-id="f4753-265">最後に、[Traffic Manager の SLA][tm-sla] を考慮する必要があります。</span><span class="sxs-lookup"><span data-stu-id="f4753-265">Finally, you must factor in the [SLA for Traffic Manager][tm-sla].</span></span> <span data-ttu-id="f4753-266">この記事の執筆時点で Traffic Manager の SLA は 99.99% です。</span><span class="sxs-lookup"><span data-stu-id="f4753-266">At the time of this writing, the SLA for Traffic Manager SLA is 99.99%.</span></span>

* <span data-ttu-id="f4753-267">複合 SLA = 99.99% &times; (両リージョンの複合 SLA)</span><span class="sxs-lookup"><span data-stu-id="f4753-267">Composite SLA = 99.99% &times; (combined SLA for both regions)</span></span>

<span data-ttu-id="f4753-268">また、フェールオーバーは瞬時に完了しないので、フェールオーバー時にはある程度のダウンタイムが発生する可能性があります。</span><span class="sxs-lookup"><span data-stu-id="f4753-268">Also, failing over is not instantaneous and can result in some downtime during a failover.</span></span> <span data-ttu-id="f4753-269">[Traffic Manager エンドポイントの監視とフェールオーバー][tm-failover]に関するページを参照してください。</span><span class="sxs-lookup"><span data-stu-id="f4753-269">See [Traffic Manager endpoint monitoring and failover][tm-failover].</span></span>

<span data-ttu-id="f4753-270">計算された SLA 値は便利なベースラインですが、可用性のすべてを把握できる訳ではありません。</span><span class="sxs-lookup"><span data-stu-id="f4753-270">The calculated SLA number is a useful baseline, but it doesn't tell the whole story about availability.</span></span> <span data-ttu-id="f4753-271">重要ではないパスで障害が発生した場合、アプリケーションの機能を適切に低下できることがよくあります。</span><span class="sxs-lookup"><span data-stu-id="f4753-271">Often, an application can degrade gracefully when a non-critical path fails.</span></span> <span data-ttu-id="f4753-272">書籍のカタログを表示するアプリケーションを例に説明します。</span><span class="sxs-lookup"><span data-stu-id="f4753-272">Consider an application that shows a catalog of books.</span></span> <span data-ttu-id="f4753-273">そのアプリケーションが表紙のサムネイル画像を取得できない場合は、プレース ホルダー イメージを表示することができます。</span><span class="sxs-lookup"><span data-stu-id="f4753-273">If the application can't retrieve the thumbnail image for the cover, it might show a placeholder image.</span></span> <span data-ttu-id="f4753-274">この場合、画像を取得できないと、アプリケーションの稼働時間は減りませんが、ユーザー エクスペリエンスには影響が出ます。</span><span class="sxs-lookup"><span data-stu-id="f4753-274">In that case, failing to get the image does not reduce the application's uptime, although it affects the user experience.</span></span>  

## <a name="design-for-resiliency"></a><span data-ttu-id="f4753-275">回復性の設計</span><span class="sxs-lookup"><span data-stu-id="f4753-275">Design for resiliency</span></span>

<span data-ttu-id="f4753-276">設計フェーズで、障害モードの分析 (FMA) を実行することをお勧めします。</span><span class="sxs-lookup"><span data-stu-id="f4753-276">During the design phase, you should perform a failure mode analysis (FMA).</span></span> <span data-ttu-id="f4753-277">FMA の目標は、潜在的な障害点を特定し、アプリケーションがその障害に対して対応する方法を定義することです。</span><span class="sxs-lookup"><span data-stu-id="f4753-277">The goal of an FMA is to identify possible points of failure, and define how the application will respond to those failures.</span></span>

* <span data-ttu-id="f4753-278">アプリケーションはこのような障害をどのように検出するでしょうか。</span><span class="sxs-lookup"><span data-stu-id="f4753-278">How will the application detect this type of failure?</span></span>
* <span data-ttu-id="f4753-279">アプリケーションはこのような障害にどのように対応するでしょうか。</span><span class="sxs-lookup"><span data-stu-id="f4753-279">How will the application respond to this type of failure?</span></span>
* <span data-ttu-id="f4753-280">このような障害のログ記録と監視はどのように行うでしょうか。</span><span class="sxs-lookup"><span data-stu-id="f4753-280">How will you log and monitor this type of failure?</span></span> 

<span data-ttu-id="f4753-281">FMA プロセスの詳細と、Azure 固有の推奨事項については、[Azure の回復性ガイダンスの障害モードの分析][fma]に関するページを参照してください。</span><span class="sxs-lookup"><span data-stu-id="f4753-281">For more information about the FMA process, with specific recommendations for Azure, see [Azure resiliency guidance: Failure mode analysis][fma].</span></span>

### <a name="example-of-identifying-failure-modes-and-detection-strategy"></a><span data-ttu-id="f4753-282">障害モードと検出戦略の特定例</span><span class="sxs-lookup"><span data-stu-id="f4753-282">Example of identifying failure modes and detection strategy</span></span>
<span data-ttu-id="f4753-283">**障害点:** 外部 Web サービス/API の呼び出し。</span><span class="sxs-lookup"><span data-stu-id="f4753-283">**Failure point:** Call to an external web service / API.</span></span>

| <span data-ttu-id="f4753-284">障害モード</span><span class="sxs-lookup"><span data-stu-id="f4753-284">Failure mode</span></span> | <span data-ttu-id="f4753-285">検出戦略</span><span class="sxs-lookup"><span data-stu-id="f4753-285">Detection strategy</span></span> |
| --- | --- |
| <span data-ttu-id="f4753-286">サービスを使用できない</span><span class="sxs-lookup"><span data-stu-id="f4753-286">Service is unavailable</span></span> |<span data-ttu-id="f4753-287">HTTP 5xx</span><span class="sxs-lookup"><span data-stu-id="f4753-287">HTTP 5xx</span></span> |
| <span data-ttu-id="f4753-288">調整</span><span class="sxs-lookup"><span data-stu-id="f4753-288">Throttling</span></span> |<span data-ttu-id="f4753-289">HTTP 429 (要求が多すぎます)</span><span class="sxs-lookup"><span data-stu-id="f4753-289">HTTP 429 (Too Many Requests)</span></span> |
| <span data-ttu-id="f4753-290">Authentication</span><span class="sxs-lookup"><span data-stu-id="f4753-290">Authentication</span></span> |<span data-ttu-id="f4753-291">HTTP 401 (権限がありません)</span><span class="sxs-lookup"><span data-stu-id="f4753-291">HTTP 401 (Unauthorized)</span></span> |
| <span data-ttu-id="f4753-292">遅い応答</span><span class="sxs-lookup"><span data-stu-id="f4753-292">Slow response</span></span> |<span data-ttu-id="f4753-293">要求のタイムアウト</span><span class="sxs-lookup"><span data-stu-id="f4753-293">Request times out</span></span> |


### <a name="redundancy-and-designing-for-failure"></a><span data-ttu-id="f4753-294">障害のための冗長性と設計</span><span class="sxs-lookup"><span data-stu-id="f4753-294">Redundancy and designing for failure</span></span>

<span data-ttu-id="f4753-295">障害が及ぼす影響の範囲はさまざまです。</span><span class="sxs-lookup"><span data-stu-id="f4753-295">Failures can vary in the scope of their impact.</span></span> <span data-ttu-id="f4753-296">たとえば、ディスク障害などの一部のハードウェア障害が、1 台のホスト コンピューターに影響を及ぼすことがあります。</span><span class="sxs-lookup"><span data-stu-id="f4753-296">Some hardware failures, such as a failed disk, may affect a single host machine.</span></span> <span data-ttu-id="f4753-297">障害が発生したネットワーク スイッチが、サーバー ラック全体に影響する場合もあります。</span><span class="sxs-lookup"><span data-stu-id="f4753-297">A failed network switch could affect a whole server rack.</span></span> <span data-ttu-id="f4753-298">データ センターの停電など、データ センター全体を中断させる障害はまれです。</span><span class="sxs-lookup"><span data-stu-id="f4753-298">Less common are failures that disrupt a whole data center, such as loss of power in a data center.</span></span> <span data-ttu-id="f4753-299">ほとんど発生しませんが、リージョン全体が利用できなくなることもあります。</span><span class="sxs-lookup"><span data-stu-id="f4753-299">Rarely, an entire region could become unavailable.</span></span>

<span data-ttu-id="f4753-300">アプリケーションの回復性を実現するための 1 つの手段として、冗長性があります。</span><span class="sxs-lookup"><span data-stu-id="f4753-300">One of the main ways to make an application resilient is through redundancy.</span></span> <span data-ttu-id="f4753-301">ただし、この冗長性は、アプリケーションの設計時に計画しなければなりません。</span><span class="sxs-lookup"><span data-stu-id="f4753-301">But you need to plan for this redundancy when you design the application.</span></span> <span data-ttu-id="f4753-302">また、必要な冗長性のレベルはビジネス要件によって異なります。リージョン障害に備えるために、すべてのアプリケーションにリージョン間での冗長性が必要だとは限りません。</span><span class="sxs-lookup"><span data-stu-id="f4753-302">Also, the level of redundancy that you need depends on your business requirements &mdash; not every application needs redundancy across regions to guard against a regional outage.</span></span> <span data-ttu-id="f4753-303">一般的に、冗長性と信頼性を高めると、コストと複雑さが増すというトレードオフがあります。</span><span class="sxs-lookup"><span data-stu-id="f4753-303">In general, there is a tradeoff between greater redundancy and reliability versus higher cost and complexity.</span></span>  

<span data-ttu-id="f4753-304">Azure には、個別の VM からリージョン全体まで、あらゆる障害レベルでアプリケーションの冗長性を確保するための機能が複数用意されています。</span><span class="sxs-lookup"><span data-stu-id="f4753-304">Azure has a number of features to make an application redundant at every level of failure, from an individual VM to an entire region.</span></span> 

![](./images/redundancy.svg)

<span data-ttu-id="f4753-305">**単一の VM**。</span><span class="sxs-lookup"><span data-stu-id="f4753-305">**Single VM**.</span></span> <span data-ttu-id="f4753-306">Azure では、単一の VM に対してはアップタイム SLA が用意されています。</span><span class="sxs-lookup"><span data-stu-id="f4753-306">Azure provides an uptime SLA for single VMs.</span></span> <span data-ttu-id="f4753-307">2 つ以上の VM を実行すると高い SLA を得られますが、ワークロードによっては単一の VM で十分な信頼性が得られる場合もあります。</span><span class="sxs-lookup"><span data-stu-id="f4753-307">Although you can get a higher SLA by running two or more VMs, a single VM may be reliable enough for some workloads.</span></span> <span data-ttu-id="f4753-308">運用環境のワークロードの場合は、2 つ以上の VM を使用して冗長性を確保することをお勧めします。</span><span class="sxs-lookup"><span data-stu-id="f4753-308">For production workloads, we recommend using two or more VMs for redundancy.</span></span> 

<span data-ttu-id="f4753-309">**可用性セット**。</span><span class="sxs-lookup"><span data-stu-id="f4753-309">**Availability sets**.</span></span> <span data-ttu-id="f4753-310">ディスクやネットワーク スイッチの障害など、ローカライズされたハードウェアの障害から保護するには、可用性セットに 2 つ以上の VM をデプロイします。</span><span class="sxs-lookup"><span data-stu-id="f4753-310">To protect against localized hardware failures, such as a disk or network switch failing, deploy two or more VMs in an availability set.</span></span> <span data-ttu-id="f4753-311">可用性セットは、電源とネットワーク スイッチを共有する 2 つ以上の "*障害ドメイン*" で構成されます。</span><span class="sxs-lookup"><span data-stu-id="f4753-311">An availability set consists of two or more *fault domains* that share a common power source and network switch.</span></span> <span data-ttu-id="f4753-312">可用性セットの VM は複数の障害ドメインに分散されるため、ある障害ドメインがハードウェア障害の影響を受けた場合は、ネットワーク トラフィックを他の障害ドメインの VM にルーティングできます。</span><span class="sxs-lookup"><span data-stu-id="f4753-312">VMs in an availability set are distributed across the fault domains, so if a hardware failure affects one fault domain, network traffic can still be routed the VMs in the other fault domains.</span></span> <span data-ttu-id="f4753-313">可用性セットの詳細については、「[Azure での Windows 仮想マシンの可用性の管理](/azure/virtual-machines/windows/manage-availability)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="f4753-313">For more information about Availability Sets, see [Manage the availability of Windows virtual machines in Azure](/azure/virtual-machines/windows/manage-availability).</span></span>

<span data-ttu-id="f4753-314">**可用性ゾーン**。</span><span class="sxs-lookup"><span data-stu-id="f4753-314">**Availability zones**.</span></span>  <span data-ttu-id="f4753-315">可用性ゾーンとは、Azure リージョンの物理的に独立したゾーンのことです。</span><span class="sxs-lookup"><span data-stu-id="f4753-315">An Availability Zone is a physically separate zone within an Azure region.</span></span> <span data-ttu-id="f4753-316">可用性ゾーンはそれぞれ異なる電源、ネットワーク、および冷却装置を持ちます。</span><span class="sxs-lookup"><span data-stu-id="f4753-316">Each Availability Zone has a distinct power source, network, and cooling.</span></span> <span data-ttu-id="f4753-317">可用性ゾーンに VM をデプロイすると、データセンター全体の障害からアプリケーションを保護するのに役立ちます。</span><span class="sxs-lookup"><span data-stu-id="f4753-317">Deploying VMs across availability zones helps to protect an application against datacenter-wide failures.</span></span> 

<span data-ttu-id="f4753-318">**ペアになっているリージョン**。</span><span class="sxs-lookup"><span data-stu-id="f4753-318">**Paired regions**.</span></span> <span data-ttu-id="f4753-319">リージョンの障害からアプリケーションを保護するために、複数のリージョンにアプリケーションをデプロイし、Azure Traffic Manager を使用してインターネット トラフィックを異なるリージョンに分散できます。</span><span class="sxs-lookup"><span data-stu-id="f4753-319">To protect an application against a regional outage, you can deploy the application across multiple regions, using Azure Traffic Manager to distribute internet traffic to the different regions.</span></span> <span data-ttu-id="f4753-320">各 Azure リージョンは別のリージョンとペアになります。</span><span class="sxs-lookup"><span data-stu-id="f4753-320">Each Azure region is paired with another region.</span></span> <span data-ttu-id="f4753-321">これが[リージョン ペア](/azure/best-practices-availability-paired-regions)になります。</span><span class="sxs-lookup"><span data-stu-id="f4753-321">Together, these form a [regional pair](/azure/best-practices-availability-paired-regions).</span></span> <span data-ttu-id="f4753-322">ブラジル南部を除き、リージョン ペアは、税および法の執行を目的としたデータ常駐要件を満たすために同じ地理的場所に配置されます。</span><span class="sxs-lookup"><span data-stu-id="f4753-322">With the exception of Brazil South, regional pairs are located within the same geography in order to meet data residency requirements for tax and law enforcement jurisdiction purposes.</span></span>

<span data-ttu-id="f4753-323">複数リージョンのアプリケーションを設計する場合、リージョン間のネットワーク待機時間は、リージョン内の待機時間よりも長くなることを考慮してください。</span><span class="sxs-lookup"><span data-stu-id="f4753-323">When you design a multi-region application, take into account that network latency across regions is higher than within a region.</span></span> <span data-ttu-id="f4753-324">たとえば、データベースをレプリケートしてフェールオーバーを有効にするときは、リージョン間の非同期データ レプリケーションではなく、リージョン内で同期データ レプリケーションを使用します。</span><span class="sxs-lookup"><span data-stu-id="f4753-324">For example, if you are replicating a database to enable failover, use synchronous data replication within a region, but asynchronous data replication across regions.</span></span>

| &nbsp; | <span data-ttu-id="f4753-325">可用性セット</span><span class="sxs-lookup"><span data-stu-id="f4753-325">Availability Set</span></span> | <span data-ttu-id="f4753-326">可用性ゾーン</span><span class="sxs-lookup"><span data-stu-id="f4753-326">Availability Zone</span></span> | <span data-ttu-id="f4753-327">ペアのリージョン</span><span class="sxs-lookup"><span data-stu-id="f4753-327">Paired region</span></span> |
|--------|------------------|-------------------|---------------|
| <span data-ttu-id="f4753-328">障害の範囲</span><span class="sxs-lookup"><span data-stu-id="f4753-328">Scope of failure</span></span> | <span data-ttu-id="f4753-329">ラック</span><span class="sxs-lookup"><span data-stu-id="f4753-329">Rack</span></span> | <span data-ttu-id="f4753-330">データセンター</span><span class="sxs-lookup"><span data-stu-id="f4753-330">Datacenter</span></span> | <span data-ttu-id="f4753-331">リージョン</span><span class="sxs-lookup"><span data-stu-id="f4753-331">Region</span></span> |
| <span data-ttu-id="f4753-332">要求のルーティング</span><span class="sxs-lookup"><span data-stu-id="f4753-332">Request routing</span></span> | <span data-ttu-id="f4753-333">Load Balancer</span><span class="sxs-lookup"><span data-stu-id="f4753-333">Load Balancer</span></span> | <span data-ttu-id="f4753-334">クロスゾーン ロード バランサー</span><span class="sxs-lookup"><span data-stu-id="f4753-334">Cross-zone Load Balancer</span></span> | <span data-ttu-id="f4753-335">Traffic Manager</span><span class="sxs-lookup"><span data-stu-id="f4753-335">Traffic Manager</span></span> |
| <span data-ttu-id="f4753-336">ネットワーク待ち時間</span><span class="sxs-lookup"><span data-stu-id="f4753-336">Network latency</span></span> | <span data-ttu-id="f4753-337">非常に低い</span><span class="sxs-lookup"><span data-stu-id="f4753-337">Very low</span></span> | <span data-ttu-id="f4753-338">低</span><span class="sxs-lookup"><span data-stu-id="f4753-338">Low</span></span> | <span data-ttu-id="f4753-339">中～高</span><span class="sxs-lookup"><span data-stu-id="f4753-339">Mid to high</span></span> |
| <span data-ttu-id="f4753-340">仮想ネットワーク</span><span class="sxs-lookup"><span data-stu-id="f4753-340">Virtual network</span></span>  | <span data-ttu-id="f4753-341">VNet</span><span class="sxs-lookup"><span data-stu-id="f4753-341">VNet</span></span> | <span data-ttu-id="f4753-342">VNet</span><span class="sxs-lookup"><span data-stu-id="f4753-342">VNet</span></span> | <span data-ttu-id="f4753-343">リージョン間 VNet ピアリング</span><span class="sxs-lookup"><span data-stu-id="f4753-343">Cross-region VNet peering</span></span> |

## <a name="implement-resiliency-strategies"></a><span data-ttu-id="f4753-344">回復性戦略を実装する</span><span class="sxs-lookup"><span data-stu-id="f4753-344">Implement resiliency strategies</span></span>
<span data-ttu-id="f4753-345">ここでは、一般的な回復性戦略の調査について説明します。</span><span class="sxs-lookup"><span data-stu-id="f4753-345">This section provides a survey of some common resiliency strategies.</span></span> <span data-ttu-id="f4753-346">ほとんどの項目は特定のテクノロジに限定されていません。</span><span class="sxs-lookup"><span data-stu-id="f4753-346">Most of these are not limited to a particular technology.</span></span> <span data-ttu-id="f4753-347">このセクションの説明では、各手法の背後にある一般的な考えをまとめ、詳細なドキュメントのリンクを紹介しています。</span><span class="sxs-lookup"><span data-stu-id="f4753-347">The descriptions in this section summarize the general idea behind each technique, with links to further reading.</span></span>

<span data-ttu-id="f4753-348">**一時的な障害を再試行する**。</span><span class="sxs-lookup"><span data-stu-id="f4753-348">**Retry transient failures**.</span></span> <span data-ttu-id="f4753-349">一時的な障害は、ネットワーク接続の一時的な喪失、データベース接続の欠落、またはサービスがビジー状態のときのタイムアウトが原因で発生します。</span><span class="sxs-lookup"><span data-stu-id="f4753-349">Transient failures can be caused by momentary loss of network connectivity, a dropped database connection, or a timeout when a service is busy.</span></span> <span data-ttu-id="f4753-350">多くの場合、一時的な障害は、要求を再試行するだけで解決できます。</span><span class="sxs-lookup"><span data-stu-id="f4753-350">Often, a transient failure can be resolved simply by retrying the request.</span></span> <span data-ttu-id="f4753-351">多くの Azure サービスでは、クライアント SDK が呼び出し元には認識されない方法の自動再試行を実装しています。詳細については、[サービス固有の再試行ガイダンス][retry-service-specific guidance]に関するページを参照してください。</span><span class="sxs-lookup"><span data-stu-id="f4753-351">For many Azure services, the client SDK implements automatic retries, in a way that is transparent to the caller; see [Retry service specific guidance][retry-service-specific guidance].</span></span>

<span data-ttu-id="f4753-352">再試行ごとに、合計待機時間が追加されます。</span><span class="sxs-lookup"><span data-stu-id="f4753-352">Each retry attempt adds to the total latency.</span></span> <span data-ttu-id="f4753-353">また、失敗した要求が多すぎると、保留中の要求がキューに蓄積されるため、ボトルネックの原因になる可能性があります。</span><span class="sxs-lookup"><span data-stu-id="f4753-353">Also, too many failed requests can cause a bottleneck, as pending requests accumulate in the queue.</span></span> <span data-ttu-id="f4753-354">これらのブロックされた要求が重要なシステム リソース (メモリ、しきい値、データベース接続など) を保持することで、障害が連鎖する可能性があります。</span><span class="sxs-lookup"><span data-stu-id="f4753-354">These blocked requests might hold critical system resources such as memory, threads, database connections, and so on, which can cause cascading failures.</span></span> <span data-ttu-id="f4753-355">この問題を回避するために、再試行間隔を長くして、失敗した要求の合計数を制限します。</span><span class="sxs-lookup"><span data-stu-id="f4753-355">To avoid this, increase the delay between each retry attempt, and limit the total number of failed requests.</span></span> 

![](./images/retry.png)

<span data-ttu-id="f4753-356">**インスタンス間で負荷分散する**。</span><span class="sxs-lookup"><span data-stu-id="f4753-356">**Load balance across instances**.</span></span> <span data-ttu-id="f4753-357">スケーラビリティのために、インスタンス数を増やしてクラウド アプリケーションをスケールアウトすることをお勧めします。</span><span class="sxs-lookup"><span data-stu-id="f4753-357">For scalability, a cloud application should be able to scale out by adding more instances.</span></span> <span data-ttu-id="f4753-358">この方法では、正常ではないインスタンスをローテーションから除去できるため、回復性も改善されます。</span><span class="sxs-lookup"><span data-stu-id="f4753-358">This approach also improves resiliency, because unhealthy instances can be removed from rotation.</span></span> <span data-ttu-id="f4753-359">例: </span><span class="sxs-lookup"><span data-stu-id="f4753-359">For example:</span></span>

* <span data-ttu-id="f4753-360">複数の VM をロード バランサーの内側に配置します。</span><span class="sxs-lookup"><span data-stu-id="f4753-360">Put two or more VMs behind a load balancer.</span></span> <span data-ttu-id="f4753-361">ロード バランサーはトラフィックをすべての VM に分散します。</span><span class="sxs-lookup"><span data-stu-id="f4753-361">The load balancer distributes traffic to all the VMs.</span></span> <span data-ttu-id="f4753-362">「[Run load-balanced VMs for scalability and availability][ra-multi-vm]」(スケーラビリティと可用性のために負荷分散された VM を実行する) を参照してください。</span><span class="sxs-lookup"><span data-stu-id="f4753-362">See [Run load-balanced VMs for scalability and availability][ra-multi-vm].</span></span>
* <span data-ttu-id="f4753-363">Azure App Service アプリを複数インスタンスにスケールアウトします。</span><span class="sxs-lookup"><span data-stu-id="f4753-363">Scale out an Azure App Service app to multiple instances.</span></span> <span data-ttu-id="f4753-364">App Service は自動的にインスタンス全体に負荷を分散します。</span><span class="sxs-lookup"><span data-stu-id="f4753-364">App Service automatically balances load across instances.</span></span> <span data-ttu-id="f4753-365">「[Basic web application][ra-basic-web]」(基本的な Web アプリケーション) を参照してください。</span><span class="sxs-lookup"><span data-stu-id="f4753-365">See [Basic web application][ra-basic-web].</span></span>
* <span data-ttu-id="f4753-366">[Azure Traffic Manager][tm] を使用して、一連のエンドポイント全体でトラフィックを分散します。</span><span class="sxs-lookup"><span data-stu-id="f4753-366">Use [Azure Traffic Manager][tm] to distribute traffic across a set of endpoints.</span></span>

<span data-ttu-id="f4753-367">**データをレプリケートする**。</span><span class="sxs-lookup"><span data-stu-id="f4753-367">**Replicate data**.</span></span> <span data-ttu-id="f4753-368">データのレプリケートは、データ ストアの一時的ではない障害を処理する場合の一般的な戦略です。</span><span class="sxs-lookup"><span data-stu-id="f4753-368">Replicating data is a general strategy for handling non-transient failures in a data store.</span></span> <span data-ttu-id="f4753-369">Azure SQL Database、Cosmos DB、Apache Cassandra など、多くのストレージ テクノロジにはレプリケーション機能が組み込まれています。</span><span class="sxs-lookup"><span data-stu-id="f4753-369">Many storage technologies provide built-in replication, including Azure SQL Database, Cosmos DB, and Apache Cassandra.</span></span> <span data-ttu-id="f4753-370">読み取りパスと書き込みパスの両方を考慮することが重要です。</span><span class="sxs-lookup"><span data-stu-id="f4753-370">It's important to consider both the read and write paths.</span></span> <span data-ttu-id="f4753-371">戦略テクノロジに応じて、複数の書き込み可能なレプリカ、または単一の書き込み可能なレプリカと複数の読み取り専用レプリカを用意する必要があります。</span><span class="sxs-lookup"><span data-stu-id="f4753-371">Depending on the storage technology, you might have multiple writable replicas, or a single writable replica and multiple read-only replicas.</span></span> 

<span data-ttu-id="f4753-372">可用性を最大限にするために、レプリカを複数のリージョンに配置する方法もあります。</span><span class="sxs-lookup"><span data-stu-id="f4753-372">To maximize availability, replicas can be placed in multiple regions.</span></span> <span data-ttu-id="f4753-373">ただし、データをレプリケートすると待機時間が長くなります。</span><span class="sxs-lookup"><span data-stu-id="f4753-373">However, this increases the latency when replicating the data.</span></span> <span data-ttu-id="f4753-374">通常、複数リージョンをまたがるレプリケートは非同期に行われます。これは最終的な整合性モデルであり、レプリカで障害が発生した場合にはデータ損失が発生する可能性があります。</span><span class="sxs-lookup"><span data-stu-id="f4753-374">Typically, replicating across regions is done asynchronously, which implies an eventual consistency model and potential data loss if a replica fails.</span></span> 

<span data-ttu-id="f4753-375">**潔く機能を減らす**。</span><span class="sxs-lookup"><span data-stu-id="f4753-375">**Degrade gracefully**.</span></span> <span data-ttu-id="f4753-376">サービスで障害が発生し、フェールオーバー パスがない場合、許容範囲のユーザー エクスペリエンスを提供した状態で、アプリケーションの機能を適切に低下させることができます。</span><span class="sxs-lookup"><span data-stu-id="f4753-376">If a service fails and there is no failover path, the application may be able to degrade gracefully while still providing an acceptable user experience.</span></span> <span data-ttu-id="f4753-377">例: </span><span class="sxs-lookup"><span data-stu-id="f4753-377">For example:</span></span>

* <span data-ttu-id="f4753-378">作業項目を後で処理できるようにキューに格納します。</span><span class="sxs-lookup"><span data-stu-id="f4753-378">Put a work item on a queue, to be handled later.</span></span> 
* <span data-ttu-id="f4753-379">予測値を返します。</span><span class="sxs-lookup"><span data-stu-id="f4753-379">Return an estimated value.</span></span>
* <span data-ttu-id="f4753-380">ローカルにキャッシュされたデータを使用します。</span><span class="sxs-lookup"><span data-stu-id="f4753-380">Use locally cached data.</span></span> 
* <span data-ttu-id="f4753-381">ユーザーにエラー メッセージを表示します</span><span class="sxs-lookup"><span data-stu-id="f4753-381">Show the user an error message.</span></span> <span data-ttu-id="f4753-382">(この選択肢は、アプリケーションが要求への応答を停止するよりも優れています)。</span><span class="sxs-lookup"><span data-stu-id="f4753-382">(This option is better than having the application stop responding to requests.)</span></span>

<span data-ttu-id="f4753-383">**高負荷のユーザーを調整する**。</span><span class="sxs-lookup"><span data-stu-id="f4753-383">**Throttle high-volume users**.</span></span> <span data-ttu-id="f4753-384">少数のユーザーが過剰な負荷を発生させることがあります。</span><span class="sxs-lookup"><span data-stu-id="f4753-384">Sometimes a small number of users create excessive load.</span></span> <span data-ttu-id="f4753-385">その結果、他のユーザーに影響が及び、アプリケーションの全体的な可用性が低くなる可能性があります。</span><span class="sxs-lookup"><span data-stu-id="f4753-385">That can have an impact on other users, reducing the overall availability of your application.</span></span>

<span data-ttu-id="f4753-386">単一のクライアントが大量の要求を行った場合、一定期間、アプリケーションはクライアントを調整することができます。</span><span class="sxs-lookup"><span data-stu-id="f4753-386">When a single client makes an excessive number of requests, the application might throttle the client for a certain period of time.</span></span> <span data-ttu-id="f4753-387">この調整期間、(詳細な調整戦略に基づいて) アプリケーションはそのクライアントからの要求の一部またはすべてを拒否します。</span><span class="sxs-lookup"><span data-stu-id="f4753-387">During the throttling period, the application refuses some or all of the requests from that client (depending on the exact throttling strategy).</span></span> <span data-ttu-id="f4753-388">調整のしきい値は、ユーザーのサービス レベルによって変わる可能性があります。</span><span class="sxs-lookup"><span data-stu-id="f4753-388">The threshold for throttling might depend on the customer's service tier.</span></span> 

<span data-ttu-id="f4753-389">調整は、クライアントが悪意を持って実行している場合に限定されません。サービス クォータを超えたというだけの理由で行われます。</span><span class="sxs-lookup"><span data-stu-id="f4753-389">Throttling does not imply the client was necessarily acting maliciously, only that it exceeded its service quota.</span></span> <span data-ttu-id="f4753-390">場合によっては、コンシューマーが常にクォータを超えているか、動作が正しくない可能性があります。</span><span class="sxs-lookup"><span data-stu-id="f4753-390">In some cases, a consumer might consistently exceed their quota or otherwise behave badly.</span></span> <span data-ttu-id="f4753-391">この場合は、さらにユーザーをブロックすることがあります。</span><span class="sxs-lookup"><span data-stu-id="f4753-391">In that case, you might go further and block the user.</span></span> <span data-ttu-id="f4753-392">通常、このブロックを行うには、API キーまたは IP アドレス範囲をブロックします。</span><span class="sxs-lookup"><span data-stu-id="f4753-392">Typically, this is done by blocking an API key or an IP address range.</span></span> <span data-ttu-id="f4753-393">詳細については、「[Throttling pattern][throttling-pattern]」(調整パターン) を参照してください。</span><span class="sxs-lookup"><span data-stu-id="f4753-393">For more information, see [Throttling Pattern][throttling-pattern].</span></span>

<span data-ttu-id="f4753-394">**サーキット ブレーカーを使用する**。</span><span class="sxs-lookup"><span data-stu-id="f4753-394">**Use a circuit breaker**.</span></span> <span data-ttu-id="f4753-395">[サーキット ブレーカー][circuit-breaker-pattern] パターンを使用すると、失敗する可能性のある操作がアプリケーションで繰り返し再試行されるのを回避できます。</span><span class="sxs-lookup"><span data-stu-id="f4753-395">The [Circuit Breaker][circuit-breaker-pattern] pattern can prevent an application from repeatedly trying an operation that is likely to fail.</span></span> <span data-ttu-id="f4753-396">サーキット ブレーカーはサービスの呼び出しをラップし、最近発生したエラーの数を追跡します。</span><span class="sxs-lookup"><span data-stu-id="f4753-396">The circuit breaker wraps calls to a service and tracks the number of recent failures.</span></span> <span data-ttu-id="f4753-397">エラーの数がしきい値を超えると、サーキット ブレーカーはサービスを呼び出さずに、エラー コードを返し始めます。</span><span class="sxs-lookup"><span data-stu-id="f4753-397">If the failure count exceeds a threshold, the circuit breaker starts returning an error code without calling the service.</span></span> <span data-ttu-id="f4753-398">これにより、サービスが復旧するための時間が確保されます。</span><span class="sxs-lookup"><span data-stu-id="f4753-398">This gives the service time to recover.</span></span> 

<span data-ttu-id="f4753-399">**負荷平準化を使用してトラフィックの急増をなくす**。</span><span class="sxs-lookup"><span data-stu-id="f4753-399">**Use load leveling to smooth out spikes in traffic**.</span></span> <span data-ttu-id="f4753-400">アプリケーションではトラフィックの急増が起きることがあり、これがバックエンドのサービスに大きな負荷をかけることがあります。</span><span class="sxs-lookup"><span data-stu-id="f4753-400">Applications may experience sudden spikes in traffic, which can overwhelm services on the backend.</span></span> <span data-ttu-id="f4753-401">バックエンド サービスが要求にすばやく応答できない場合、要求がキューに格納されることや (バックアップ)、サービスによってアプリケーションが調整されることがあります。</span><span class="sxs-lookup"><span data-stu-id="f4753-401">If a backend service cannot respond to requests quickly enough, it may cause requests to queue (back up), or cause the service to throttle the application.</span></span> <span data-ttu-id="f4753-402">この状況を回避するために、バッファーとしてキューを使用することができます。</span><span class="sxs-lookup"><span data-stu-id="f4753-402">To avoid this, you can use a queue as a buffer.</span></span> <span data-ttu-id="f4753-403">新しい作業項目がある場合、バックエンド サービスを即時に呼び出すのではなく、アプリケーションで作業項目をキューに格納して非同期に実行します。</span><span class="sxs-lookup"><span data-stu-id="f4753-403">When there is a new work item, instead of calling the backend service immediately, the application queues a work item to run asynchronously.</span></span> <span data-ttu-id="f4753-404">キューは、負荷のピークを平準化するバッファーとして機能します。</span><span class="sxs-lookup"><span data-stu-id="f4753-404">The queue acts as a buffer that smooths out peaks in the load.</span></span> <span data-ttu-id="f4753-405">詳細については、[Queue-Based Load Leveling パターン][load-leveling-pattern]に関するページを参照してください。</span><span class="sxs-lookup"><span data-stu-id="f4753-405">For more information, see [Queue-Based Load Leveling Pattern][load-leveling-pattern].</span></span>

<span data-ttu-id="f4753-406">**重要なリソースを分離する**。</span><span class="sxs-lookup"><span data-stu-id="f4753-406">**Isolate critical resources**.</span></span> <span data-ttu-id="f4753-407">1 つのサブシステムで複数の障害が連鎖し、アプリケーションの他の部分で障害が発生する可能性があります。</span><span class="sxs-lookup"><span data-stu-id="f4753-407">Failures in one subsystem can sometimes cascade, causing failures in other parts of the application.</span></span> <span data-ttu-id="f4753-408">これが起きるのは、障害によってスレッドやソケットなどのリソースが適切なタイミングで解放されない場合で、リソースの消費につながります。</span><span class="sxs-lookup"><span data-stu-id="f4753-408">This can happen if a failure causes some resources, such as threads or sockets, not to get freed in a timely manner, leading to resource exhaustion.</span></span> 

<span data-ttu-id="f4753-409">これを回避するには、システムを分離グループにパーティション分割して、1 つのパーティションでの障害がシステム全体をダウンさせないようにします。</span><span class="sxs-lookup"><span data-stu-id="f4753-409">To avoid this, you can partition a system into isolated groups, so that a failure in one partition does not bring down the entire system.</span></span> <span data-ttu-id="f4753-410">この手法は、バルクヘッド パターンとも呼ばれます。</span><span class="sxs-lookup"><span data-stu-id="f4753-410">This technique is sometimes called the Bulkhead pattern.</span></span>

<span data-ttu-id="f4753-411">次に例を示します。</span><span class="sxs-lookup"><span data-stu-id="f4753-411">Examples:</span></span>

* <span data-ttu-id="f4753-412">データベースをパーティション分割し (テナント別など)、各パーティションに Web サーバー インスタンスの別プールを割り当てます。</span><span class="sxs-lookup"><span data-stu-id="f4753-412">Partition a database (for example, by tenant) and assign a separate pool of web server instances for each partition.</span></span>  
* <span data-ttu-id="f4753-413">個別のスレッド プールを使用して、異なるサービスの呼び出しを分離します。</span><span class="sxs-lookup"><span data-stu-id="f4753-413">Use separate thread pools to isolate calls to different services.</span></span> <span data-ttu-id="f4753-414">こうすることで、いずれかのサービスで障害が発生した場合の障害の連鎖を回避できます。</span><span class="sxs-lookup"><span data-stu-id="f4753-414">This helps to prevent cascading failures if one of the services fails.</span></span> <span data-ttu-id="f4753-415">例については、Netflix の [Hystrix ライブラリ][hystrix]を参照してください。</span><span class="sxs-lookup"><span data-stu-id="f4753-415">For an example, see the Netflix [Hystrix library][hystrix].</span></span>
* <span data-ttu-id="f4753-416">[コンテナー][containers]を使用して、特定のサブシステムに使用できるリソースを制限します。</span><span class="sxs-lookup"><span data-stu-id="f4753-416">Use [containers][containers] to limit the resources available to a particular subsystem.</span></span> 

![](./images/bulkhead.png)

<span data-ttu-id="f4753-417">**補正トランザクションを適用する**。</span><span class="sxs-lookup"><span data-stu-id="f4753-417">**Apply compensating transactions**.</span></span> <span data-ttu-id="f4753-418">[補正トランザクション][compensating-transaction-pattern]は、別の完了したトランザクションの影響を元に戻すトランザクションです。</span><span class="sxs-lookup"><span data-stu-id="f4753-418">A [compensating transaction][compensating-transaction-pattern] is a transaction that undoes the effects of another completed transaction.</span></span> <span data-ttu-id="f4753-419">分散システムでは、厳密なトランザクションの一貫性を実現することが非常に困難な可能性があります。</span><span class="sxs-lookup"><span data-stu-id="f4753-419">In a distributed system, it can be very difficult to achieve strong transactional consistency.</span></span> <span data-ttu-id="f4753-420">補正トランザクションは、各手順で元に戻すことができる一連の小規模な個別トランザクションを使用することで、一貫性を実現する方法です。</span><span class="sxs-lookup"><span data-stu-id="f4753-420">Compensating transactions are a way to achieve consistency by using a series of smaller, individual transactions that can be undone at each step.</span></span>

<span data-ttu-id="f4753-421">たとえば、旅行を予約する場合、ユーザーは車、ホテルの客室、航空便を予約する可能性があります。</span><span class="sxs-lookup"><span data-stu-id="f4753-421">For example, to book a trip, a customer might reserve a car, a hotel room, and a flight.</span></span> <span data-ttu-id="f4753-422">これらいずれかの手順に失敗した場合、操作全体が失敗します。</span><span class="sxs-lookup"><span data-stu-id="f4753-422">If any of these steps fails, the entire operation fails.</span></span> <span data-ttu-id="f4753-423">操作全体に単一の分散トランザクションを使用するのではなく、各手順に補正トランザクションを定義することができます。</span><span class="sxs-lookup"><span data-stu-id="f4753-423">Instead of trying to use a single distributed transaction for the entire operation, you can define a compensating transaction for each step.</span></span> <span data-ttu-id="f4753-424">たとえば、車の予約を元に戻すには、予約を取り消します。</span><span class="sxs-lookup"><span data-stu-id="f4753-424">For example, to undo a car reservation, you cancel the reservation.</span></span> <span data-ttu-id="f4753-425">操作全体を完了するために、コーディネーターは各手順を実行します。</span><span class="sxs-lookup"><span data-stu-id="f4753-425">In order to complete the whole operation, a coordinator executes each step.</span></span> <span data-ttu-id="f4753-426">いずれかの手順が失敗すると、コーディネーターは補正トランザクションを適用し、完了したすべての手順を元に戻します。</span><span class="sxs-lookup"><span data-stu-id="f4753-426">If any step fails, the coordinator applies compensating transactions to undo any steps that were completed.</span></span> 

## <a name="test-for-resiliency"></a><span data-ttu-id="f4753-427">回復性のテスト</span><span class="sxs-lookup"><span data-stu-id="f4753-427">Test for resiliency</span></span>
<span data-ttu-id="f4753-428">一般的に、アプリケーション機能のテストと同じ方法 (単体テストの実行など) で回復性をテストすることはできません。</span><span class="sxs-lookup"><span data-stu-id="f4753-428">Generally, you can't test resiliency in the same way that you test application functionality (by running unit tests and so on).</span></span> <span data-ttu-id="f4753-429">代わりに、断続的にのみ発生する障害条件下で、エンドツーエンドのワークロードが動作する方法をテストする必要があります。</span><span class="sxs-lookup"><span data-stu-id="f4753-429">Instead, you must test how the end-to-end workload performs under failure conditions which only occur intermittently.</span></span>

<span data-ttu-id="f4753-430">テストは反復的なプロセスです。</span><span class="sxs-lookup"><span data-stu-id="f4753-430">Testing is an iterative process.</span></span> <span data-ttu-id="f4753-431">アプリケーションをテストし、結果を測定し、結果のすべてのエラーを分析して対応し、プロセスを繰り返します。</span><span class="sxs-lookup"><span data-stu-id="f4753-431">Test the application, measure the outcome, analyze and address any failures that result, and repeat the process.</span></span>

<span data-ttu-id="f4753-432">**フォールト挿入テスト**。</span><span class="sxs-lookup"><span data-stu-id="f4753-432">**Fault injection testing**.</span></span> <span data-ttu-id="f4753-433">実際のエラーをトリガーするまたはシミュレートすることによって、システムの障害への回復性をテストすることができます。</span><span class="sxs-lookup"><span data-stu-id="f4753-433">Test the resiliency of the system during failures, either by triggering actual failures or by simulating them.</span></span> <span data-ttu-id="f4753-434">テストされる一般的な障害シナリオを次に示します。</span><span class="sxs-lookup"><span data-stu-id="f4753-434">Here are some common failure scenarios to test:</span></span>

* <span data-ttu-id="f4753-435">VM インスタンスのシャットダウン。</span><span class="sxs-lookup"><span data-stu-id="f4753-435">Shut down VM instances.</span></span>
* <span data-ttu-id="f4753-436">プロセスのクラッシュ。</span><span class="sxs-lookup"><span data-stu-id="f4753-436">Crash processes.</span></span>
* <span data-ttu-id="f4753-437">証明書の期限切れ。</span><span class="sxs-lookup"><span data-stu-id="f4753-437">Expire certificates.</span></span>
* <span data-ttu-id="f4753-438">アクセス キーの変更。</span><span class="sxs-lookup"><span data-stu-id="f4753-438">Change access keys.</span></span>
* <span data-ttu-id="f4753-439">ドメイン コントローラー上の DNS サービスのシャットダウン。</span><span class="sxs-lookup"><span data-stu-id="f4753-439">Shut down the DNS service on domain controllers.</span></span>
* <span data-ttu-id="f4753-440">RAM やスレッド数など、使用可能なシステム リソースの制限。</span><span class="sxs-lookup"><span data-stu-id="f4753-440">Limit available system resources, such as RAM or number of threads.</span></span>
* <span data-ttu-id="f4753-441">ディスクのマウント解除。</span><span class="sxs-lookup"><span data-stu-id="f4753-441">Unmount disks.</span></span>
* <span data-ttu-id="f4753-442">VM の再デプロイ。</span><span class="sxs-lookup"><span data-stu-id="f4753-442">Redeploy a VM.</span></span>

<span data-ttu-id="f4753-443">回復時間を測定し、ビジネス要件を満たしていることを確認します。</span><span class="sxs-lookup"><span data-stu-id="f4753-443">Measure the recovery times and verify that your business requirements are met.</span></span> <span data-ttu-id="f4753-444">障害モードの組み合わせもテストします。</span><span class="sxs-lookup"><span data-stu-id="f4753-444">Test combinations of failure modes as well.</span></span> <span data-ttu-id="f4753-445">障害が連鎖しないこと、分離された方法で処理されることを確認します。</span><span class="sxs-lookup"><span data-stu-id="f4753-445">Make sure that failures don't cascade, and are handled in an isolated way.</span></span>

<span data-ttu-id="f4753-446">これが、設計フェーズで潜在的な障害点を分析することが重要なもう 1 つの理由です。</span><span class="sxs-lookup"><span data-stu-id="f4753-446">This is another reason why it's important to analyze possible failure points during the design phase.</span></span> <span data-ttu-id="f4753-447">この分析結果をテスト計画に反映させることをお勧めします。</span><span class="sxs-lookup"><span data-stu-id="f4753-447">The results of that analysis should be inputs into your test plan.</span></span>

<span data-ttu-id="f4753-448">**ロード テスト**。</span><span class="sxs-lookup"><span data-stu-id="f4753-448">**Load testing**.</span></span> <span data-ttu-id="f4753-449">ロード テストは、過負荷状態またはサービスの調整が行われているバックエンド データベースなど、負荷がかかった状態でのみ発生する障害を特定するために重要です。</span><span class="sxs-lookup"><span data-stu-id="f4753-449">Load testing is crucial for identifying failures that only happen under load, such as the backend database being overwhelmed or service throttling.</span></span> <span data-ttu-id="f4753-450">運用データまたは運用データに可能な限り近い総合的なデータを使用して、ピーク負荷の場合をテストします。</span><span class="sxs-lookup"><span data-stu-id="f4753-450">Test for peak load, using production data or synthetic data that is as close to production data as possible.</span></span> <span data-ttu-id="f4753-451">目標は、実際の条件下でアプリケーションがどのように動作するかを確認することです。</span><span class="sxs-lookup"><span data-stu-id="f4753-451">The goal is to see how the application behaves under real-world conditions.</span></span>   

## <a name="deploy-using-reliable-processes"></a><span data-ttu-id="f4753-452">信頼性の高いプロセスを使用してデプロイする</span><span class="sxs-lookup"><span data-stu-id="f4753-452">Deploy using reliable processes</span></span>
<span data-ttu-id="f4753-453">アプリケーションを運用環境にデプロイした場合、更新プログラムがエラーの原因になることがあります。</span><span class="sxs-lookup"><span data-stu-id="f4753-453">Once an application is deployed to production, updates are a possible source of errors.</span></span> <span data-ttu-id="f4753-454">最悪の場合には、更新プログラムの不良でダウンタイムが発生することがあります。</span><span class="sxs-lookup"><span data-stu-id="f4753-454">In the worst case, a bad update can cause downtime.</span></span> <span data-ttu-id="f4753-455">この問題を回避するために、デプロイ プロセスを予測可能で反復的にする必要があります。</span><span class="sxs-lookup"><span data-stu-id="f4753-455">To avoid this, the deployment process must be predictable and repeatable.</span></span> <span data-ttu-id="f4753-456">デプロイには、Azure リソースのプロビジョニング、アプリケーション コードのデプロイ、構成設定の適用が含まれます。</span><span class="sxs-lookup"><span data-stu-id="f4753-456">Deployment includes provisioning Azure resources, deploying application code, and applying configuration settings.</span></span> <span data-ttu-id="f4753-457">1 つの更新プログラムで、この 3 つすべて、または一部が行われることがあります。</span><span class="sxs-lookup"><span data-stu-id="f4753-457">An update may involve all three, or a subset.</span></span> 

<span data-ttu-id="f4753-458">手動のデプロイはエラーが起きやすいという点が重要です。</span><span class="sxs-lookup"><span data-stu-id="f4753-458">The crucial point is that manual deployments are prone to error.</span></span> <span data-ttu-id="f4753-459">そのため、必要に応じて実行可能で、何かが失敗した場合に再実行できる自動的なべき等プロセスを用意することをお勧めします。</span><span class="sxs-lookup"><span data-stu-id="f4753-459">Therefore, it's recommended to have an automated, idempotent process that you can run on demand, and re-run if something fails.</span></span> 

* <span data-ttu-id="f4753-460">Azure Resource Manager テンプレートを使用して、Azure リソースのプロビジョニングを自動化します。</span><span class="sxs-lookup"><span data-stu-id="f4753-460">Use Azure Resource Manager templates to automate provisioning of Azure resources.</span></span>
* <span data-ttu-id="f4753-461">[Azure Automation Desired State Configuration][dsc] (DSC) を使用して VM を構成します。</span><span class="sxs-lookup"><span data-stu-id="f4753-461">Use [Azure Automation Desired State Configuration][dsc] (DSC) to configure VMs.</span></span>
* <span data-ttu-id="f4753-462">アプリケーション コードに自動デプロイ プロセスを使用します。</span><span class="sxs-lookup"><span data-stu-id="f4753-462">Use an automated deployment process for application code.</span></span>

<span data-ttu-id="f4753-463">*コードとしてのインフラストラクチャ*と*イミュータブル インフラストラクチャ*という回復性のデプロイに関連する 2 つの概念があります。</span><span class="sxs-lookup"><span data-stu-id="f4753-463">Two concepts related to resilient deployment are *infrastructure as code* and *immutable infrastructure*.</span></span>

* <span data-ttu-id="f4753-464">**コードとしてのインフラストラクチャ**は、コードを使用してインフラストラクチャのプロビジョニングと構成を行う手法です。</span><span class="sxs-lookup"><span data-stu-id="f4753-464">**Infrastructure as code** is the practice of using code to provision and configure infrastructure.</span></span> <span data-ttu-id="f4753-465">コードとしてのインフラストラクチャには、宣言型の方法、命令型の方法 (またはその両方の組み合わせ) を使用することができます。</span><span class="sxs-lookup"><span data-stu-id="f4753-465">Infrastructure as code may use a declarative approach or an imperative approach (or a combination of both).</span></span> <span data-ttu-id="f4753-466">宣言型の方法の例として、Resource Manager テンプレートがあります。</span><span class="sxs-lookup"><span data-stu-id="f4753-466">Resource Manager templates are an example of a declarative approach.</span></span> <span data-ttu-id="f4753-467">PowerShell スクリプトは、命令型の方法の一例です。</span><span class="sxs-lookup"><span data-stu-id="f4753-467">PowerShell scripts are an example of an imperative approach.</span></span>
* <span data-ttu-id="f4753-468">**イミュータブル インフラストラクチャ**は、運用環境にデプロイした後にインフラストラクチャを変更すべきではないという原則です。</span><span class="sxs-lookup"><span data-stu-id="f4753-468">**Immutable infrastructure** is the principle that you shouldn’t modify infrastructure after it’s deployed to production.</span></span> <span data-ttu-id="f4753-469">そうしないと、場当たりの変更が適用され、変更内容を正確に把握しづらくなり、システムについて論理的に判断しづらくなる状態に陥る可能性があります。</span><span class="sxs-lookup"><span data-stu-id="f4753-469">Otherwise, you can get into a state where ad hoc changes have been applied, so it's hard to know exactly what changed, and hard to reason about the system.</span></span> 

<span data-ttu-id="f4753-470">もう 1 つの問題は、アプリケーションの更新プログラムを展開する方法です。</span><span class="sxs-lookup"><span data-stu-id="f4753-470">Another question is how to roll out an application update.</span></span> <span data-ttu-id="f4753-471">ブルーグリーン デプロイまたはカナリア リリースなどの手法を採用して高度に制御された方法で更新プログラムをプッシュし、不適切なデプロイの考えられる影響を最小限に抑えることをお勧めします。</span><span class="sxs-lookup"><span data-stu-id="f4753-471">We recommend techniques such as blue-green deployment or canary releases, which push updates in highly controlled way to minimize possible impacts from a bad deployment.</span></span>

* <span data-ttu-id="f4753-472">[ブルーグリーン デプロイ][blue-green]は、ライブ アプリケーションとは別の運用環境に更新プログラムをデプロイする手法です。</span><span class="sxs-lookup"><span data-stu-id="f4753-472">[Blue-green deployment][blue-green] is a technique where an update is deployed into a production environment separate from the live application.</span></span> <span data-ttu-id="f4753-473">デプロイの検証が完了したら、トラフィック ルーティングを更新されたバージョンに切り替えます。</span><span class="sxs-lookup"><span data-stu-id="f4753-473">After you validate the deployment, switch the traffic routing to the updated version.</span></span> <span data-ttu-id="f4753-474">たとえば、Azure App Service Web Apps を使用すると、このステージング スロットが可能になります。</span><span class="sxs-lookup"><span data-stu-id="f4753-474">For example, Azure App Service Web Apps enables this with staging slots.</span></span>
* <span data-ttu-id="f4753-475">[カナリア リリース][canary-release]は、ブルーグリーン デプロイと似ています。</span><span class="sxs-lookup"><span data-stu-id="f4753-475">[Canary releases][canary-release] are similar to blue-green deployments.</span></span> <span data-ttu-id="f4753-476">すべてのトラフィックを更新されたバージョンに切り替えるのではなく、トラフィックの一部を新しいデプロイにルーティングすることで更新プログラムを少数のユーザーに展開します。</span><span class="sxs-lookup"><span data-stu-id="f4753-476">Instead of switching all traffic to the updated version, you roll out the update to a small percentage of users, by routing a portion of the traffic to the new deployment.</span></span> <span data-ttu-id="f4753-477">問題が発生した場合は、以前のデプロイに戻します。</span><span class="sxs-lookup"><span data-stu-id="f4753-477">If there is a problem, back off and revert to the old deployment.</span></span> <span data-ttu-id="f4753-478">問題が発生しない場合は、より多くのトラフィックを新しいバージョンにルーティングします。トラフィックの 100% になるまでこの手順を実行します。</span><span class="sxs-lookup"><span data-stu-id="f4753-478">Otherwise, route more of the traffic to the new version, until it gets 100% of the traffic.</span></span>

<span data-ttu-id="f4753-479">どの方法を採用する場合でも、新しいバージョンが機能しなかった場合に最後の正常なデプロイに戻すことができるようにします。</span><span class="sxs-lookup"><span data-stu-id="f4753-479">Whatever approach you take, make sure that you can roll back to the last-known-good deployment, in case the new version is not functioning.</span></span> <span data-ttu-id="f4753-480">また、エラーが発生した場合、アプリケーション ログでエラーの原因となったバージョンを特定できるようにします。</span><span class="sxs-lookup"><span data-stu-id="f4753-480">Also, if errors occur, the application logs must indicate which version caused the error.</span></span> 

## <a name="monitor-to-detect-failures"></a><span data-ttu-id="f4753-481">監視によって障害を検出する</span><span class="sxs-lookup"><span data-stu-id="f4753-481">Monitor to detect failures</span></span>
<span data-ttu-id="f4753-482">監視と診断は回復性にとって非常に重要です。</span><span class="sxs-lookup"><span data-stu-id="f4753-482">Monitoring and diagnostics are crucial for resiliency.</span></span> <span data-ttu-id="f4753-483">何かが失敗した場合、失敗したことを把握し、障害の原因を分析する必要があります。</span><span class="sxs-lookup"><span data-stu-id="f4753-483">If something fails, you need to know that it failed, and you need insights into the cause of the failure.</span></span> 

<span data-ttu-id="f4753-484">大規模な分散システムの監視は、大きな課題です。</span><span class="sxs-lookup"><span data-stu-id="f4753-484">Monitoring a large-scale distributed system poses a significant challenge.</span></span> <span data-ttu-id="f4753-485">数十単位の VM で実行されるアプリケーションを例にして説明します。&mdash; 各 VM 1 つずつにログを記録し、ログ ファイルを確認し、問題を解決することは実用的ではありません。</span><span class="sxs-lookup"><span data-stu-id="f4753-485">Think about an application that runs on a few dozen VMs &mdash; it's not practical to log into each VM, one at a time, and look through log files, trying to troubleshoot a problem.</span></span> <span data-ttu-id="f4753-486">さらに、VM インスタンス数はおそらく静的ではありません。</span><span class="sxs-lookup"><span data-stu-id="f4753-486">Moreover, the number of VM instances is probably not static.</span></span> <span data-ttu-id="f4753-487">アプリケーションのスケールインとスケールアウトで VM 数は増減し、インスタンスが失敗して再プロビジョニングが必要になることがあります。</span><span class="sxs-lookup"><span data-stu-id="f4753-487">VMs get added and removed as the application scales in and out, and occasionally an instance may fail and need to be reprovisioned.</span></span> <span data-ttu-id="f4753-488">さらに、一般的なクラウド アプリケーションは複数のデータ ストア (App Storage、SQL Database、Cosmos DB、Redis Cache) を使用することや、単一のユーザー アクションが複数のサブシステムに広がることがあります。</span><span class="sxs-lookup"><span data-stu-id="f4753-488">In addition, a typical cloud application might use multiple data stores (Azure storage, SQL Database, Cosmos DB, Redis cache), and a single user action may span multiple subsystems.</span></span> 

<span data-ttu-id="f4753-489">監視と診断プロセスは、いくつかの異なる段階があるパイプラインと考えることができます。</span><span class="sxs-lookup"><span data-stu-id="f4753-489">You can think of the monitoring and diagnostics process as a pipeline with several distinct stages:</span></span>

![複合 SLA](./images/monitoring.png)

* <span data-ttu-id="f4753-491">**インストルメンテーション**。</span><span class="sxs-lookup"><span data-stu-id="f4753-491">**Instrumentation**.</span></span> <span data-ttu-id="f4753-492">監視と診断の生データは、多様なソースに由来します。たとえば、アプリケーション ログ、Web サーバー ログ、OS のパフォーマンス カウンター、データベース ログ、Azure プラットフォームに組み込まれている診断などです。</span><span class="sxs-lookup"><span data-stu-id="f4753-492">The raw data for monitoring and diagnostics comes from a variety of sources, including application logs, web server logs, OS performance counters, database logs, and diagnostics built into the Azure platform.</span></span> <span data-ttu-id="f4753-493">Most Azure サービスには、問題の原因特定に使用できる診断機能があります。</span><span class="sxs-lookup"><span data-stu-id="f4753-493">Most Azure services have a diagnostics feature that you can use to determine the cause of problems.</span></span>
* <span data-ttu-id="f4753-494">**収集と保存**。</span><span class="sxs-lookup"><span data-stu-id="f4753-494">**Collection and storage**.</span></span> <span data-ttu-id="f4753-495">生インストルメンテーション データは多様な場所に多様な形式で保持される可能性があります (たとえば、アプリケーション トレース ログ、IIS ログ、パフォーマンス カウンターなど)。</span><span class="sxs-lookup"><span data-stu-id="f4753-495">Raw instrumentation data can be held in various locations and with various formats (e.g., application trace logs, IIS logs, performance counters).</span></span> <span data-ttu-id="f4753-496">このようなさまざまなソースは収集され、統合されて、信頼性の高いストレージに格納されます。</span><span class="sxs-lookup"><span data-stu-id="f4753-496">These disparate sources are collected, consolidated, and put into reliable storage.</span></span>
* <span data-ttu-id="f4753-497">**分析と診断**。</span><span class="sxs-lookup"><span data-stu-id="f4753-497">**Analysis and diagnosis**.</span></span> <span data-ttu-id="f4753-498">データの統合後は、分析して問題を解決し、アプリケーションの正常性の全体を把握することができます。</span><span class="sxs-lookup"><span data-stu-id="f4753-498">After the data is consolidated, it can be analyzed to troubleshoot issues and provide an overall view of application health.</span></span>
* <span data-ttu-id="f4753-499">**視覚化とアラート**。</span><span class="sxs-lookup"><span data-stu-id="f4753-499">**Visualization and alerts**.</span></span> <span data-ttu-id="f4753-500">この段階では、オペレーターが問題や傾向にすばやく気づくことができる方法で利用統計情報が表示されます。</span><span class="sxs-lookup"><span data-stu-id="f4753-500">In this stage, telemetry data is presented in such a way that an operator can quickly notice problems or trends.</span></span> <span data-ttu-id="f4753-501">たとえば、ダッシュボードや電子メールのアラートがあります。</span><span class="sxs-lookup"><span data-stu-id="f4753-501">Example include dashboards or email alerts.</span></span>  

<span data-ttu-id="f4753-502">監視は障害の検出と同じではありません。</span><span class="sxs-lookup"><span data-stu-id="f4753-502">Monitoring is not the same as failure detection.</span></span> <span data-ttu-id="f4753-503">たとえば、アプリケーションが一時的なエラーを検出して再試行し、ダウンタイムが発生しないことがあります。</span><span class="sxs-lookup"><span data-stu-id="f4753-503">For example, your application might detect a transient error and retry, resulting in no downtime.</span></span> <span data-ttu-id="f4753-504">それでも再試行操作はログに記録されるので、エラー率を監視して、アプリケーション正常性の全体像を把握することができます。</span><span class="sxs-lookup"><span data-stu-id="f4753-504">But it should also log the retry operation, so that you can monitor the error rate, in order to get an overall picture of application health.</span></span> 

<span data-ttu-id="f4753-505">アプリケーション ログは、診断データの重要なソースです。</span><span class="sxs-lookup"><span data-stu-id="f4753-505">Application logs are an important source of diagnostics data.</span></span> <span data-ttu-id="f4753-506">アプリケーションのログ記録には、次のようなベスト プラクティスがあります。</span><span class="sxs-lookup"><span data-stu-id="f4753-506">Best practices for application logging include:</span></span>

* <span data-ttu-id="f4753-507">運用環境でログを記録します。</span><span class="sxs-lookup"><span data-stu-id="f4753-507">Log in production.</span></span> <span data-ttu-id="f4753-508">そうしないと、最も必要な場合に洞察できません。</span><span class="sxs-lookup"><span data-stu-id="f4753-508">Otherwise, you lose insight where you need it most.</span></span>
* <span data-ttu-id="f4753-509">サービスの境界でイベントのログを記録します。</span><span class="sxs-lookup"><span data-stu-id="f4753-509">Log events at service boundaries.</span></span> <span data-ttu-id="f4753-510">フローがサービス境界をまたがる関連付け ID を含めます。</span><span class="sxs-lookup"><span data-stu-id="f4753-510">Include a correlation ID that flows across service boundaries.</span></span> <span data-ttu-id="f4753-511">トランザクション フローが複数のサービスを経由し、いずれかが失敗した場合、関連付け ID でトランザクションが失敗した理由を特定できます。</span><span class="sxs-lookup"><span data-stu-id="f4753-511">If a transaction flows through multiple services and one of them fails, the correlation ID will help you pinpoint why the transaction failed.</span></span>
* <span data-ttu-id="f4753-512">セマンティック ログ (構造化ログとも呼ばれます) を使用します。</span><span class="sxs-lookup"><span data-stu-id="f4753-512">Use semantic logging, also known as structured logging.</span></span> <span data-ttu-id="f4753-513">構造化されていないログの場合、ログ データの使用と分析の自動化が困難です。こうした自動化はクラウド規模で必要になります。</span><span class="sxs-lookup"><span data-stu-id="f4753-513">Unstructured logs make it hard to automate the consumption and analysis of the log data, which is needed at cloud scale.</span></span>
* <span data-ttu-id="f4753-514">非同期のログ記録を使用します。</span><span class="sxs-lookup"><span data-stu-id="f4753-514">Use asynchronous logging.</span></span> <span data-ttu-id="f4753-515">そうしないと、ログ アプリケーションによって、ログ記録イベントの書き込みを待機中に要求がブロックされ、要求がバックアップされ、アプリケーションで障害が発生する原因になる可能性があります。</span><span class="sxs-lookup"><span data-stu-id="f4753-515">Otherwise, the logging system itself can cause the application to fail by causing requests to back up, as they block while waiting to write a logging event.</span></span>
* <span data-ttu-id="f4753-516">アプリケーションのログ記録は、監査と同じではありません。</span><span class="sxs-lookup"><span data-stu-id="f4753-516">Application logging is not the same as auditing.</span></span> <span data-ttu-id="f4753-517">監査は、コンプライアンスまたは法規制上の理由で行われることがあります。</span><span class="sxs-lookup"><span data-stu-id="f4753-517">Auditing may be done for compliance or regulatory reasons.</span></span> <span data-ttu-id="f4753-518">そのため、監査レコードは完全である必要があります。トランザクションの処理中に削除が発生することは許容されません。</span><span class="sxs-lookup"><span data-stu-id="f4753-518">As such, audit records must be complete, and it's not acceptable to drop any while processing transactions.</span></span> <span data-ttu-id="f4753-519">アプリケーションに監査が必要な場合、診断ログとは別に維持する必要があります。</span><span class="sxs-lookup"><span data-stu-id="f4753-519">If an application requires auditing, this should be kept separate from diagnostics logging.</span></span> 

<span data-ttu-id="f4753-520">監視と診断の詳細については、「[Monitoring and diagnostics guidance][monitoring-guidance]」(監査と診断のガイダンス) を参照してください。</span><span class="sxs-lookup"><span data-stu-id="f4753-520">For more information about monitoring and diagnostics, see [Monitoring and diagnostics guidance][monitoring-guidance].</span></span>

## <a name="respond-to-failures"></a><span data-ttu-id="f4753-521">障害に対応する</span><span class="sxs-lookup"><span data-stu-id="f4753-521">Respond to failures</span></span>
<span data-ttu-id="f4753-522">これまでのセクションでは、高可用性に重要な自動的な復旧戦略を中心に説明してきましたが、</span><span class="sxs-lookup"><span data-stu-id="f4753-522">Previous sections have focused on automated recovery strategies, which are critical for high availability.</span></span> <span data-ttu-id="f4753-523">手動操作が必要な場合もあります。</span><span class="sxs-lookup"><span data-stu-id="f4753-523">However, sometimes manual intervention is needed.</span></span>

* <span data-ttu-id="f4753-524">**[Alerts]** (アラート)。</span><span class="sxs-lookup"><span data-stu-id="f4753-524">**Alerts**.</span></span> <span data-ttu-id="f4753-525">アプリケーションで、積極的な介入が必要な可能性がある警告の兆候を監視します。</span><span class="sxs-lookup"><span data-stu-id="f4753-525">Monitor your application for warning signs that may require proactive intervention.</span></span> <span data-ttu-id="f4753-526">たとえば、SQL Database または Cosmos DB がアプリケーションを常に調整している場合は、データベース容量の増加や、クエリの最適化が必要な可能性があります。</span><span class="sxs-lookup"><span data-stu-id="f4753-526">For example, if you see that SQL Database or Cosmos DB consistently throttles your application, you might need to increase your database capacity or optimize your queries.</span></span> <span data-ttu-id="f4753-527">この例では、アプリケーションが調整エラーを透過的に処理している場合でも、利用統計情報でアラートが報告されるので、対応することができます。</span><span class="sxs-lookup"><span data-stu-id="f4753-527">In this example, even though the application might handle the throttling errors transparently, your telemetry should still raise an alert so that you can follow up.</span></span>  
* <span data-ttu-id="f4753-528">**手動フェールオーバー**。</span><span class="sxs-lookup"><span data-stu-id="f4753-528">**Manual failover**.</span></span> <span data-ttu-id="f4753-529">一部のシステムは自動的にフェールオーバーせず、手動フェールオーバーが必要です。</span><span class="sxs-lookup"><span data-stu-id="f4753-529">Some systems cannot fail over automatically and require a manual failover.</span></span> 
* <span data-ttu-id="f4753-530">**運用準備状況のテスト**。</span><span class="sxs-lookup"><span data-stu-id="f4753-530">**Operational readiness testing**.</span></span> <span data-ttu-id="f4753-531">アプリケーションがセカンダリ リージョンにフェールオーバーした場合、運用準備状況のテストを実行してから、プライマリ リージョンにフェールバックすることをお勧めします。</span><span class="sxs-lookup"><span data-stu-id="f4753-531">If your application fails over to a secondary region, you should perform an operational readiness test before you fail back to the primary region.</span></span> <span data-ttu-id="f4753-532">テストでは、プライマリ リージョンが正常で、トラフィックを再び受け取る準備が整っていることを確認します。</span><span class="sxs-lookup"><span data-stu-id="f4753-532">The test should verify that the primary region is healthy and ready to receive traffic again.</span></span>
* <span data-ttu-id="f4753-533">**データ整合性チェック**。</span><span class="sxs-lookup"><span data-stu-id="f4753-533">**Data consistency check**.</span></span> <span data-ttu-id="f4753-534">データ ストアで障害が発生した場合、特にデータがレプリケートされた場合には、ストアを再び使用可能な状態にするときにデータに整合性がある必要があります。</span><span class="sxs-lookup"><span data-stu-id="f4753-534">If a failure happens in a data store, there may be data inconsistencies when the store becomes available again, especially if the data was replicated.</span></span> 
* <span data-ttu-id="f4753-535">**バックアップからの復元**。</span><span class="sxs-lookup"><span data-stu-id="f4753-535">**Restoring from backup**.</span></span> <span data-ttu-id="f4753-536">たとえば、SQL Database で地域的な停電が発生した場合、最新のバックアップからデータベースの geo リストアを実行する方法があります。</span><span class="sxs-lookup"><span data-stu-id="f4753-536">For example, if SQL Database experiences a regional outage, you can geo-restore the database from the latest backup.</span></span>

<span data-ttu-id="f4753-537">ディザスター リカバリー計画を文書化し、テストします。</span><span class="sxs-lookup"><span data-stu-id="f4753-537">Document and test your disaster recovery plan.</span></span> <span data-ttu-id="f4753-538">アプリケーションの障害によるビジネスの影響を評価します。</span><span class="sxs-lookup"><span data-stu-id="f4753-538">Evaluate the business impact of application failures.</span></span> <span data-ttu-id="f4753-539">できるだけ多くのプロセスを自動化し、手動の手順を文書化します。たとえば、バックアップからの手動のフェールオーバーやデータの復元などです。</span><span class="sxs-lookup"><span data-stu-id="f4753-539">Automate the process as much as possible, and document any manual steps, such as manual failover or data restoration from backups.</span></span> <span data-ttu-id="f4753-540">ディザスター リカバリー プロセスは定期的にテストし、計画の検証と改善を行います。</span><span class="sxs-lookup"><span data-stu-id="f4753-540">Regularly test your disaster recovery process to validate and improve the plan.</span></span> 

## <a name="summary"></a><span data-ttu-id="f4753-541">まとめ</span><span class="sxs-lookup"><span data-stu-id="f4753-541">Summary</span></span>
<span data-ttu-id="f4753-542">この記事では、クラウド固有の一部の課題を特に取り上げながら、包括的な観点から回復性について説明しました。</span><span class="sxs-lookup"><span data-stu-id="f4753-542">This article discussed resiliency from a holistic perspective, emphasizing some of the unique challenges of the cloud.</span></span> <span data-ttu-id="f4753-543">たとえば、クラウド コンピューティングの分散の特性、汎用的なハードウェアの使用、一時的なネットワーク障害の存在などです。</span><span class="sxs-lookup"><span data-stu-id="f4753-543">These include the distributed nature of cloud computing, the use of commodity hardware, and the presence of transient network faults.</span></span>

<span data-ttu-id="f4753-544">この記事の主な点を次に示します。</span><span class="sxs-lookup"><span data-stu-id="f4753-544">Here are the major points to take away from this article:</span></span>

* <span data-ttu-id="f4753-545">回復性によって可用性が高くなり、障害からの平均復旧時間が短くなります。</span><span class="sxs-lookup"><span data-stu-id="f4753-545">Resiliency leads to higher availability, and lower mean time to recover from failures.</span></span> 
* <span data-ttu-id="f4753-546">クラウドで回復性を実現するには、従来のオンプレミス ソリューションのさまざまな手法が必要です。</span><span class="sxs-lookup"><span data-stu-id="f4753-546">Achieving resiliency in the cloud requires a different set of techniques from traditional on-premises solutions.</span></span> 
* <span data-ttu-id="f4753-547">偶発的に回復性が実現することはありません。</span><span class="sxs-lookup"><span data-stu-id="f4753-547">Resiliency does not happen by accident.</span></span> <span data-ttu-id="f4753-548">初期段階から設計し、構築する必要があります。</span><span class="sxs-lookup"><span data-stu-id="f4753-548">It must be designed and built in from the start.</span></span>
* <span data-ttu-id="f4753-549">回復性は、計画、コーディングから運用まで、アプリケーションのライフサイクルのあらゆる部分に関係します。</span><span class="sxs-lookup"><span data-stu-id="f4753-549">Resiliency touches every part of the application lifecycle, from planning and coding to operations.</span></span>
* <span data-ttu-id="f4753-550">テストと監視をお勧めします。</span><span class="sxs-lookup"><span data-stu-id="f4753-550">Test and monitor!</span></span>


<!-- links -->

[blue-green]: https://martinfowler.com/bliki/BlueGreenDeployment.html
[canary-release]: https://martinfowler.com/bliki/CanaryRelease.html
[circuit-breaker-pattern]: https://msdn.microsoft.com/library/dn589784.aspx
[compensating-transaction-pattern]: https://msdn.microsoft.com/library/dn589804.aspx
[containers]: https://en.wikipedia.org/wiki/Operating-system-level_virtualization
[dsc]: /azure/automation/automation-dsc-overview
[contingency-planning-guide]: https://nvlpubs.nist.gov/nistpubs/Legacy/SP/nistspecialpublication800-34r1.pdf
[fma]: failure-mode-analysis.md
[hystrix]: https://medium.com/netflix-techblog/introducing-hystrix-for-resilience-engineering-13531c1ab362
[jmeter]: https://jmeter.apache.org/
[load-leveling-pattern]: ../patterns/queue-based-load-leveling.md
[monitoring-guidance]: ../best-practices/monitoring.md
[ra-basic-web]: ../reference-architectures/app-service-web-app/basic-web-app.md
[ra-multi-vm]: ../reference-architectures/virtual-machines-windows/multi-vm.md
[checklist]: ../checklist/resiliency.md
[retry-pattern]: ../patterns/retry.md
[retry-service-specific guidance]: ../best-practices/retry-service-specific.md
[sla]: https://azure.microsoft.com/support/legal/sla/
[throttling-pattern]: ../patterns/throttling.md
[tm]: https://azure.microsoft.com/services/traffic-manager/
[tm-failover]: /azure/traffic-manager/traffic-manager-monitoring
[tm-sla]: https://azure.microsoft.com/support/legal/sla/traffic-manager/v1_0/
